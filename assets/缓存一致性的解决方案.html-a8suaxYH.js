import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as a,a as r}from"./app-BpSwnEP9.js";const s="/assets/image-20240730223613763-CFmh5wsh.png",n="/assets/image-20240802114221312-DzoNBZnp.png",o="/assets/image-20240802120203791-2fvA4LvC.png",i="/assets/image-20240802114742724-POPc6KOx.png",d="/assets/image-20240802114826597-H-Nh74Gk.png",l="/assets/image-20240802115807382-t7l4qceR.png",p="/assets/image-20240802115739500-C1r6euq8.png",g="/assets/image-20240802115749157-qVwnp-4H.png",h="/assets/image-20240802115344409-CDcbErhs.png",c="/assets/image-20240802115449018-C6oTprX0.png",m="/assets/image-20240802115504421-DGVkuTJH.png",u="/assets/image-20240802115552990-o2_1CFFN.png",_={},b=r('<blockquote><p>文章内容来自：</p><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649766984&amp;idx=1&amp;sn=fb6dcafedc845584049c56ba6fedc13c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">浅谈缓存最终一致性的解决方案</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/VprIIqJ4wdqMiXY8LRXAJA" target="_blank" rel="noopener noreferrer">浅谈缓存一致性</a></p></li></ul></blockquote><h2 id="引入" tabindex="-1"><a class="header-anchor" href="#引入"><span>引入</span></a></h2><p>持久化层和缓存层的一致性问题也通常被称为双写一致性问题。对于一致性来说，有强一致性和弱一致性。</p><ul><li>强一致性保证写入后立即可以读取。</li><li>弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在<strong>经过一定时间后</strong>可以读取到。</li></ul><p>在弱一致性中应用最为广泛的模型则是「最终一致性模型」，即保证在一定时间之后写入和读取达到一致的状态。</p><h2 id="旁路缓存模式-cache-aside" tabindex="-1"><a class="header-anchor" href="#旁路缓存模式-cache-aside"><span>旁路缓存模式（Cache-Aside）</span></a></h2><p><strong>Cache-Aside 旁路缓存模式</strong>，是应用最为广泛的一种缓存策略。</p><ul><li><p><strong>在读请求中</strong>，首先请求缓存，若缓存命中（cache hit），则直接返回缓存中的数据；若缓存未命中（cache miss），则查询数据库并将查询结果更新至缓存，然后返回查询出的数据（demand-filled look-aside）。</p></li><li><p><strong>在写请求中</strong>，先更新数据库，再删除缓存（write-invalidate）。</p></li></ul><p><img src="'+s+'" alt="image-20240730223613763" loading="lazy"></p><h3 id="为什么删除缓存-而不是更新缓存" tabindex="-1"><a class="header-anchor" href="#为什么删除缓存-而不是更新缓存"><span>为什么删除缓存，而不是更新缓存</span></a></h3><ul><li>在写操作中，当该缓存对应的结果需要消耗大量的计算过程才能得到时，更新缓存会是一笔不小的开销。</li><li>当写操作较多时，可能也会存在<strong>刚更新的缓存还没有被读取到，又再次被更新</strong>的情况。</li><li>删除缓存的操作不仅是幂等的，可以在发生异常时重试，而且<strong>写-删除</strong>和<strong>读-更新</strong>在语义上更加对称。</li></ul><p>在并发场景下，<strong>在写请求中更新缓存可能会引发数据的不一致问题</strong>：有两个线程去更新同一个数值，线程 A 把数据更新为 1，线程 B 把数据更新为 2，我们期望的结果是以下两种情况之一：</p><ol><li>「数据库」里的数据是 1 且「缓存」里的数据也是 1；</li><li>「数据库」里的数据是 2 且「缓存」里的数据也是 2；</li></ol><p>模拟并发写场景：</p><p><img src="'+n+'" alt="image-20240802114221312" loading="lazy"></p><table><thead><tr><th><strong>时刻</strong></th><th><strong>线程A（写）</strong></th><th><strong>线程B（写）</strong></th></tr></thead><tbody><tr><td><strong>T1</strong></td><td>更新数据库为 1</td><td></td></tr><tr><td><strong>T2</strong></td><td></td><td>更数据库为 2</td></tr><tr><td><strong>T3</strong></td><td></td><td>更新缓存为 2</td></tr><tr><td><strong>T4</strong></td><td>更新缓存为 1</td><td></td></tr></tbody></table><p><strong>这个时候如果有 读请求 命中缓存，读取的便是旧值</strong></p><h3 id="为什么先更新数据库-而不是先删除缓存" tabindex="-1"><a class="header-anchor" href="#为什么先更新数据库-而不是先删除缓存"><span>为什么先更新数据库，而不是先删除缓存？</span></a></h3><p>在单线程下，在删除缓存成功，但更新数据库失败的场景下。尽管缓存被删除了，下次读操作时，仍能将正确的数据写回缓存。这种方式看起来有一定的合理性。相对于 Cache-Aside 中更新数据库成功，删除缓存失败的场景来说，先删除缓存的方案似乎更合理一些。</p><p>在并发读写的场景下仍然存在不一致的问题：</p><p>考虑这样的场景：目前 a 在缓存和数据库的值都为 <strong>1，现在有线程 A 去将 a 修改为 2，同时有线程 B 去读取 a</strong>，我们期望的结果是以下两种情况之一：</p><ol><li><p>a 在「缓存」中失效且 a 在「数据库」中的值是 2；</p></li><li><p>a 在「缓存」中的值是 2 且 a 在「数据库」中的值是 2。</p></li></ol><p><img src="'+o+'" alt="image-20240802120203791" loading="lazy"></p><table><thead><tr><th><strong>时刻</strong></th><th><strong>线程A（写）</strong></th><th><strong>线程B（读）</strong></th></tr></thead><tbody><tr><td><strong>T1</strong></td><td>删除缓存 a</td><td></td></tr><tr><td><strong>T2</strong></td><td></td><td>先读缓存，发现缓存未命中；从数据库中读取 a 的值为1</td></tr><tr><td><strong>T3</strong></td><td></td><td>更新 a 缓存为 1</td></tr><tr><td><strong>T4</strong></td><td>更新数据库 a 的值为 2</td><td></td></tr></tbody></table><p>这个时候 读请求 读取到的是旧值（即缓存落后于数据库）</p><h3 id="延迟双删" tabindex="-1"><a class="header-anchor" href="#延迟双删"><span>延迟双删</span></a></h3><p>为了避免“先删除缓存，再更新数据库”这一方案在读写并发时可能带来的缓存脏数据。业界提出了 <strong>延迟双删</strong> 的策略。</p><blockquote><p>延迟双删：<strong>在更新数据库之后，延迟一段时间再次删除缓存。为了保证第二次删除缓存的时间点在 读请求 更新缓存之后，这个延迟时间的经验值通常应稍大于业务中读请求的耗时。</strong></p></blockquote><p><img src="'+i+'" alt="image-20240802114742724" loading="lazy"></p><h3 id="cache-aside-也存在数据不一致" tabindex="-1"><a class="header-anchor" href="#cache-aside-也存在数据不一致"><span>Cache-Aside 也存在数据不一致</span></a></h3><p><strong>目前 a 数据库的值为 1 且在缓存中失效，现在有线程 A 去将 a 修改为 2，同时有线程 B 去读取 a</strong>，我们期望的结果是以下两种情况之一：</p><ol><li><p>a 在「缓存」中失效且 a 在「数据库」中的值是 2；</p></li><li><p>a 在「缓存」中的值是 2 且 a 在「数据库」中的值是 2。</p></li></ol><p><img src="'+d+'" alt="image-20240802114826597" loading="lazy"></p><table><thead><tr><th><strong>时刻</strong></th><th><strong>线程A（写）</strong></th><th><strong>线程B（读）</strong></th></tr></thead><tbody><tr><td><strong>T1</strong></td><td></td><td>先读缓存，发现缓存失效；从数据库中读取 a 的值为 1</td></tr><tr><td><strong>T2</strong></td><td>更新数据库 a 的值为 2</td><td></td></tr><tr><td><strong>T3</strong></td><td>删除缓存 a</td><td></td></tr><tr><td><strong>T4</strong></td><td></td><td>更新 a 缓存为 1</td></tr></tbody></table><p>这种场景的出现，</p><ul><li><strong>需要缓存失效</strong>且<strong>读写并发执行</strong></li><li>读请求查询数据库的执行 早于 写请求更新数据库，同时读请求的执行完成 晚于 写请求。</li></ul><p>读请求命中缓存的时间点在写请求更新数据库之后，删除缓存之前的情况如下：</p><p></p><table><thead><tr><th><strong>时刻</strong></th><th><strong>线程A（写）</strong></th><th><strong>线程B（读）</strong></th></tr></thead><tbody><tr><td><strong>T1</strong></td><td>更新数据库 a 的值为 2</td><td></td></tr><tr><td><strong>T2</strong></td><td></td><td>先读缓存，缓存命中，缓存为1</td></tr><tr><td><strong>T3</strong></td><td>删除缓存 a</td><td></td></tr></tbody></table><p><img src="'+l+'" alt="image-20240802115807382" loading="lazy"></p><p>业务层面对这种情况的容忍度较低，那么可以采用加锁在写请求中保证**【更新数据库&amp;删除缓存】<strong>的串行执行为原子性操作，同理也可对读请求中</strong>【缓存更新】**加锁</p><p><img src="'+p+'" alt="image-20240802115739500" loading="lazy"></p><p><img src="'+g+'" alt="image-20240802115749157" loading="lazy"></p><h3 id="补偿机制" tabindex="-1"><a class="header-anchor" href="#补偿机制"><span>补偿机制</span></a></h3><p>在 Cache-Aside 中可能存在更新数据库成功，但删除缓存失败的场景，如果这种情况发生，那么便会导致缓存中的数据落后于数据库，产生数据的不一致的问题。</p><h4 id="删除重试机制" tabindex="-1"><a class="header-anchor" href="#删除重试机制"><span>删除重试机制</span></a></h4><p>通过引入消息队列，将删除失败的缓存对应的 <code>key</code> 放入消息队列中，在对应的消费者中获取删除失败的 <code>key</code>，异步重试删除。</p><p>这种方法在实现上相对简单，但由于删除失败后的逻辑需要基于业务代码的 trigger 来触发 ，对业务代码具有一定入侵性。</p><p><img src="'+h+'" alt="image-20240802115344409" loading="lazy"></p><h4 id="read-through-读穿透模式" tabindex="-1"><a class="header-anchor" href="#read-through-读穿透模式"><span>Read-Through（读穿透模式）</span></a></h4><p>Read-Through 中多了一个访问控制层，<strong>读请求只和该访问控制层进行交互</strong>，而背后缓存命中与否的逻辑则由访问控制层与数据源进行交互，业务层的实现会更加简洁，并且对于缓存层及持久化层交互的封装程度更高，更易于移植。</p><p><img src="'+c+'" alt="image-20240802115449018" loading="lazy"></p><h4 id="write-through-直写模式" tabindex="-1"><a class="header-anchor" href="#write-through-直写模式"><span>Write-Through（直写模式）</span></a></h4><p>它也增加了访问控制层来提供更高程度的封装。不同于 Cache-Aside 的是，<strong>Write-Through 直写模式在写请求更新数据库之后，并不会删除缓存，而是更新缓存</strong>。</p><p><img src="'+m+'" alt="image-20240802115504421" loading="lazy"></p><p>弊端：</p><ul><li>上面我们提到的更新数据库再更新缓存的弊端</li><li>更新效率低</li><li>两个写操作任何一次写失败都会造成数据不一致</li></ul><p>解决：</p><ul><li>将这两个操作作为事务处理，可以同时失败或者同时成功，支持回滚，并且防止并发环境下的不一致。</li><li>分布式锁解决，保证对缓存和数据库的操作仅能由同一个线程完成。对于没有拿到锁的线程，一是通过锁的 <code>timeout</code> 时间进行控制，二是将请求暂存在消息队列中顺序消费。</li></ul><h4 id="write-behind-异步回写模式" tabindex="-1"><a class="header-anchor" href="#write-behind-异步回写模式"><span>Write-Behind（异步回写模式）</span></a></h4><p>Write behind 在处理写请求时，只更新缓存而不更新数据库。</p><p>对于数据库的更新，则是通过批量异步更新的方式进行的，<strong>批量写入的时间点可以选在数据库负载较低的时间进行</strong>。</p><blockquote><p>如何判断数据库负载较低？</p></blockquote><p><img src="'+u+'" alt="image-20240802115552990" loading="lazy"></p><p>在 Write-Behind 模式下，写请求延迟较低，减轻了数据库的压力，具有较好的吞吐性。</p><p>弊端：</p><ul><li><strong>数据库和缓存的一致性较弱</strong>，比如当更新的数据还未被写入数据库时，直接从数据库中查询数据是落后于缓存的。</li><li>缓存的负载较大，如果缓存宕机会导致数据丢失，所以需要做好缓存的高可用。</li></ul><h4 id="write-around" tabindex="-1"><a class="header-anchor" href="#write-around"><span>Write-Around</span></a></h4><p>如果一些非核心业务，对一致性的要求较弱，可以选择在 cache aside 读模式下增加一个<strong>缓存过期时间</strong>，在写请求中仅仅更新数据库。但缓存中的数据和数据库数据一致性较差，往往会造成用户的体验较差，应慎重选择。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>读多写少的场景下，可以选择采用**“ Cache-Aside 结合消费数据库日志做补偿”**的方案，</p><p>写多的场景下，可以选择采用**“ Write-Through 结合分布式锁”**的方案 ，</p><p>写多的极端场景下，可以选择采用**“ Write-Behind ”** 的方案。</p>',73),f=[b];function A(y,w){return a(),e("div",null,f)}const q=t(_,[["render",A],["__file","缓存一致性的解决方案.html.vue"]]),x=JSON.parse('{"path":"/other/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html","title":"","lang":"zh-CN","frontmatter":{"description":"文章内容来自： 浅谈缓存最终一致性的解决方案 浅谈缓存一致性 引入 持久化层和缓存层的一致性问题也通常被称为双写一致性问题。对于一致性来说，有强一致性和弱一致性。 强一致性保证写入后立即可以读取。 弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在经过一定时间后可以读取到。 在弱一致性中应用最为广泛的模型则是「最终一致性模型」，即保证在一定时间...","head":[["meta",{"property":"og:url","content":"https://doublew2w.cn/other/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"}],["meta",{"property":"og:site_name","content":"DoubleW2w"}],["meta",{"property":"og:description","content":"文章内容来自： 浅谈缓存最终一致性的解决方案 浅谈缓存一致性 引入 持久化层和缓存层的一致性问题也通常被称为双写一致性问题。对于一致性来说，有强一致性和弱一致性。 强一致性保证写入后立即可以读取。 弱一致性则不保证立即可以读取写入后的值，而是尽可能的保证在经过一定时间后可以读取到。 在弱一致性中应用最为广泛的模型则是「最终一致性模型」，即保证在一定时间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-27T16:18:14.000Z"}],["meta",{"property":"article:author","content":"Doublew2w"}],["meta",{"property":"article:modified_time","content":"2024-11-27T16:18:14.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-11-27T16:18:14.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Doublew2w\\",\\"url\\":\\"https://doublew2w.cn\\"}]}"]]},"headers":[{"level":2,"title":"引入","slug":"引入","link":"#引入","children":[]},{"level":2,"title":"旁路缓存模式（Cache-Aside）","slug":"旁路缓存模式-cache-aside","link":"#旁路缓存模式-cache-aside","children":[{"level":3,"title":"为什么删除缓存，而不是更新缓存","slug":"为什么删除缓存-而不是更新缓存","link":"#为什么删除缓存-而不是更新缓存","children":[]},{"level":3,"title":"为什么先更新数据库，而不是先删除缓存？","slug":"为什么先更新数据库-而不是先删除缓存","link":"#为什么先更新数据库-而不是先删除缓存","children":[]},{"level":3,"title":"延迟双删","slug":"延迟双删","link":"#延迟双删","children":[]},{"level":3,"title":"Cache-Aside 也存在数据不一致","slug":"cache-aside-也存在数据不一致","link":"#cache-aside-也存在数据不一致","children":[]},{"level":3,"title":"补偿机制","slug":"补偿机制","link":"#补偿机制","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]}],"git":{"createdTime":1732724294000,"updatedTime":1732724294000,"contributors":[{"name":"DoubleW2w","email":"1049951363@qq.com","commits":1}]},"readingTime":{"minutes":7.8,"words":2339},"filePathRelative":"other/缓存一致性的解决方案.md","localizedDate":"2024年11月27日","excerpt":"<blockquote>\\n<p>文章内容来自：</p>\\n<ul>\\n<li>\\n<p><a href=\\"https://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;mid=2649766984&amp;idx=1&amp;sn=fb6dcafedc845584049c56ba6fedc13c&amp;scene=21#wechat_redirect\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">浅谈缓存最终一致性的解决方案</a></p>\\n</li>\\n<li>\\n<p><a href=\\"https://mp.weixin.qq.com/s/VprIIqJ4wdqMiXY8LRXAJA\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">浅谈缓存一致性</a></p>\\n</li>\\n</ul>\\n</blockquote>","autoDesc":true}');export{q as comp,x as data};
