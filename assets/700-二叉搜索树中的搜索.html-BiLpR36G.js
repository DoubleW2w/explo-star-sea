import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,o as t,a as l,b as i,e as s}from"./app-ClhoyXrL.js";const n={},h=l(`<h2 id="题目地址-700-二叉搜索树中的搜索-力扣-leetcode" tabindex="-1"><a class="header-anchor" href="#题目地址-700-二叉搜索树中的搜索-力扣-leetcode"><span>题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）)</span></a></h2><p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/" target="_blank" rel="noopener noreferrer">https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/</a></p><h2 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述"><span>题目描述</span></a></h2><p> 给定二叉搜索树（BST）的根节点 <meta charset="UTF-8">  <code> root </code>  和一个整数值 <meta charset="UTF-8">  <code> val </code>。</p><p> 你需要在 BST 中找到节点值等于  <code> val </code>  的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <meta charset="UTF-8">  <code> null </code> 。</p><p>  </p><p><strong> 示例 1: </strong></p><p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" style="height:179px;width:250px;"> <meta charset="UTF-8"></p><pre> <b> 输入：</b> root = [4,2,7,1,3], val = 2
<b> 输出：</b> [2,1,3]
</pre><p><strong> 示例 2: </strong></p><img alt="" src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" style="height:179px;width:250px;"><pre> <b> 输入：</b> root = [4,2,7,1,3], val = 5
<b> 输出：</b> []
</pre><p>  </p><p><strong> 提示：</strong></p><ul><li> 树中节点数在  <code> [1, 5000] </code>  范围内 </li><li><code> 1 &lt;= Node.val &lt;= 10 <sup> 7 </sup></code></li><li><code> root </code>  是二叉搜索树 </li><li><code> 1 &lt;= val &lt;= 10 <sup> 7 </sup></code></li></ul><h2 id="思路-中序遍历" tabindex="-1"><a class="header-anchor" href="#思路-中序遍历"><span>思路：中序遍历</span></a></h2><p>对于一棵二叉搜索树来说，中序遍历的结果是一个单调递增的数组。</p><p>递归函数定义：</p><ol><li>返回值是树的节点，参数是树 root 和目标值 target</li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> TreeNode</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> searchBST</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> val)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="2"><li>递归终止条件：如果树为空，直接返回 null，如果搜索到叶子节点还没找到，也返回 null</li><li>递归函数逻辑 <ol><li>如果当前节点比 val 小 <code>root.val &lt; val</code>，说明要往 root 的右子树搜索</li><li>如果当前节点比 val 大 <code>root.val &gt; val</code>，说明要往 root 的左子树搜索</li><li>否则就是当前节点</li></ol></li></ol><h2 id="关键点" tabindex="-1"><a class="header-anchor" href="#关键点"><span>关键点</span></a></h2><ul><li>抓住二叉搜索树的特性</li><li>左子树的节点都比根节点小</li><li>右子树的节点都比根节点大</li><li>并且左右子树都是二叉搜索树</li></ul><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h2><ul><li>语言支持：Java</li></ul><p>Java Code:</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * Definition for a binary tree node.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * public class TreeNode {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * int val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * TreeNode left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * TreeNode right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * TreeNode() {}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * TreeNode(int val) { this.val = val; }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * TreeNode(int val, TreeNode left, TreeNode right) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * this.val = val;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * this.left = left;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * this.right = right;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> * }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#E5C07B;"> Solution</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> TreeNode</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> searchBST</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">TreeNode</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#E06C75;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"> val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (root </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (val </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) root </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">left</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            else</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (val </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) root </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> root</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">right</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">            else</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> root;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>复杂度分析</strong></p><p>令 n 为节点个数。</p>`,29),r=i("ul",null,[i("li",null,[s("时间复杂度："),i("span",{class:"katex"},[i("span",{class:"katex-mathml"},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("semantics",null,[i("mrow",null,[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"n"),i("mo",{stretchy:"false"},")")]),i("annotation",{encoding:"application/x-tex"},"O(n)")])])]),i("span",{class:"katex-html","aria-hidden":"true"},[i("span",{class:"base"},[i("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),i("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),i("span",{class:"mopen"},"("),i("span",{class:"mord mathnormal"},"n"),i("span",{class:"mclose"},")")])])]),s("，遍历的节点个数")]),i("li",null,[s("空间复杂度："),i("span",{class:"katex"},[i("span",{class:"katex-mathml"},[i("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[i("semantics",null,[i("mrow",null,[i("mi",null,"O"),i("mo",{stretchy:"false"},"("),i("mi",null,"n"),i("mo",{stretchy:"false"},")")]),i("annotation",{encoding:"application/x-tex"},"O(n)")])])]),i("span",{class:"katex-html","aria-hidden":"true"},[i("span",{class:"base"},[i("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),i("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),i("span",{class:"mopen"},"("),i("span",{class:"mord mathnormal"},"n"),i("span",{class:"mclose"},")")])])]),s("，最坏情况下递归需要 O(n) 的栈空间。")])],-1),p=[h,r];function k(d,o){return t(),e("div",null,p)}const y=a(n,[["render",k],["__file","700-二叉搜索树中的搜索.html.vue"]]),m=JSON.parse('{"path":"/leetcode/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html","title":"700-二叉搜索树中的搜索","lang":"zh-CN","frontmatter":{"title":"700-二叉搜索树中的搜索","date":"2024-07-28T00:00:00.000Z","tag":"二叉树","category":"LeetCode","description":"题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）) https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/ 题目描述 给定二叉搜索树（BST）的根节点 root 和一个整数值 val 。 你需要在 BST 中找到节点值等于 ...","head":[["meta",{"property":"og:url","content":"https://doublew2w.cn/leetcode/700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html"}],["meta",{"property":"og:site_name","content":"DoubleW2w"}],["meta",{"property":"og:title","content":"700-二叉搜索树中的搜索"}],["meta",{"property":"og:description","content":"题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）) https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/ 题目描述 给定二叉搜索树（BST）的根节点 root 和一个整数值 val 。 你需要在 BST 中找到节点值等于 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-11-30T16:11:02.000Z"}],["meta",{"property":"article:author","content":"Doublew2w"}],["meta",{"property":"article:tag","content":"二叉树"}],["meta",{"property":"article:published_time","content":"2024-07-28T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-11-30T16:11:02.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"700-二叉搜索树中的搜索\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-28T00:00:00.000Z\\",\\"dateModified\\":\\"2024-11-30T16:11:02.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Doublew2w\\",\\"url\\":\\"https://doublew2w.cn\\"}]}"]]},"headers":[{"level":2,"title":"题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）)","slug":"题目地址-700-二叉搜索树中的搜索-力扣-leetcode","link":"#题目地址-700-二叉搜索树中的搜索-力扣-leetcode","children":[]},{"level":2,"title":"题目描述","slug":"题目描述","link":"#题目描述","children":[]},{"level":2,"title":"思路：中序遍历","slug":"思路-中序遍历","link":"#思路-中序遍历","children":[]},{"level":2,"title":"关键点","slug":"关键点","link":"#关键点","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]}],"git":{"createdTime":1732983062000,"updatedTime":1732983062000,"contributors":[{"name":"DoubleW2w","email":"1049951363@qq.com","commits":1}]},"readingTime":{"minutes":2.07,"words":620},"filePathRelative":"leetcode/700-二叉搜索树中的搜索.md","localizedDate":"2024年7月28日","excerpt":"<h2>题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）)</h2>\\n<p><a href=\\"https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/</a></p>","autoDesc":true}');export{y as comp,m as data};
