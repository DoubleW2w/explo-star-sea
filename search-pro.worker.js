const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":216,\"nextId\":216,\"documentIds\":{\"0\":\"0\",\"1\":\"2\",\"2\":\"2#介绍\",\"3\":\"3\",\"4\":\"3#关于我\",\"5\":\"4\",\"6\":\"5\",\"7\":\"5@0\",\"8\":\"6\",\"9\":\"6@0\",\"10\":\"6@1\",\"11\":\"7\",\"12\":\"7@0\",\"13\":\"7@1\",\"14\":\"8\",\"15\":\"8#markdown-介绍\",\"16\":\"8#markdown-配置\",\"17\":\"8#markdown-扩展\",\"18\":\"8#vuepress-扩展\",\"19\":\"8#主题扩展\",\"20\":\"8#选项卡\",\"21\":\"8#脚注\",\"22\":\"8#导入文件\",\"23\":\"8#tex-语法\",\"24\":\"8#任务列表\",\"25\":\"8#图片增强\",\"26\":\"8#上下角标\",\"27\":\"8#组件\",\"28\":\"8@0\",\"29\":\"8@1\",\"30\":\"9\",\"31\":\"9#页面标题\",\"32\":\"9#页面信息\",\"33\":\"9#页面内容\",\"34\":\"9#组件\",\"35\":\"9@0\",\"36\":\"9@1\",\"37\":\"10\",\"38\":\"10#题目地址-1-两数之和-力扣-leetcode\",\"39\":\"10#题目描述\",\"40\":\"10#前置知识\",\"41\":\"10#思路\",\"42\":\"10#关键点\",\"43\":\"10#代码\",\"44\":\"10@1\",\"45\":\"11\",\"46\":\"11#题目地址-142-环形链表-ii-力扣-leetcode\",\"47\":\"11#题目描述\",\"48\":\"11#前置知识\",\"49\":\"11#思路\",\"50\":\"11#关键点\",\"51\":\"11#代码\",\"52\":\"11@1\",\"53\":\"12\",\"54\":\"12#题目地址-19-删除链表的倒数第-n-个结点-力扣-leetcode\",\"55\":\"12#题目描述\",\"56\":\"12#前置知识\",\"57\":\"12#思路-1-双指针\",\"58\":\"12#关键点\",\"59\":\"12#代码\",\"60\":\"12@1\",\"61\":\"13\",\"62\":\"13#题目地址-202-快乐数-力扣-leetcode\",\"63\":\"13#题目描述\",\"64\":\"13#前置知识\",\"65\":\"13#思路\",\"66\":\"13#关键点\",\"67\":\"13#代码\",\"68\":\"13@1\",\"69\":\"14\",\"70\":\"14#题目地址-203-移除链表元素-力扣-leetcode\",\"71\":\"14#题目描述\",\"72\":\"14#思路1-直接删除\",\"73\":\"14#关键点\",\"74\":\"14#代码\",\"75\":\"14#思路2-虚拟头节点\",\"76\":\"14#关键点-1\",\"77\":\"14#代码-1\",\"78\":\"14@1\",\"79\":\"15\",\"80\":\"15#题目地址-206-反转链表-力扣-leetcode\",\"81\":\"15#题目描述\",\"82\":\"15#前置知识\",\"83\":\"15#思路1-双指针\",\"84\":\"15#关键点\",\"85\":\"15#代码\",\"86\":\"15#思路2-递归\",\"87\":\"15#关键点-1\",\"88\":\"15#代码-1\",\"89\":\"15@1\",\"90\":\"16\",\"91\":\"16#题目地址-209-长度最小的子数组-力扣-leetcode\",\"92\":\"16#题目描述\",\"93\":\"16#前置知识\",\"94\":\"16#思路1-滑动窗口\",\"95\":\"16#关键点\",\"96\":\"16#代码\",\"97\":\"17\",\"98\":\"17#题目地址-24-两两交换链表中的节点-力扣-leetcode\",\"99\":\"17#题目描述\",\"100\":\"17#前置知识\",\"101\":\"17#思路1-虚拟头节点\",\"102\":\"17#关键点\",\"103\":\"17#代码\",\"104\":\"18\",\"105\":\"18#题目地址-242-有效的字母异位词-力扣-leetcode\",\"106\":\"18#题目描述\",\"107\":\"18#前置知识\",\"108\":\"18#思路-哈希表记录\",\"109\":\"18#关键点\",\"110\":\"18#代码\",\"111\":\"18@1\",\"112\":\"19\",\"113\":\"19#题目地址-27-移除元素-力扣-leetcode\",\"114\":\"19#题目描述\",\"115\":\"19#前置知识\",\"116\":\"19#思路-1\",\"117\":\"19#关键点\",\"118\":\"19#代码\",\"119\":\"19@1\",\"120\":\"20\",\"121\":\"20#题目地址-349-两个数组的交集-力扣-leetcode\",\"122\":\"20#题目描述\",\"123\":\"20#前置知识\",\"124\":\"20#公司\",\"125\":\"20#思路\",\"126\":\"20#关键点\",\"127\":\"20#代码\",\"128\":\"20@1\",\"129\":\"21\",\"130\":\"21#题目地址-59-螺旋矩阵-ii-力扣-leetcode\",\"131\":\"21#题目描述\",\"132\":\"21#前置知识\",\"133\":\"21#思路\",\"134\":\"21#关键点\",\"135\":\"21#代码\",\"136\":\"22\",\"137\":\"22#题目地址-704-二分查找-力扣-leetcode\",\"138\":\"22#题目描述\",\"139\":\"22#前置知识\",\"140\":\"22#思路\",\"141\":\"22#关键点\",\"142\":\"22#代码\",\"143\":\"22#思路改进\",\"144\":\"22#左闭右必区间\",\"145\":\"22@1\",\"146\":\"23\",\"147\":\"23#题目地址-707-设计链表-力扣-leetcode\",\"148\":\"23#题目描述\",\"149\":\"23#前置知识\",\"150\":\"23#思路-单链表实现\",\"151\":\"23#关键点\",\"152\":\"23#代码\",\"153\":\"23#思路-双链表实现\",\"154\":\"23#关键点-1\",\"155\":\"23#代码-1\",\"156\":\"23@1\",\"157\":\"24\",\"158\":\"24#题目地址-977-有序数组的平方-力扣-leetcode\",\"159\":\"24#题目描述\",\"160\":\"24#前置知识\",\"161\":\"24#思路\",\"162\":\"24#关键点\",\"163\":\"24#代码\",\"164\":\"24@1\",\"165\":\"25\",\"166\":\"26\",\"167\":\"26#哈希表是什么\",\"168\":\"26#哈希函数\",\"169\":\"26#哈希冲突\",\"170\":\"26#拉链法\",\"171\":\"26#线性探测法\",\"172\":\"26@1\",\"173\":\"27\",\"174\":\"27#什么是数组\",\"175\":\"27#数组的特点\",\"176\":\"27#二分法\",\"177\":\"27#二分查找模板-1\",\"178\":\"27#二分查找模版-2-找满足条件的最左侧的值\",\"179\":\"27#二分查找模版-3-找满足条件的最右侧的值\",\"180\":\"27#双指针法\",\"181\":\"27#滑动窗口\",\"182\":\"27#模拟行为\",\"183\":\"28\",\"184\":\"28#虚拟头节点\",\"185\":\"28#快慢指针\",\"186\":\"28#删除倒数第-n-个节点\",\"187\":\"28#链表的基本操作\",\"188\":\"28#链表相交\",\"189\":\"28#环形链表\",\"190\":\"28@1\",\"191\":\"29\",\"192\":\"29#链表是什么\",\"193\":\"29#链表类型\",\"194\":\"29#单链表\",\"195\":\"29#双链表\",\"196\":\"29#循环链表\",\"197\":\"29#链表存储方式\",\"198\":\"29#链表操作\",\"199\":\"29#头插节点\",\"200\":\"29#尾插节点\",\"201\":\"29#拆链操作\",\"202\":\"29#删除节点\",\"203\":\"29#链表性能分析\",\"204\":\"29#问题\",\"205\":\"29@1\",\"206\":\"30\",\"207\":\"30#题目地址-面试题-02-07-链表相交-力扣-leetcode\",\"208\":\"30#题目描述\",\"209\":\"30#前置知识\",\"210\":\"30#思路\",\"211\":\"30#关键点\",\"212\":\"30#代码\",\"213\":\"30@1\",\"214\":\"31\",\"215\":\"32\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,3],\"1\":[1],\"2\":[1,6],\"3\":[1],\"4\":[1],\"5\":[1,88],\"6\":[1],\"7\":[null,null,1],\"8\":[1,18],\"9\":[null,null,1],\"10\":[null,null,1],\"11\":[1,20],\"12\":[null,null,1],\"13\":[null,null,1],\"14\":[2,10],\"15\":[2,8],\"16\":[2,12],\"17\":[2,11],\"18\":[2,10],\"19\":[1,10],\"20\":[1,1],\"21\":[1,3],\"22\":[1,1],\"23\":[2,10],\"24\":[1,5],\"25\":[1,2],\"26\":[1,3],\"27\":[1],\"28\":[null,null,1],\"29\":[null,null,1],\"30\":[1,3],\"31\":[1,19],\"32\":[1,20],\"33\":[1,12],\"34\":[1,13],\"35\":[null,null,1],\"36\":[null,null,2],\"37\":[2],\"38\":[6,7],\"39\":[1,45],\"40\":[1,1],\"41\":[1,21],\"42\":[1,7],\"43\":[1,37],\"44\":[null,null,1],\"45\":[3],\"46\":[7,10],\"47\":[1,57],\"48\":[1,2],\"49\":[1,49],\"50\":[1,3],\"51\":[1,52],\"52\":[null,null,1],\"53\":[2],\"54\":[8,13],\"55\":[1,27],\"56\":[1,2],\"57\":[3,17],\"58\":[1,5],\"59\":[1,51],\"60\":[null,null,1],\"61\":[2],\"62\":[6,7],\"63\":[1,41],\"64\":[1,1],\"65\":[1,25],\"66\":[1,4],\"67\":[1,75],\"68\":[null,null,1],\"69\":[2],\"70\":[6,10],\"71\":[1,32],\"72\":[2,6],\"73\":[1,4],\"74\":[1,39],\"75\":[2],\"76\":[1,6],\"77\":[1,40],\"78\":[null,null,1],\"79\":[2],\"80\":[6,8],\"81\":[1,24],\"82\":[1,3],\"83\":[2,8],\"84\":[1,8],\"85\":[1,40],\"86\":[2,6],\"87\":[1,3],\"88\":[1,25],\"89\":[null,null,1],\"90\":[2],\"91\":[6,9],\"92\":[1,39],\"93\":[1,3],\"94\":[2,15],\"95\":[1,5],\"96\":[1,50],\"97\":[2],\"98\":[6,10],\"99\":[1,23],\"100\":[1,1],\"101\":[2,19],\"102\":[1,2],\"103\":[1,46],\"104\":[2],\"105\":[6,8],\"106\":[1,37],\"107\":[1,1],\"108\":[2,16],\"109\":[1,2],\"110\":[1,44],\"111\":[null,null,1],\"112\":[2],\"113\":[6,7],\"114\":[1,76],\"115\":[1,1],\"116\":[2,25],\"117\":[1,1],\"118\":[1,27],\"119\":[null,null,1],\"120\":[2],\"121\":[6,9],\"122\":[1,30],\"123\":[1],\"124\":[1,1],\"125\":[1],\"126\":[1],\"127\":[1,48],\"128\":[null,null,2],\"129\":[3],\"130\":[7,8],\"131\":[1,26],\"132\":[1,2],\"133\":[1,32],\"134\":[1,2],\"135\":[1,67],\"136\":[2],\"137\":[6,7],\"138\":[1,38],\"139\":[1,1],\"140\":[1,45],\"141\":[1,2],\"142\":[1,34],\"143\":[1,35],\"144\":[1,23],\"145\":[null,null,2],\"146\":[2],\"147\":[6,9],\"148\":[1,75],\"149\":[1,2],\"150\":[2,7],\"151\":[1,4],\"152\":[1,73],\"153\":[2,14],\"154\":[1,17],\"155\":[1,55],\"156\":[null,null,1],\"157\":[2],\"158\":[6,11],\"159\":[1,42],\"160\":[1,1],\"161\":[1,7],\"162\":[1,6],\"163\":[1,50],\"164\":[null,null,2],\"165\":[1,1],\"166\":[1],\"167\":[1,17],\"168\":[1,16],\"169\":[1,6],\"170\":[1,2],\"171\":[1,4],\"172\":[null,null,1],\"173\":[1],\"174\":[2,6],\"175\":[1,10],\"176\":[1],\"177\":[2,61],\"178\":[3,72],\"179\":[3,42],\"180\":[1,7],\"181\":[1,12],\"182\":[1,6],\"183\":[1],\"184\":[1,5],\"185\":[1,2],\"186\":[3,12],\"187\":[1,10],\"188\":[1,4],\"189\":[1,9],\"190\":[null,null,1],\"191\":[1],\"192\":[2,7],\"193\":[1],\"194\":[1,2],\"195\":[1,4],\"196\":[1,4],\"197\":[1,20],\"198\":[1],\"199\":[1,38],\"200\":[1,22],\"201\":[1,21],\"202\":[1,24],\"203\":[1,7],\"204\":[1,12],\"205\":[null,null,1],\"206\":[3],\"207\":[8,12],\"208\":[1,76],\"209\":[1,3],\"210\":[1,38],\"211\":[1,7],\"212\":[1,57],\"213\":[null,null,1],\"214\":[1,3],\"215\":[1]},\"averageFieldLength\":[1.6612274889003331,18.31141092751083,0.5820873037165516],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"配置项的相关说明详见 项目主页配置。\"]},\"1\":{\"h\":\"档案主页\"},\"2\":{\"h\":\"介绍\",\"t\":[\"This is Me!\",\"相关配置文档请见 档案主页。\"]},\"3\":{\"h\":\"关于我\"},\"4\":{\"h\":\"关于我\"},\"5\":{\"h\":\"关于本站\",\"t\":[\"2024-06-17\",\"完善 deploy,yml，部署到SSH 域名解析 doublew2w.cn\",\"2024-06-16\",\"完善 deploy.yml 文件，部署到 github-page\",\"注意\",\"记得建立 gh-pages 分支\",\"name: 部署文档 on: push: branches: - master permissions: contents: write jobs: deploy-gh-pages: runs-on: ubuntu-latest environment: master steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 1 # 如果你文档需要 Git 子模块，取消注释下一行 # submodules: true - name: 设置 pnpm uses: pnpm/action-setup@v4 - name: 设置 Node.js uses: actions/setup-node@v4 with: node-version: 20 cache: \\\"pnpm\\\" - name: 安装依赖 run: | corepack enable pnpm install --frozen-lockfile - name: 构建文档 env: NODE_OPTIONS: --max_old_space_size=8192 run: |- pnpm run docs:build > src/.vuepress/dist/.nojekyll - name: 部署文档 uses: JamesIves/github-pages-deploy-action@v4 with: # 部署文档 branch: gh-pages folder: src/.vuepress/dist\",\"2024-06-15\",\"初始化项目并上传到github\"]},\"6\":{\"h\":\"主要功能与配置演示\"},\"7\":{\"c\":[\"使用指南\"]},\"8\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"9\":{\"c\":[\"使用指南\"]},\"10\":{\"c\":[\"禁用\"]},\"11\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"12\":{\"c\":[\"指南\"]},\"13\":{\"c\":[\"布局\"]},\"14\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"15\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"16\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"17\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"18\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"19\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"20\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"21\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"22\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"23\":{\"h\":\"TeX 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"24\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"25\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"26\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"27\":{\"h\":\"组件\"},\"28\":{\"c\":[\"使用指南\"]},\"29\":{\"c\":[\"Markdown\"]},\"30\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"31\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"32\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"33\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"34\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"35\":{\"c\":[\"使用指南\"]},\"36\":{\"c\":[\"页面配置\",\"使用指南\"]},\"37\":{\"h\":\"1-两数之和\"},\"38\":{\"h\":\"题目地址(1. 两数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/two-sum/\"]},\"39\":{\"h\":\"题目描述\",\"t\":[\" 给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\",\" 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\",\" 你可以按任意顺序返回答案。\",\" 示例 1：\",\" 输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释： 因为 nums [0] + nums [1] == 9 ，返回 [0, 1] 。 \",\" 示例 2：\",\" 输入： nums = [3,2,4], target = 6 输出： [1,2] \",\" 示例 3：\",\" 输入： nums = [3,3], target = 6 输出： [0,1] \",\" 提示：\",\" 2 <= nums.length <= 10 4 \",\"-10 9 <= nums [i] <= 10 9 \",\"-10 9 <= target <= 10 9 \",\" 只会存在一个有效答案 \",\" 进阶： 你可以想出一个时间复杂度小于 O(n 2 ) 的算法吗？\"]},\"40\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"41\":{\"h\":\"思路\",\"t\":[\"创建一个哈希表，对于每个 x，通过查询 target - x 是否存在于哈希表中\",\"不存在，则将 x 插入哈希表\",\"存在，x 的下标与 target-x 的下标就是答案\",\"如果有 3 个或者以上的重复元素，代表这个重复元素不可能是解\",\"如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于 target。\"]},\"42\":{\"h\":\"关键点\",\"t\":[\"每种输入只会对应一个答案\",\"哈希表存储的 key 是 x 和 target - x\"]},\"43\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; ++i) { int first = target - nums[i]; if (map.containsKey(first)) { int firstIndex = map.get(target - nums[i]); return new int[]{firstIndex, i}; } map.put(nums[i], i); } return new int[0]; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，哈希表存储元素的开销\"]},\"44\":{\"c\":[\"哈希表\"]},\"45\":{\"h\":\"142-环形链表 ii\"},\"46\":{\"h\":\"题目地址(142. 环形链表 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/linked-list-cycle-ii/description/\"]},\"47\":{\"h\":\"题目描述\",\"t\":[\" 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 。\",\" 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（ 索引从 0 开始 ）。如果 pos 是 -1 ，则在该链表中没有环。 注意： pos 不作为参数进行传递 ，仅仅是为了标识链表的实际情况。\",\" 不允许修改 链表。\",\" 示例 1：\",\" 输入： head = [3,2,0,-4], pos = 1 输出： 返回索引为 1 的链表节点 解释： 链表中有一个环，其尾部连接到第二个节点。 \",\" 示例 2：\",\" 输入： head = [1,2], pos = 0 输出： 返回索引为 0 的链表节点 解释： 链表中有一个环，其尾部连接到第一个节点。 \",\" 示例 3：\",\" 输入： head = [1], pos = -1 输出： 返回 null 解释： 链表中没有环。 \",\" 提示：\",\" 链表中节点的数目范围在范围 [0, 10 4 ] 内 \",\"-10 5 <= Node.val <= 10 5 \",\" pos 的值为 -1 或者链表中的一个有效索引 \",\" 进阶： 你是否可以使用 O(1) 空间解决此题？\"]},\"48\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"环形证明\"]},\"49\":{\"h\":\"思路\",\"t\":[\"使用双指针，分别定义为 fast 和 slow。从头节点出发，fast 每次走两步，slow 每次走 1 步。\",\"如果存在环，由于 fast 的步速大于 slow，最终 fast 和 slow 一定会在环中相遇\",\"如果不存在环，fast 会先于 slow 走到 null\",\"从头节点到环形入口节点的节点数为 x，环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 y。从相遇节点 再到环形入口节点节点数为 z。\",\"相遇时，slow 走过的节点数为 x+y，fast 走过的节点数为 x+y+n(y+z)，其中 n 为走过的环的圈数。\",\"fast 每次走两步，slow 每次走一步。\",\"x+y+n(y+z) = 2*(x+y) => x = (n-1)(y+z)+z\",\"从「相遇点到入环点的距离」加上「 n−1 圈的环长度」，恰好等于「从链表头部到入环点的距离」。\"]},\"50\":{\"h\":\"关键点\",\"t\":[\"判断链表是否环\",\"如果有环，如何找到这个环的入口\"]},\"51\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { if(head == null || head.next == null){ return null; } // 采用双指针的方式 ListNode fast = head,slow = head; // 第一次相遇, fast 走了 2n 个环， slow 走了 n 个环 while(true){ if(fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if(fast == slow) break; } // 让 fast 和 slow 一起同时 1，在次相遇就是环入口 fast = head; while(fast != slow){ fast = fast.next; slow = slow.next; } return slow; } }\",\"复杂度分析\",\"时间复杂度：O(n)：第一次相遇时，slow 要走 x+y 步，第二次相遇，slow 要走 z 步，总体是线性复杂度\",\"空间复杂度：O(1)：双指针使用常数大小的额外空间\"]},\"52\":{\"c\":[\"链表\"]},\"53\":{\"h\":\"19-删除链表的倒数第N个结点\"},\"54\":{\"h\":\"题目地址(19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\"]},\"55\":{\"h\":\"题目描述\",\"t\":[\" 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\",\" 示例 1：\",\" 输入： head = [1,2,3,4,5], n = 2 输出： [1,2,3,5] \",\" 示例 2：\",\" 输入： head = [1], n = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [1,2], n = 1 输出： [1] \",\" 提示：\",\" 链表中结点的数目为 sz \",\" 1 <= sz <= 30 \",\" 0 <= Node.val <= 100 \",\" 1 <= n <= sz \",\" 进阶： 你能尝试使用一趟扫描实现吗？\"]},\"56\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针\"]},\"57\":{\"h\":\"思路 1：双指针\",\"t\":[\"dummyHead 存储虚拟头节点，first 存储头节点，second 存储虚拟头节点，进行遍历。\",\"让 first 先走 N 步。\",\"second 和 first 一起走。\",\"当 first 走到空节点时时，second 刚好走好倒数第 N+1 个\"]},\"58\":{\"h\":\"关键点\",\"t\":[\"由于要进行删除操作，因此要找到「倒数第 n+1」个节点位置\"]},\"59\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (head.next == null && n == 1) { return null; } // 怎么知道是倒数第 2 个，使用双指针，让一个指针先走 2 步 ListNode dummyHead = new ListNode(-1, head); ListNode first = head; ListNode second = dummyHead; // 让 first 先走 n，让 first 到达尾节点，second 刚好指向倒数第 n 个 for (int i = 0; i < n; i++) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummyHead.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"60\":{\"c\":[\"链表\"]},\"61\":{\"h\":\"202-快乐数\"},\"62\":{\"h\":\"题目地址(202. 快乐数 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/happy-number/\"]},\"63\":{\"h\":\"题目描述\",\"t\":[\"编写一个算法来判断一个数 n 是不是快乐数。\",\"「快乐数」 定义为：\",\"对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\",\"然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\",\"如果这个过程 结果为 1，那么这个数就是快乐数。\",\"如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\",\"示例 1：\",\"输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 \",\"示例 2：\",\"输入：n = 2 输出：false \",\"提示：\",\"1 <= n <= 231 - 1\"]},\"64\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"65\":{\"h\":\"思路\",\"t\":[\"通过反复调用 getNext(n) 得到的链是一个隐式的链表。链中的所有其他数字都是节点。那问题就直接转换为「检测一个链表是否有环。」\",\"定义两个指针slow和fast，slow在链表中前进 1 个节点，fast在链表前进 2 个节点（对 getNext(n) 函数的嵌套调用）。\",\"如果 n 是快乐数，则就说明没有循环，fast 会先到 “1”\",\"如果 n 不是快乐数，fast 和 slow 一定会在循环中。\"]},\"66\":{\"h\":\"关键点\",\"t\":[\"将”快乐数“操作视为寻找下一个数，即看成一个链表\"]},\"67\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { // 对于一个三位数来说，最大的平方和为 9^2+9^2+9^2 = 243 // 对于一个四位数来说，最大的平方和为 81 + 81 + 81 + 81 = 324 // 在继续往下后，4位数只会降到3位数，而不会无穷大 public int getNext(int n) { int totalSum = 0; // 计算每一位的平方和 while (n > 0) { int d = n % 10; n = n / 10; totalSum += d * d; } return totalSum; } public boolean isHappy(int n) { int slowRunner = n; int fastRunner = getNext(n); if(fastRunner == 1){ return true; } // 快慢指针，不是快乐数，那么存在一个环使得算法无限循环 // 在环中它们由于步速不一致，会相遇 // 如果相遇，则说明不是快乐数 // 如果是快乐数，最后会返回1 while (slowRunner != fastRunner) { // slow 走一步, fast 走两步 slowRunner = getNext(slowRunner); fastRunner = getNext(fastRunner); fastRunner = getNext(fastRunner); } return fastRunner == 1; } }\",\"复杂度分析\",\"时间复杂度：O(n)\",\"如果没有循环，那么fast将先到达 1，slow将到达链表中的一半。成本是 O(2⋅logn)=O(logn)\",\"一旦两个指针都在循环中，假设循环中有 k 个数字。如果他们的起点是相隔 k−1 的位置（这是他们可以开始的最远的距离），那么快跑者需要 k−1 步才能到达慢跑者，主操作不变，所以也是 O(logn)。\",\"空间复杂度：O(n)\"]},\"68\":{\"c\":[\"哈希表\"]},\"69\":{\"h\":\"203-移除链表元素\"},\"70\":{\"h\":\"题目地址(203. 移除链表元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-linked-list-elements/description/\"]},\"71\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\",\" 示例 1：\",\" 输入： head = [1,2,6,3,4,5,6], val = 6 输出： [1,2,3,4,5] \",\" 示例 2：\",\" 输入： head = [], val = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [7,7,7,7], val = 7 输出： [] \",\" 提示：\",\" 列表中的节点数目在范围 [0, 10 4 ] 内 \",\" 1 <= Node.val <= 50 \",\" 0 <= val <= 50 ## 前置知识 \",\"链表\",\"删除节点\",\"虚拟节点\"]},\"72\":{\"h\":\"思路1:直接删除\",\"t\":[\"先判断头结点的情况 head!=null&&head.val!=val\",\"从当前节点的后驱节点进行遍历\"]},\"73\":{\"h\":\"关键点\",\"t\":[\"头结点要特殊处理\",\"cur.next=cur.next.next\"]},\"74\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 删除值相同的头结点后，可能新的头结点也值相等，用循环解决 while (head != null && head.val == val) { head = head.next; } if (head == null) return head; ListNode prev = head; // 确保当前结点后还有结点 while (prev.next != null) { if (prev.next.val == val) { prev.next = prev.next.next; } else { prev = prev.next; } } return head; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"75\":{\"h\":\"思路2：虚拟头节点\"},\"76\":{\"h\":\"关键点\",\"t\":[\"在虚拟头节点下，要删除一个节点，删除方式一样。最后返回的时候是 dummyNode.next\"]},\"77\":{\"h\":\"代码\",\"t\":[\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { //创建一个虚拟头结点 ListNode dummyNode=new ListNode(val-1); dummyNode.next=head; ListNode prev=dummyNode; //确保当前结点后还有结点 while(prev.next!=null){ if(prev.next.val==val){ prev.next=prev.next.next; }else{ prev=prev.next; } } return dummyNode.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"78\":{\"c\":[\"链表\"]},\"79\":{\"h\":\"206-反转链表\"},\"80\":{\"h\":\"题目地址(206. 反转链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-linked-list/\"]},\"81\":{\"h\":\"题目描述\",\"t\":[\"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\",\"示例 1：\",\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \",\"示例 2：\",\"输入：head = [1,2] 输出：[2,1] \",\"示例 3：\",\"输入：head = [] 输出：[] \",\"提示：\",\"链表中节点的数目范围是 [0, 5000]\",\"-5000 <= Node.val <= 5000\",\"进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\"]},\"82\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针/递归思想\"]},\"83\":{\"h\":\"思路1:双指针\",\"t\":[\"图片来自：代码随想录\",\"pre 指向虚拟节点，cur 指向头节点\",\"在每一次移动过程中，修改节点指向\"]},\"84\":{\"h\":\"关键点\",\"t\":[\"先存储 next 引用 next=cur.next\",\"cur.next=pre\",\"pre=cur\",\"cur=next\"]},\"85\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; // 前驱节点 null ListNode curr = head; // 当前节点 1 (1->2) while (curr != null) { ListNode next = curr.next; // 后驱节点 2 curr.next = prev; // 反向 1<-2 prev = curr; // prev = 1 curr = next; // curr = 2 } return prev; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"86\":{\"h\":\"思路2：递归\",\"t\":[\"递归函数的定义\",\"输出一个节点 head\",\"将 head 为起点的链表进行反转\",\"返回反转之后的头节点\"]},\"87\":{\"h\":\"关键点\",\"t\":[\"理解递归\",\"当第一次递归时，已经把链表分成后两部分\"]},\"88\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，空间复杂度主要取决于递归调用的栈空间，最多为 n 层。\"]},\"89\":{\"c\":[\"链表\"]},\"90\":{\"h\":\"209-长度最小的子数组\"},\"91\":{\"h\":\"题目地址(209. 长度最小的子数组 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/minimum-size-subarray-sum/\"]},\"92\":{\"h\":\"题目描述\",\"t\":[\"给定一个含有 n个正整数的数组和一个正整数 target 。\",\"找出该数组中满足其总和大于等于target的长度最小的 \",\"子数组\",\"[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\",\"示例 1：\",\"输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 \",\"示例 2：\",\"输入：target = 4, nums = [1,4,4] 输出：1 \",\"示例 3：\",\"输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 \",\"提示：\",\"1 <= target <= 109\",\"1 <= nums.length <= 105\",\"1 <= nums[i] <= 105\",\"进阶：\",\"如果你已经实现O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\"]},\"93\":{\"h\":\"前置知识\",\"t\":[\"滑动窗口\",\"[前缀和+二分查找]\"]},\"94\":{\"h\":\"思路1：滑动窗口\",\"t\":[\"定义两个指针 start 和 end 分别指向滑动窗口的开始位置和结束位置\",\"计算滑动窗口的总和 sum\",\"当 sum 符合题目时，窗口的长度为子数组的最小长度 end−start+1\",\"将 start 继续往右移，找到更小的窗口长度\",\"继续更新子数组的最小长度\"]},\"95\":{\"h\":\"关键点\",\"t\":[\"当窗口符合条件时，要将 start 继续往右移，找到更小的窗口长度\"]},\"96\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int minSubArrayLen(int target, int[] nums) { // 第一次符合条件为窗口长度 right - left // int n = nums.length; if(n == 0) return 0; int ans = Integer.MAX_VALUE; int start = 0, end = 0; // 滑动串口的指针和右指针 int sum = 0; while (end < n) { sum += nums[end]; // 把当前元素添加进去,直到符合最小窗口的长度 while (sum >= target) { // 最小窗口长度右移，直到不满足 此时，ans = end - start + 1， end - start ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"97\":{\"h\":\"24-两两交换链表中的节点\"},\"98\":{\"h\":\"题目地址(24. 两两交换链表中的节点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/swap-nodes-in-pairs/description/\"]},\"99\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\",\"示例 1：\",\"输入：head = [1,2,3,4] 输出：[2,1,4,3] \",\"示例 2：\",\"输入：head = [] 输出：[] \",\"示例 3：\",\"输入：head = [1] 输出：[1] \",\"提示：\",\"链表中节点的数目在范围 [0, 100] 内\",\"0 <= Node.val <= 100\"]},\"100\":{\"h\":\"前置知识\",\"t\":[\"链表\"]},\"101\":{\"h\":\"思路1：虚拟头节点\",\"t\":[\"使用变量 cur 代表当前节点，初始化为 cur=dummy\",\"使用两个变量 first 和 second 待交换的节点，即 first=cur.next 和 second=cur.next.next\",\"当链表还剩下两个节点时，就可以进行更改链表节点的交换\",\"cur.next = secod\",\"first.next = second.next\",\"second.next = first\",\"cur = first\",\"进行下一轮的判断并且交换\"]},\"102\":{\"h\":\"关键点\",\"t\":[\"循环条件是当前链表还有2个以上的节点\",\"链表节点交换的指针变动\"]},\"103\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(0); // 设置一个虚拟头节点 dummy.next = head; // 将虚拟头结点指向head,这样方便后续做删除操作 ListNode cur = dummy; while (cur.next != null && cur.next.next != null) { ListNode first = cur.next; ListNode second = cur.next.next; cur.next = second; // 步骤一 first.next = second.next; // 步骤三 second.next = first; // 步骤二 cur = first; } return dummy.next; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"104\":{\"h\":\"242-有效的字母异位词\"},\"105\":{\"h\":\"题目地址(242. 有效的字母异位词 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/valid-anagram/description/\"]},\"106\":{\"h\":\"题目描述\",\"t\":[\" 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\",\" 注意： 若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\",\" 示例 1: \",\" 输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true \",\" 示例 2: \",\" 输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false \",\" 提示: \",\" 1 <= s.length, t.length <= 5 * 10 4 \",\" s 和 t 仅包含小写字母 \",\" 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\"]},\"107\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"108\":{\"h\":\"思路：哈希表记录\",\"t\":[\"若 s、t 长度不相等，则「非字母异位词」\",\"若 s、t 某对应字母数量不同，则「非字母异位词」\",\"统计 s 各字符时执行 +1 ，统计 t 各字符时 −1 。若两字符串互为字母异位词，则最终哈希表中所有字符统计数值都应为 0 。\"]},\"109\":{\"h\":\"关键点\",\"t\":[\"使用哈希表进行记录不同字母出现的次数\",\"也可以使用长度固定的数组记录不同字母出现的次数\"]},\"110\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public boolean isAnagram(String s, String t) { // 先判断长度一致 if (s.length() != t.length()) { return false; } // 使用字母的特性：只有 26 个，以一个数组来记录 int[] table = new int[26]; for (int i = 0; i < s.length(); i++) { table[s.charAt(i) - 'a']++; table[t.charAt(i) - 'a']--; } for (int i = 0; i < 26; i++) { if (table[i] != 0) { return false; } } return true; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，数组长度为常数，因此空间复杂度为常数\"]},\"111\":{\"c\":[\"哈希表\"]},\"112\":{\"h\":\"27-移除元素\"},\"113\":{\"h\":\"题目地址(27. 移除元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-element/\"]},\"114\":{\"h\":\"题目描述\",\"t\":[\" 给你一个数组 nums 和一个值 val ，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\",\" 假设 nums 中不等于 val 的元素数量为 k ，要通过此题，您需要执行以下操作：\",\" 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。 nums 的其余元素和 nums 的大小并不重要。\",\" 返回 k 。\",\" 用户评测：\",\" 评测机将使用以下代码测试您的解决方案：\",\"int [] nums = [...]; // 输入数组 int val = ...; // 要移除的值 int [] expectedNums = [...]; // 长度正确的预期答案。 // 它以不等于 val 的值排序。 int k = removeElement(nums, val); // 调用你的实现 assert k == expectedNums.length; sort(nums, 0, k); // 排序 nums 的前 k 个元素 for (int i = 0; i < actualLength; i++) { assert nums [i] == expectedNums [i]; }\",\" 如果所有的断言都通过，你的解决方案将会 通过 。\",\" 示例 1：\",\" 输入： nums = [3,2,2,3], val = 3 输出： 2, nums = [2,2, _,_] 解释： 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\",\" 示例 2：\",\" 输入： nums = [0,1,2,2,3,0,4,2], val = 2 输出： 5, nums = [0,1,4,0,3, _,_,_] 解释： 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。 注意这五个元素可以任意顺序返回。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。 \",\" 提示：\",\" 0 <= nums.length <= 100 \",\" 0 <= nums [i] <= 50 \",\" 0 <= val <= 100 \"]},\"115\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"116\":{\"h\":\"思路 1\",\"t\":[\"题意：\",\"原地-》空间复杂度为 O(1)\",\"前 K 个元素不等于 val\",\"遍历数组 nums，每次取出的数字变量为 num，同时设置一个下标 ans\",\"在遍历过程中如果出现数字与需要移除的值 不相同 时，则进行拷贝覆盖 nums[ans]=num，ans 自增 1\",\"如果相同的时候，则跳过该数字不进行拷贝覆盖，最后 ans 即为新的数组长度\"]},\"117\":{\"h\":\"关键点\",\"t\":[\"拷贝覆盖\"]},\"118\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int removeElement(int[] nums, int val) { int ans = 0; for (int num : nums) { if (num != val) { nums[ans] = num; ans++; } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"119\":{\"c\":[\"数组\"]},\"120\":{\"h\":\"349-两个数组的交集\"},\"121\":{\"h\":\"题目地址(349. 两个数组的交集 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-arrays/\"]},\"122\":{\"h\":\"题目描述\",\"t\":[\"给定两个数组 nums1 和 nums2 ，返回 它们的 \",\"交集\",\" 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\",\"示例 1：\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] \",\"示例 2：\",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 1000\"]},\"123\":{\"h\":\"前置知识\"},\"124\":{\"h\":\"公司\",\"t\":[\"暂无\"]},\"125\":{\"h\":\"思路\"},\"126\":{\"h\":\"关键点\"},\"127\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] intersection(int[] nums1, int[] nums2) { int[] hash1 = new int[1002]; int[] hash2 = new int[1002]; // 计数 for(int i : nums1) hash1[i]++; for(int i : nums2) hash2[i]++; List<Integer> resList = new ArrayList<>(); // 寻找交集元素 for(int i = 0; i < 1002; i++) if(hash1[i] > 0 && hash2[i] > 0) resList.add(i); // 转换成数组 int index = 0; int res[] = new int[resList.size()]; for(int i : resList) res[index++] = i; return res; } }\",\"复杂度分析\",\"令 n 为nums1数组长度,m为nums2数组长度。\",\"时间复杂度：O(m+n),使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间\",\"空间复杂度：O(m+n)，两个存储数组都是固定长度。\"]},\"128\":{\"c\":[\"哈希表\",\"数组\"]},\"129\":{\"h\":\"59-螺旋矩阵 II\"},\"130\":{\"h\":\"题目地址(59. 螺旋矩阵 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/spiral-matrix-ii/\"]},\"131\":{\"h\":\"题目描述\",\"t\":[\" 给你一个正整数 n ，生成一个包含 1 到 n 2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\",\" 示例 1：\",\" 输入： n = 3 输出： [[1,2,3], [8,9,4], [7,6,5]] \",\" 示例 2：\",\" 输入： n = 1 输出： [[1]] \",\" 提示：\",\" 1 <= n <= 20 \"]},\"132\":{\"h\":\"前置知识\",\"t\":[\"数组\",\"模拟\"]},\"133\":{\"h\":\"思路\",\"t\":[\"定义好上下左右四个边界 top, bottom, left, right\",\"按照题目进行模拟，从左到右（上边界缩减），从上到下（右边界缩减），从右到左（下边界缩减），从下到上（下边界缩减）\",\"使用 num<=tar 而不是 l<r∣∣t<b 作为迭代条件，是为了解决当 n 为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。 \",\"当 n = 3 时，填充到8时，此时 top==bottom ，就会导致退出循环，中心数字无法在迭代过程中被填充。\"]},\"134\":{\"h\":\"关键点\",\"t\":[\"边界变化条件\",\"循环终止条件\"]},\"135\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[][] generateMatrix(int n) { int left = 0, right = n-1, top = 0, bottom = n-1; int count = 1, target = n * n; int[][] res = new int[n][n]; //for循环中变量定义成i或j的细节：按照通常的思维，i代表行，j代表列 //这样，就可以很容易区分出来变化的量应该放在[][]的第一个还是第二个 //对于变量的边界怎么定义： //从左向右填充：填充的列肯定在[left,right]区间 //从上向下填充：填充的行肯定在[top,bottom]区间 //从右向左填充：填充的列肯定在[right,left]区间 //从下向上填充：填充的行肯定在[bootom,top]区间 //通过上面的总结会发现边界的起始和结束与方向是对应的 while(count <= target){ //从左到右填充，相当于缩小上边界 for(int j = left; j <= right; j++) res[top][j] = count++; //缩小上边界 top++; //从上向下填充，相当于缩小右边界 for(int i = top; i <=bottom; i++) res[i][right] = count++; //缩小右边界 right--; //从右向左填充，相当于缩小下边界 for(int j = right; j >= left; j--) res[bottom][j] = count++; //缩小下边界 bottom--; //从下向上填充，相当于缩小左边界 for(int i = bottom; i >= top; i--) res[i][left] = count++; //缩小左边界 left++; } return res; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)\",\"空间复杂度：O(1)\"]},\"136\":{\"h\":\"704-二分查找\"},\"137\":{\"h\":\"题目地址(704. 二分查找 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/binary-search/\"]},\"138\":{\"h\":\"题目描述\",\"t\":[\" 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target ，如果目标值存在返回下标，否则返回 -1 。\",\" 示例 1: \",\" 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 \",\" 示例 2: \",\" 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 \",\" 提示：\",\" 你可以假设 nums 中的所有元素是不重复的。\",\" n 将在 [1, 10000] 之间。\",\" nums 的每个元素都将在 [-9999, 9999] 之间。\"]},\"139\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"140\":{\"h\":\"思路\",\"t\":[\"区间定义\",\"当我们选择「左闭右开」的时候，我们可以 0 来定义左边界(left)，而以数组的长度来定义右边界(right)，因此右边界我们是判断不到的。\",\"循环终止条件\",\"在左闭右开的情况，区间不为空，也就意味着 right 至少大于等于 left 。如果超过了这个条件，循环就终止。\",\"判断条件\",\"nums[mid]==target ，mid 就是我们要得到的结果，直接返回\",\"nums[mid]<target，我们应往右边的区间继续寻找，注意 mid 的位置我们是可以取到的，因此我们更新左边界的时候，应该为 left=mid+1\",\"nums[mid]>target，我们应往左边的区间找，而 mid 的位置明显不是答案，但是我们选择的是左闭右开区间，而右开所指向的位置本身就不在我们的候选区间里，所以 right=mid，而不是 right=mid−1.\",\"如果 mid−1 的位置正好是答案，在左闭右开的情况是找不到这个位置的\"]},\"141\":{\"h\":\"关键点\",\"t\":[\"左右区间的闭合\",\"左右区间的比较\"]},\"142\":{\"h\":\"代码\",\"t\":[\"Java Code:\",\" class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left) / 2; if(nums[mid] > target){ right = mid; }else if(nums[mid] < target) { left = mid +1 ; }else{ return mid; } } return -1; }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(logn)\",\"空间复杂度：O(1)\"]},\"143\":{\"h\":\"思路改进\",\"t\":[\"在 nums[mid]<target 和 nums[mid]==target 是可以合并起来的。当区间长度为 1 时，剩下的就是答案，由于 nums [mid] 可能等于答案，因此我们不能跳过这个 mid 的位置\",\"public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left)/2; if(nums[mid] > target){ right = mid; }else{ left = mid; } } if(nums[l] == target){ return l; } return -1; }\"]},\"144\":{\"h\":\"左闭右必区间\",\"t\":[\"public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left <= right){ // #1 int mid = (right + left) / 2; if(nums[mid] == target){ return mid; }else if(nums[mid] < target){ left = mid + 1; // #2 }else{ right = mid - 1; // #3 } } return -1; }\"]},\"145\":{\"c\":[\"数组\",\"二分查找\"]},\"146\":{\"h\":\"707-设计链表\"},\"147\":{\"h\":\"题目地址(707. 设计链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/design-linked-list/description/\"]},\"148\":{\"h\":\"题目描述\",\"t\":[\" 你可以选择使用单链表或者双链表，设计并实现自己的链表。\",\" 单链表中的节点应该具备两个属性： val 和 next 。 val 是当前节点的值， next 是指向下一个节点的指针/引用。\",\" 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\",\" 实现 MyLinkedList 类：\",\" MyLinkedList() 初始化 MyLinkedList 对象。\",\" int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\",\" void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\",\" void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\",\" void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\",\" void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\",\" 示例：\",\" 输入 [\\\"MyLinkedList\\\", \\\"addAtHead\\\", \\\"addAtTail\\\", \\\"addAtIndex\\\", \\\"get\\\", \\\"deleteAtIndex\\\", \\\"get\\\"] [[], [1], [3], [1, 2], [1], [1], [1]] 输出 [null, null, null, null, 2, null, 3] 解释 MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // 链表变为 1-> 2-> 3 myLinkedList.get(1); // 返回 2 myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-> 3 myLinkedList.get(1); // 返回 3 \",\" 提示：\",\" 0 <= index, val <= 1000 \",\" 请不要使用内置的 LinkedList 库。\",\" 调用 get 、 addAtHead 、 addAtTail 、 addAtIndex 和 deleteAtIndex 的次数不超过 2000 。\"]},\"149\":{\"h\":\"前置知识\",\"t\":[\"链表结果\",\"链表基本操作\"]},\"150\":{\"h\":\"思路: 单链表实现\",\"t\":[\"内部定义一个 Node 对象当成链表中的节点\",\"由于需要根据索引来查找节点，因此提供查询节点的方法 getNode()\"]},\"151\":{\"h\":\"关键点\",\"t\":[\"插入/删除节点，需要同时更新 size\"]},\"152\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyLinkedList { // 单向链表 class Node { int val; Node next; public Node(int val) { this.val = val; } } Node _head = new Node(-1); int size = 0; public MyLinkedList() { _head.next = null; } public int get(int index) { Node ret = getNode(index); return ret == null ? -1 : ret.val; } public void addAtHead(int val) { Node newNode = new Node(val); newNode.next = _head.next; _head.next = newNode; size++; } public void addAtTail(int val) { Node newNode = new Node(val); newNode.next = null; if (size == 0) { _head.next = newNode; } else { // 头节点 Node head = _head.next; // 遍历找到最后一个节点 while (head.next != null) { head = head.next; } // 最后一个节点的后驱节点是新节点 head.next = newNode; } size++; } public void addAtIndex(int index, int val) { if (index > size) { return; } if (index == size) { addAtTail(val); return; } Node newNode = new Node(val); Node indexNode = getNode(index - 1); newNode.next = indexNode.next; indexNode.next = newNode; size++; } public void deleteAtIndex(int index) { if (index >= size) { return; } if (index == 0) { _head.next = _head.next.next; } else { Node indexPreNode = getNode(index - 1); indexPreNode.next = indexPreNode.next.next; } size--; } Node getNode(int index) { if (index >= size) { return null; } Node head = _head; for (int i = 0; i <= index; i++) { head = head.next; } return head; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index, val); * obj.deleteAtIndex(index); */\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(n)\",\"空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"153\":{\"h\":\"思路：双链表实现\",\"t\":[\"实现双向链表，即每个节点要存储本身的值，「后继节点」和「前驱节点」。除此之外，需要一个「哨兵节点」作为头节点 head 和一个「哨兵节点」作为尾节点 tail。\"]},\"154\":{\"h\":\"关键点\",\"t\":[\"在遍历过程过程，从前往后遍历（当索引小于链表长度的一半时）还是从后往前遍历来优化查找效率。\",\"遍历时，每移动一次就减小 index 的值，当 index 为 0 时，说明找到了目标节点并返回。如果遍历结束没有找到，则返回 null。\"]},\"155\":{\"h\":\"代码\",\"t\":[\"class MyLinkedList { class Node { Node prev, next; int val; Node (int _val) { val = _val; } } Node head = new Node(-1), tail = new Node(-1); int size = 0; public MyLinkedList() { head.next = tail; tail.prev = head; } public int get(int index) { Node node = getNode(index); return node == null ? -1 : node.val; } public void addAtHead(int val) { Node node = new Node(val); node.next = head.next; node.prev = head; head.next.prev = node; head.next = node; size++; } public void addAtTail(int val) { Node node = new Node(val); node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; size++; } public void addAtIndex(int index, int val) { if (index > sz) return ; if (index <= 0) { addAtHead(val); } else if (index == sz) { addAtTail(val); } else { Node node = new Node(val), cur = getNode(index); node.next = cur; node.prev = cur.prev; cur.prev.next = node; cur.prev = node; size++; } } public void deleteAtIndex(int index) { Node cur = getNode(index); if (cur == null) return ; cur.next.prev = cur.prev; cur.prev.next = cur.next; size--; } Node getNode(int index) { boolean isLeft = index < size / 2; if (!isLeft) index = size - index - 1; Node cur = isLeft ? head.next : tail.prev; for (; cur != tail && cur != head; cur = isLeft ? cur.next : cur.prev) { if (index-- == 0) return cur; } return null; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。\",\"空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"156\":{\"c\":[\"链表\"]},\"157\":{\"h\":\"977-有序数组的平方\"},\"158\":{\"h\":\"题目地址(977. 有序数组的平方 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/squares-of-a-sorted-array/description/\"]},\"159\":{\"h\":\"题目描述\",\"t\":[\" 给你一个按 非递减顺序 排序的整数数组 nums ，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\",\" 示例 1：\",\" 输入： nums = [-4,-1,0,3,10] 输出： [0,1,9,16,100] 解释： 平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] \",\" 示例 2：\",\" 输入： nums = [-7,-3,2,3,11] 输出： [4,9,9,49,121] \",\" 提示：\",\" 1 <= nums.length <= 10 4 \",\"-10 4 <= nums [i] <= 10 4 \",\" nums 已按 非递减顺序 排序 \",\" 进阶：\",\" 请你 设计时间复杂度为 O(n) 的算法解决本问题 \"]},\"160\":{\"h\":\"前置知识\",\"t\":[\"双指针\"]},\"161\":{\"h\":\"思路\",\"t\":[\"使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。\"]},\"162\":{\"h\":\"关键点\",\"t\":[\"平方大小的比较 = 绝对值大小的比较\",\"双指针指向相等时，任意放一个进入结果数组即可。\"]},\"163\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] sortedSquares(int[] nums) { // 非递减 // 在正数，越大，平方也就越大 // 在负数，越小，平方越大 // 采用双指针，头尾比较 int left = 0; int right = nums.length - 1; int[] ret = new int[nums.length]; int index = right; while (left < right) { // 当left == right时，退出循环 if (Math.abs(nums[left]) < Math.abs(nums[right])) { ret[index--] = nums[right] * nums[right]; right--; } else if (Math.abs(nums[left]) > Math.abs(nums[right])) { ret[index--] = nums[left]*nums[left]; left++; }else if(Math.abs(nums[left]) == Math.abs(nums[right])){ ret[index--] = nums[right]*nums[right]; right--; } } ret[index] = nums[left]*nums[left]; return ret; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，除了存储答案的数组以外，我们只需要维护常量空间。\"]},\"164\":{\"c\":[\"数组\",\"二分查找\"]},\"165\":{\"h\":\"LeetCode\",\"t\":[\"记录自己的刷题过程\"]},\"166\":{\"h\":\"哈希表基础理论\"},\"167\":{\"h\":\"哈希表是什么\",\"t\":[\"通过建立键 key 与值 value 之间的映射，实现高效的元素查询。就像每一个人的身份证对应一个人一样。\",\"数组\",\"链表\",\"哈希表\",\"查找元素\",\"O(1)\",\"O(n)\",\"O(1)\",\"添加元素\",\"O(n)\",\"O(1)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(1)\",\"O(1)\"]},\"168\":{\"h\":\"哈希函数\",\"t\":[\"通过某种算法将 value 映射到 key上。\",\"比如\",\"当我们使用数组实现哈希表时，会将所有的key能映射到数组上对应的索引，数组元素则是对应的value\",\"index = hash(key) % cap\",\"图片来自：hello-algo\"]},\"169\":{\"h\":\"哈希冲突\",\"t\":[\"理论上一定存在“多个输入对应相同输出”的情况，将这种情况视为“哈希冲突”。\"]},\"170\":{\"h\":\"拉链法\",\"t\":[\"冲突的位置存储在链表中。\"]},\"171\":{\"h\":\"线性探测法\",\"t\":[\"在冲突的地方继续往前查询，直到查询到不冲突，就放入对应的索引中。\"]},\"172\":{\"c\":[\"哈希表\"]},\"173\":{\"h\":\"数组总结篇\"},\"174\":{\"h\":\"什么是数组？\",\"t\":[\"数组是存放在「连续内存空间」上的「相同类型数据」的集合。\"]},\"175\":{\"h\":\"数组的特点\",\"t\":[\"索引从 0 开始\",\"内存地址是连续\",\"访问元素：O(1)\",\"插入和删除元素: O(n)\"]},\"176\":{\"h\":\"二分法\"},\"177\":{\"h\":\"二分查找模板 1\",\"t\":[\"public int binarySearch(int[] nums, int target){ int left = 0; int right = nums.length - 1; // 注意 1 while(left <= right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target){ return mid; } else if(nums[mid] < target) { left = mid + 1; // 注意 }else if(nums[mid] > target){ right = mid - 1; // 注意 } } // End Condition: left > right return -1; }\",\"初始化条件：left = 0, right = nums.length - 1 ，相当于闭区间 [left,right]，而这个区间就是我们的「搜索区间」\",\"循环停止条件：\",\"nums[mid] == target\",\"如果没有找到的情况下，「搜索区间」不存在。即 left > right => [right+1,right] ，区间不存在\",\" 如果非要用 while(left < right)，我该怎么办？\",\" //... while(left < right) { // ... } return nums [left] == target ? left : -1; \",\" 分析如下：\",\" 当退出循环时，存在 left == right ，不管是因为什么原因导致的， 左元素还是右元素最终有一个没做判断 \",\" left = mid + 1 ，所以才有 left == right 退出循环 \",\" right = mid - 1 ，所以才有 left == right 退出循环 \",\"向左查找，向右查找：在上面的「搜索区间」情况下，当 nums[mid] 查找不到时，此时 mid 已经被判断了。因此下次「搜索区间」应该是 [left,mid−1] 或者 [mid+1,right]\"]},\"178\":{\"h\":\"二分查找模版 2：找满足条件的最左侧的值\",\"t\":[\"int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left < right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; // 注意 } } return left; }\",\"初始化条件：left = 0, right = nums.length ，每次循环的「搜索区间」是 [left, right) 左闭右开\",\"循环停止条件：left == right，[left,left) 区间为空，搜索停止。\",\"向左查找：nums[mid] > target，nums[mid] == target 都会改变 right 的值。其实相当于告诉我们 nums[mid]的值都在target的右侧。只有这样做，我们才能不断地 缩小「搜索区间」的上界right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\",\"如果 target 在数组中，最后返回的结果 left 表示，数组中小于 target 的元素有 left 个，也可以表示 target 最左的下标为 left\",\"如果 target 不在数组中，假设一种极端情况\",\"[2,5,7,8] target = 1\",\"在循环过程中，left 一直保持不变，而 right 一直向左边靠近，最终 left == right 最后循环，最后返回 left = 0。\",\"含义是：数组中小于 1 的元素有 0 个。\",\"综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间[0,nums.length]\",\"while (left < right) { //... } // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1; //if(left != nums.length && nums [left] == target){ //return left; //} //return -1;\"]},\"179\":{\"h\":\"二分查找模版 3：找满足条件的最右侧的值\",\"t\":[\"public int search(int[] nums,int target){ int left = 0; int right = nums.length; while(left < right){ int mid = left + (right - left) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; } } if(left != 0 && nums[left-1] == target){ return left - 1; } return -1; }\",\"当 nums[mid] == target 时，不要立即返回，而是 增大「搜索区间」的下界**left**，使得区间不断向右收缩，达到锁定右侧边界的目的。\",\"由于我们更新 left 是 left = mid + 1，那就出现一种情况，left = mid + 1 = right 越界退出循环。\",\"nums[left] 一定不等于 target，否则也不会导致 left = mid+ 1 的操作发生\",\"nums[left-1] 有可能是 target，所以要进行 后处理检查\"]},\"180\":{\"h\":\"双指针法\",\"t\":[\"双指针法（快慢指针法）：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\"]},\"181\":{\"h\":\"滑动窗口\",\"t\":[\"根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O(n2) 的暴力解法降为 O(n)。\",\"最小/最大子数组问题\",\"字符串模式匹配问题\",\"固定长度的子数组/子字符串问题\",\"固定长度的子数组/子字符串问题\"]},\"182\":{\"h\":\"模拟行为\",\"t\":[\"模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟。\",\"循环不变量原则，其实这也是写程序中的重要原则。\"]},\"183\":{\"h\":\"链表总结篇\"},\"184\":{\"h\":\"虚拟头节点\",\"t\":[\"203-移除链表元素\",\"通过添加虚拟头节点的方式，可以很方便进行删除操作。\"]},\"185\":{\"h\":\"快慢指针\",\"t\":[\"206-翻转链表\"]},\"186\":{\"h\":\"删除倒数第 N 个节点\",\"t\":[\"19-删除倒数第 N 个节点 结合虚拟头结点 和 双指针法来移除链表倒数第 N 个节点\",\"交换链表中的节点\",\"删除链表 M 个节点之后的 N 个节点\",\"删除链表的中间节点\"]},\"187\":{\"h\":\"链表的基本操作\",\"t\":[\"707-设计链表\",\"获取链表第 index 个节点的数值\",\"在链表的最前面插入一个节点\",\"在链表的最后面插入一个节点\",\"在链表第 index 个节点前面插入一个节点\",\"删除链表的第 index 个节点的数值\"]},\"188\":{\"h\":\"链表相交\",\"t\":[\"面试题 02.07-链表相交\"]},\"189\":{\"h\":\"环形链表\",\"t\":[\"这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。\",\"142-环形链表-ii\"]},\"190\":{\"c\":[\"链表\"]},\"191\":{\"h\":\"链表理论基础\"},\"192\":{\"h\":\"链表是什么？\",\"t\":[\"链表是一种通过指针串联在一起的线性结构\",\"每一个节点由两部分组成，一部分是「数据域」，一部分是「指针域」，最后一个节点的指针域指向 null\"]},\"193\":{\"h\":\"链表类型\"},\"194\":{\"h\":\"单链表\",\"t\":[\"​ \"]},\"195\":{\"h\":\"双链表\",\"t\":[\"每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\"]},\"196\":{\"h\":\"循环链表\",\"t\":[\"循环链表，顾名思义，就是链表首尾相连。\"]},\"197\":{\"h\":\"链表存储方式\",\"t\":[\"链表在内存中可不是连续分布的。\",\"链表是通过「指针域的指针」链接在内存中各个节点，每个节点存放着下一个节点的内存地址。\",\"链表的组成单位是 Node 对象\",\"/* 链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向下一节点的引用 ListNode(int x) { val = x; } // 构造函数 }\"]},\"198\":{\"h\":\"链表操作\"},\"199\":{\"h\":\"头插节点\",\"t\":[\"记录头节点\",\"创建新节点，新节点的头节点为null\",\"新节点的 next 为 「步骤1」的头节点\",\"「步骤1」的前驱节点为 新节点\",\"void linkFirst(E e) { final Node<E> f = first; // 头节点 final Node<E> newNode = new Node<>(null, e, f); // 新节点，后驱节点是f first = newNode; // 现在头节点是新节点 if (f == null) // 如果之前的头节点为null last = newNode; // 那么现在头节点和尾节点都是 新节点 else f.prev = newNode; // 之间的头节点的前驱节点是新节点 size++; }\",\"图片来自：bugstack.cn\"]},\"200\":{\"h\":\"尾插节点\",\"t\":[\"void linkLast(E e) { final Node<E> l = last; final Node<E> newNode = new Node<>(l, e, null); last = newNode; if (l == null) { first = newNode; } else { l.next = newNode; } size++; }\",\"图片来自：bugstack.cn\"]},\"201\":{\"h\":\"拆链操作\",\"t\":[\"E unlink(Node<E> x) { final E element = x.item; final Node<E> next = x.next; final Node<E> prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; return element; }\",\"图片来自：bugstack.cn\"]},\"202\":{\"h\":\"删除节点\",\"t\":[\"public boolean remove(Object o) { if (o == null) { for (Node<E> x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node<E> x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; }\",\"图片来自：bugstack.cn\"]},\"203\":{\"h\":\"链表性能分析\",\"t\":[\"插入/删除为 O(1)\",\"查询为O(n)\"]},\"204\":{\"h\":\"问题\",\"t\":[\"描述一下链表的数据结构？\",\"Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？\",\"链表中数据的插入、删除、获取元素，时间复杂度是多少？\",\"什么场景下使用链表更合适？\"]},\"205\":{\"c\":[\"链表\"]},\"206\":{\"h\":\"面试题02.07-链表相交\"},\"207\":{\"h\":\"题目地址(面试题 02.07. 链表相交 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\"]},\"208\":{\"h\":\"题目描述\",\"t\":[\" 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\",\" 图示两个链表在节点 c1 开始相交 ：\",\" 题目数据 保证 整个链式结构中不存在环。\",\" 注意 ，函数返回结果后，链表必须 保持其原始结构 。\",\" 示例 1：\",\" 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出： Intersected at '8' 解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 \",\" 示例 2：\",\" 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出： Intersected at '2' 解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 \",\" 示例 3：\",\" 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出： null 解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 \",\" 提示：\",\" listA 中节点数目为 m \",\" listB 中节点数目为 n \",\" 0 <= m, n <= 3 * 10 4 \",\" 1 <= Node.val <= 10 5 \",\" 0 <= skipA <= m \",\" 0 <= skipB <= n \",\" 如果 listA 和 listB 没有交点， intersectVal 为 0 \",\" 如果 listA 和 listB 有交点， intersectVal == listA [skipA + 1] == listB [skipB + 1] \",\" 进阶： 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\"]},\"209\":{\"h\":\"前置知识\",\"t\":[\"双指针\",\"链表\",\"哈希表\"]},\"210\":{\"h\":\"思路\",\"t\":[\"相交部分长度为 c，listA 长度为 a，listb 长度为 b。\",\"有两个变量 headA、headB 分别从 listA、listB 分别出发。\",\"当 headA 走完 listA 时，从 headB 继续走。\",\"当 headB 走完 listB 时，从 headA 继续走。\",\"headA == headB 时就是相交节点\",\"headA 共走了 a+（b-c）\",\"headB 共走了 b+（a-c）\",\"若两链表 有 公共尾部 (即 c > 0 ) ：指针 A, B 同时指向第一个相交节点。\",\"若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。\"]},\"211\":{\"h\":\"关键点\",\"t\":[\"双指针遍历各自所在链表后，在遍历对方的链表，第一次「相等」就是相交点\",\"「相等」有可能两个指针都指向 null\"]},\"212\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } // A 链长度为 a // B 链长度为 b // A 和 B 重叠的链长度为 c // A 相交的位置在 a+b-c // B 相交的位置在 b+a-c ListNode first = headA; ListNode second = headB; while(first != second){ // 循环终止条件 first = first == null? headB:first.next; second = second == null? headA:second.next; } return first; } }\",\"复杂度分析\",\"令 a 为 listA 长度，b 为 listB 长度\",\"时间复杂度：O(a+b)，最差情况下（即 ∣a−b∣=1 , c=0 ），此时需遍历 a+b 个节点。\",\"空间复杂度：O(1)\"]},\"213\":{\"c\":[\"链表\"]},\"214\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"215\":{\"h\":\"About\"}},\"dirtCount\":0,\"index\":[[\"∣a−b∣=1\",{\"1\":{\"212\":1}}],[\"重叠的链长度为\",{\"1\":{\"212\":1}}],[\"无\",{\"1\":{\"210\":1}}],[\"无限循环\",{\"1\":{\"63\":1}}],[\"公共尾部\",{\"1\":{\"210\":2}}],[\"公司\",{\"0\":{\"124\":1}}],[\"共走了\",{\"1\":{\"210\":2}}],[\"没有交点\",{\"1\":{\"208\":1}}],[\"必须为\",{\"1\":{\"208\":1}}],[\"保持其原始结构\",{\"1\":{\"208\":1}}],[\"保证\",{\"1\":{\"208\":1}}],[\"函数返回结果后\",{\"1\":{\"208\":1}}],[\"函数的返回值\",{\"1\":{\"178\":1}}],[\"函数的嵌套调用\",{\"1\":{\"65\":1}}],[\"图示两个链表在节点\",{\"1\":{\"208\":1}}],[\"图片来自\",{\"1\":{\"83\":1,\"168\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"图片引入\",{\"1\":{\"33\":1}}],[\"图片增强\",{\"0\":{\"25\":1}}],[\"什么场景下使用链表更合适\",{\"1\":{\"204\":1}}],[\"什么是数组\",{\"0\":{\"174\":1}}],[\"获取元素\",{\"1\":{\"204\":1}}],[\"获取链表第\",{\"1\":{\"187\":1}}],[\"获取链表中下标为\",{\"1\":{\"148\":1}}],[\"描述一下链表的数据结构\",{\"1\":{\"204\":1}}],[\"问题\",{\"0\":{\"204\":1}}],[\"拆链操作\",{\"0\":{\"201\":1}}],[\"尾插节点\",{\"0\":{\"200\":1}}],[\"创建新节点\",{\"1\":{\"199\":1}}],[\"创建一个虚拟头结点\",{\"1\":{\"77\":1}}],[\"创建一个哈希表\",{\"1\":{\"41\":1}}],[\"构造函数\",{\"1\":{\"197\":1}}],[\"构建文档\",{\"1\":{\"5\":1}}],[\"节点值\",{\"1\":{\"197\":1}}],[\"顾名思义\",{\"1\":{\"196\":1}}],[\"​\",{\"1\":{\"194\":1}}],[\"数据域\",{\"1\":{\"192\":1}}],[\"数组中小于\",{\"1\":{\"178\":2}}],[\"数组中同一个元素在答案里不能重复出现\",{\"1\":{\"39\":1}}],[\"数组的特点\",{\"0\":{\"175\":1}}],[\"数组是存放在\",{\"1\":{\"174\":1}}],[\"数组总结篇\",{\"0\":{\"173\":1}}],[\"数组元素则是对应的value\",{\"1\":{\"168\":1}}],[\"数组变为\",{\"1\":{\"159\":2}}],[\"数组\",{\"1\":{\"114\":1,\"115\":1,\"132\":1,\"139\":1,\"167\":1},\"2\":{\"119\":1,\"128\":1,\"145\":1,\"164\":1}}],[\"数组长度为常数\",{\"1\":{\"110\":1}}],[\"寻找公共尾部入口等\",{\"1\":{\"189\":1}}],[\"寻找环入口\",{\"1\":{\"189\":1}}],[\"寻找交集元素\",{\"1\":{\"127\":1}}],[\"例如寻找距离尾部第\",{\"1\":{\"189\":1}}],[\"面试题02\",{\"0\":{\"206\":1}}],[\"面试题\",{\"0\":{\"207\":1},\"1\":{\"188\":1}}],[\"交换链表中的节点\",{\"1\":{\"186\":1}}],[\"交集\",{\"1\":{\"122\":1}}],[\"结合虚拟头结点\",{\"1\":{\"186\":1}}],[\"结果为\",{\"1\":{\"63\":1}}],[\"翻转链表\",{\"1\":{\"185\":1}}],[\"固定长度的子数组\",{\"1\":{\"181\":2}}],[\"字符串模式匹配问题\",{\"1\":{\"181\":1}}],[\"字符怎么办\",{\"1\":{\"106\":1}}],[\"根据当前子序列和大小的情况\",{\"1\":{\"181\":1}}],[\"否则也不会导致\",{\"1\":{\"179\":1}}],[\"否则返回\",{\"1\":{\"138\":1}}],[\"达到锁定右侧边界的目的\",{\"1\":{\"179\":1}}],[\"达到锁定左侧边界的目的\",{\"1\":{\"178\":1}}],[\"增大\",{\"1\":{\"179\":1}}],[\"取值区间是闭区间\",{\"1\":{\"178\":1}}],[\"取消注释下一行\",{\"1\":{\"5\":1}}],[\"变量的值\",{\"1\":{\"178\":1}}],[\"综上可以看出\",{\"1\":{\"178\":1}}],[\"含义是\",{\"1\":{\"178\":1}}],[\"表示\",{\"1\":{\"178\":1}}],[\"都会改变\",{\"1\":{\"178\":1}}],[\"搜索停止\",{\"1\":{\"178\":1}}],[\"搜索区间\",{\"1\":{\"177\":4,\"178\":2,\"179\":1}}],[\"或者\",{\"1\":{\"177\":1}}],[\"或者链表中的一个有效索引\",{\"1\":{\"47\":1}}],[\"应该是\",{\"1\":{\"177\":1}}],[\"应该为\",{\"1\":{\"140\":1}}],[\"情况下\",{\"1\":{\"177\":1}}],[\"向右查找\",{\"1\":{\"177\":1}}],[\"向左查找\",{\"1\":{\"177\":1,\"178\":1}}],[\"我该怎么办\",{\"1\":{\"177\":1}}],[\"我们才能不断地\",{\"1\":{\"178\":1}}],[\"我们只需要维护常量空间\",{\"1\":{\"163\":1}}],[\"我们应往左边的区间找\",{\"1\":{\"140\":1}}],[\"我们应往右边的区间继续寻找\",{\"1\":{\"140\":1}}],[\"我们可以\",{\"1\":{\"122\":1,\"140\":1}}],[\"二分法\",{\"0\":{\"176\":1}}],[\"二分查找模版\",{\"0\":{\"178\":1,\"179\":1}}],[\"二分查找模板\",{\"0\":{\"177\":1}}],[\"二分查找\",{\"0\":{\"136\":1,\"137\":1},\"2\":{\"145\":1,\"164\":1}}],[\"访问元素\",{\"1\":{\"175\":1}}],[\"连续内存空间\",{\"1\":{\"174\":1}}],[\"线性探测法\",{\"0\":{\"171\":1}}],[\"冲突的位置存储在链表中\",{\"1\":{\"170\":1}}],[\"拉链法\",{\"0\":{\"170\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"169\":1}}],[\"理论上一定存在\",{\"1\":{\"169\":1}}],[\"理解递归\",{\"1\":{\"87\":1}}],[\"比所有数都大\",{\"1\":{\"178\":1}}],[\"比如\",{\"1\":{\"168\":1}}],[\"比长度更大\",{\"1\":{\"148\":1}}],[\"映射到\",{\"1\":{\"168\":1}}],[\"哈希冲突\",{\"0\":{\"169\":1},\"1\":{\"169\":1}}],[\"哈希函数\",{\"0\":{\"168\":1}}],[\"哈希表是什么\",{\"0\":{\"167\":1}}],[\"哈希表基础理论\",{\"0\":{\"166\":1}}],[\"哈希表记录\",{\"0\":{\"108\":1}}],[\"哈希表存储元素的开销\",{\"1\":{\"43\":1}}],[\"哈希表存储的\",{\"1\":{\"42\":1}}],[\"哈希表\",{\"1\":{\"40\":1,\"64\":1,\"107\":1,\"167\":1,\"209\":1},\"2\":{\"44\":1,\"68\":1,\"111\":1,\"128\":1,\"172\":1}}],[\"添加元素\",{\"1\":{\"167\":1}}],[\"查询为o\",{\"1\":{\"203\":1}}],[\"查找不到时\",{\"1\":{\"177\":1}}],[\"查找元素\",{\"1\":{\"167\":1}}],[\"查看详情\",{\"1\":{\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1}}],[\"与值\",{\"1\":{\"167\":1}}],[\"记录头节点\",{\"1\":{\"199\":1}}],[\"记录自己的刷题过程\",{\"1\":{\"165\":1}}],[\"记得建立\",{\"1\":{\"5\":1}}],[\"除了存储答案的数组以外\",{\"1\":{\"163\":1}}],[\"除此之外\",{\"1\":{\"153\":1}}],[\"退出循环\",{\"1\":{\"163\":1,\"177\":2}}],[\"采用双指针\",{\"1\":{\"163\":1}}],[\"采用双指针的方式\",{\"1\":{\"51\":1}}],[\"越界退出循环\",{\"1\":{\"179\":1}}],[\"越小\",{\"1\":{\"163\":1}}],[\"越大\",{\"1\":{\"163\":1}}],[\"任意放一个进入结果数组即可\",{\"1\":{\"162\":1}}],[\"任务列表\",{\"0\":{\"24\":1}}],[\"绝对值大小的比较\",{\"1\":{\"162\":1}}],[\"平方越大\",{\"1\":{\"163\":1}}],[\"平方也就越大\",{\"1\":{\"163\":1}}],[\"平方大小的比较\",{\"1\":{\"162\":1}}],[\"平方后\",{\"1\":{\"159\":1}}],[\"选择较大的那个逆序放入答案并移动指针\",{\"1\":{\"161\":1}}],[\"选项卡\",{\"0\":{\"20\":1}}],[\"已经被判断了\",{\"1\":{\"177\":1}}],[\"已经把链表分成后两部分\",{\"1\":{\"87\":1}}],[\"已按\",{\"1\":{\"159\":1}}],[\"组成的新数组\",{\"1\":{\"159\":1}}],[\"组件\",{\"0\":{\"27\":1,\"34\":1},\"1\":{\"34\":1}}],[\"非递减\",{\"1\":{\"163\":1}}],[\"非递减顺序\",{\"1\":{\"159\":3}}],[\"非字母异位词\",{\"1\":{\"108\":2}}],[\"有可能两个指针都指向\",{\"1\":{\"211\":1}}],[\"有可能是\",{\"1\":{\"179\":1}}],[\"有\",{\"1\":{\"210\":1}}],[\"有两个变量\",{\"1\":{\"210\":1}}],[\"有交点\",{\"1\":{\"208\":1}}],[\"有序数组的平方\",{\"0\":{\"157\":1,\"158\":1}}],[\"有效的字母异位词\",{\"0\":{\"104\":1,\"105\":1}}],[\"说明找到了目标节点并返回\",{\"1\":{\"154\":1}}],[\"还是从后往前遍历来优化查找效率\",{\"1\":{\"154\":1}}],[\"还不会编写\",{\"1\":{\"15\":1}}],[\"哨兵节点\",{\"1\":{\"153\":2}}],[\"需要一个\",{\"1\":{\"153\":1}}],[\"需要同时更新\",{\"1\":{\"151\":1}}],[\"后处理检查\",{\"1\":{\"179\":1}}],[\"后继节点\",{\"1\":{\"153\":1}}],[\"后驱节点是f\",{\"1\":{\"199\":1}}],[\"后驱节点\",{\"1\":{\"85\":1}}],[\"双向链表还是循环链表\",{\"1\":{\"204\":1}}],[\"双链表\",{\"0\":{\"195\":1}}],[\"双链表实现\",{\"0\":{\"153\":1}}],[\"双指针遍历各自所在链表后\",{\"1\":{\"211\":1}}],[\"双指针法来移除链表倒数第\",{\"1\":{\"186\":1}}],[\"双指针法\",{\"0\":{\"180\":1},\"1\":{\"180\":1}}],[\"双指针指向相等时\",{\"1\":{\"162\":1}}],[\"双指针\",{\"0\":{\"57\":1,\"83\":1},\"1\":{\"56\":1,\"82\":1,\"160\":1,\"209\":1}}],[\"双指针使用常数大小的额外空间\",{\"1\":{\"51\":1}}],[\"总体空间复杂度为\",{\"1\":{\"152\":1,\"155\":1}}],[\"总体是线性复杂度\",{\"1\":{\"51\":1}}],[\"消耗\",{\"1\":{\"152\":3,\"155\":4}}],[\"遍历时\",{\"1\":{\"154\":1}}],[\"遍历找到最后一个节点\",{\"1\":{\"152\":1}}],[\"遍历数组\",{\"1\":{\"116\":1}}],[\"头插节点\",{\"0\":{\"199\":1}}],[\"头尾比较\",{\"1\":{\"163\":1}}],[\"头节点\",{\"1\":{\"152\":1,\"199\":1}}],[\"头结点要特殊处理\",{\"1\":{\"73\":1}}],[\"单向链表\",{\"1\":{\"152\":1}}],[\"单链表\",{\"0\":{\"194\":1}}],[\"单链表实现\",{\"0\":{\"150\":1}}],[\"单链表中的节点应该具备两个属性\",{\"1\":{\"148\":1}}],[\"调用次数之和\",{\"1\":{\"152\":1,\"155\":1}}],[\"调用\",{\"1\":{\"148\":1}}],[\"调用你的实现\",{\"1\":{\"114\":1}}],[\"库\",{\"1\":{\"148\":1}}],[\"现在头节点是新节点\",{\"1\":{\"199\":1}}],[\"现在\",{\"1\":{\"148\":1}}],[\"该节点将\",{\"1\":{\"148\":1}}],[\"等于链表的长度\",{\"1\":{\"148\":1}}],[\"新节点\",{\"1\":{\"199\":3}}],[\"新节点的\",{\"1\":{\"199\":1}}],[\"新节点的头节点为null\",{\"1\":{\"199\":1}}],[\"新节点会成为链表的第一个节点\",{\"1\":{\"148\":1}}],[\"新的头节点\",{\"1\":{\"71\":1}}],[\"类似之前算法的处理方式\",{\"1\":{\"178\":1}}],[\"类\",{\"1\":{\"148\":1}}],[\"实现高效的元素查询\",{\"1\":{\"167\":1}}],[\"实现双向链表\",{\"1\":{\"153\":1}}],[\"实现\",{\"1\":{\"148\":1}}],[\"设计时间复杂度为\",{\"1\":{\"159\":1}}],[\"设计并实现自己的链表\",{\"1\":{\"148\":1}}],[\"设计链表\",{\"0\":{\"146\":1,\"147\":1},\"1\":{\"187\":1}}],[\"设置一个虚拟头节点\",{\"1\":{\"103\":1}}],[\"设置\",{\"1\":{\"5\":2}}],[\"剩下的就是答案\",{\"1\":{\"143\":1}}],[\"左元素还是右元素最终有一个没做判断\",{\"1\":{\"177\":1}}],[\"左闭右必区间\",{\"0\":{\"144\":1}}],[\"左闭右开\",{\"1\":{\"140\":1,\"178\":1}}],[\"左右区间的比较\",{\"1\":{\"141\":1}}],[\"左右区间的闭合\",{\"1\":{\"141\":1}}],[\"判断条件\",{\"1\":{\"140\":1}}],[\"判断链表是否环\",{\"1\":{\"50\":1}}],[\"至少大于等于\",{\"1\":{\"140\":1}}],[\"而是\",{\"1\":{\"179\":1}}],[\"而这个区间就是我们的\",{\"1\":{\"177\":1}}],[\"而右开所指向的位置本身就不在我们的候选区间里\",{\"1\":{\"140\":1}}],[\"而\",{\"1\":{\"140\":1,\"178\":1,\"208\":1}}],[\"而以数组的长度来定义右边界\",{\"1\":{\"140\":1}}],[\"而不是\",{\"1\":{\"133\":1,\"140\":1}}],[\"而不会无穷大\",{\"1\":{\"67\":1}}],[\"之间的头节点的前驱节点是新节点\",{\"1\":{\"199\":1}}],[\"之间的映射\",{\"1\":{\"167\":1}}],[\"之间\",{\"1\":{\"138\":2}}],[\"出现在\",{\"1\":{\"138\":1}}],[\"写一个函数搜索\",{\"1\":{\"138\":1}}],[\"写作日期为\",{\"1\":{\"32\":1}}],[\"整个链式结构中不存在环\",{\"1\":{\"208\":1}}],[\"整型数组\",{\"1\":{\"138\":1}}],[\"整数\",{\"1\":{\"39\":1}}],[\"升序\",{\"1\":{\"138\":1}}],[\"缩小\",{\"1\":{\"178\":1}}],[\"缩小左边界\",{\"1\":{\"135\":1}}],[\"缩小下边界\",{\"1\":{\"135\":1}}],[\"缩小右边界\",{\"1\":{\"135\":1}}],[\"缩小上边界\",{\"1\":{\"135\":1}}],[\"区间为空\",{\"1\":{\"178\":1}}],[\"区间不存在\",{\"1\":{\"177\":1}}],[\"区间不为空\",{\"1\":{\"140\":1}}],[\"区间定义\",{\"1\":{\"140\":1}}],[\"区间\",{\"1\":{\"135\":4}}],[\"填充的行肯定在\",{\"1\":{\"135\":2}}],[\"填充的列肯定在\",{\"1\":{\"135\":2}}],[\"填充到8时\",{\"1\":{\"133\":1}}],[\"按照通常的思维\",{\"1\":{\"135\":1}}],[\"按照题目进行模拟\",{\"1\":{\"133\":1}}],[\"循环链表\",{\"0\":{\"196\":1},\"1\":{\"196\":1}}],[\"循环不变量原则\",{\"1\":{\"182\":1}}],[\"循环的工作\",{\"1\":{\"180\":1}}],[\"循环下完成两个\",{\"1\":{\"180\":1}}],[\"循环停止条件\",{\"1\":{\"177\":1,\"178\":1}}],[\"循环就终止\",{\"1\":{\"140\":1}}],[\"循环终止条件\",{\"1\":{\"134\":1,\"140\":1,\"212\":1}}],[\"循环条件是当前链表还有2个以上的节点\",{\"1\":{\"102\":1}}],[\"边界变化条件\",{\"1\":{\"134\":1}}],[\"矩阵中心数字无法在迭代过程中被填充的问题\",{\"1\":{\"133\":1}}],[\"作为尾节点\",{\"1\":{\"153\":1}}],[\"作为头节点\",{\"1\":{\"153\":1}}],[\"作为迭代条件\",{\"1\":{\"133\":1}}],[\"作者设置为\",{\"1\":{\"32\":1}}],[\"下边界缩减\",{\"1\":{\"133\":2}}],[\"下一篇\",{\"1\":{\"8\":1}}],[\"右边界缩减\",{\"1\":{\"133\":1}}],[\"模拟类的题目在数组中很常见\",{\"1\":{\"182\":1}}],[\"模拟行为\",{\"0\":{\"182\":1}}],[\"模拟\",{\"1\":{\"132\":1}}],[\"正方形矩阵\",{\"1\":{\"131\":1}}],[\"且元素按顺时针顺序螺旋排列的\",{\"1\":{\"131\":1}}],[\"所有函数单次调用的空间复杂度均为\",{\"1\":{\"155\":1}}],[\"所有函数的单次调用空间复杂度均为\",{\"1\":{\"152\":1}}],[\"所有元素\",{\"1\":{\"131\":1}}],[\"所以要进行\",{\"1\":{\"179\":1}}],[\"所以才有\",{\"1\":{\"177\":2}}],[\"所以\",{\"1\":{\"140\":1,\"208\":1}}],[\"所以也是\",{\"1\":{\"67\":1}}],[\"到链表中\",{\"1\":{\"148\":1}}],[\"到\",{\"1\":{\"131\":1}}],[\"到达尾节点\",{\"1\":{\"59\":1}}],[\"生成一个包含\",{\"1\":{\"131\":1}}],[\"螺旋矩阵\",{\"0\":{\"129\":1,\"130\":1}}],[\"转换成数组\",{\"1\":{\"127\":1}}],[\"暂无\",{\"1\":{\"124\":1}}],[\"也就意味着\",{\"1\":{\"140\":1}}],[\"也是可通过的\",{\"1\":{\"122\":1}}],[\"也可以表示\",{\"1\":{\"178\":1}}],[\"也可以使用长度固定的数组记录不同字母出现的次数\",{\"1\":{\"109\":1}}],[\"也可能是\",{\"1\":{\"63\":1}}],[\"唯一\",{\"1\":{\"122\":1}}],[\"它们的\",{\"1\":{\"122\":1}}],[\"它以不等于\",{\"1\":{\"114\":1}}],[\"拷贝覆盖\",{\"1\":{\"117\":1}}],[\"自增\",{\"1\":{\"116\":1}}],[\"时就是相交节点\",{\"1\":{\"210\":1}}],[\"时\",{\"1\":{\"116\":1,\"133\":1,\"143\":1,\"154\":1,\"179\":1,\"210\":2}}],[\"时间复杂度是多少\",{\"1\":{\"204\":1}}],[\"时间复杂度的解法\",{\"1\":{\"92\":2}}],[\"时间复杂度\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"155\":1,\"163\":1,\"212\":1}}],[\"题意\",{\"1\":{\"116\":1}}],[\"题目数据\",{\"1\":{\"208\":1}}],[\"题目描述\",{\"0\":{\"39\":1,\"47\":1,\"55\":1,\"63\":1,\"71\":1,\"81\":1,\"92\":1,\"99\":1,\"106\":1,\"114\":1,\"122\":1,\"131\":1,\"138\":1,\"148\":1,\"159\":1,\"208\":1}}],[\"题目地址\",{\"0\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"排序后\",{\"1\":{\"159\":1}}],[\"排序的整数数组\",{\"1\":{\"159\":1}}],[\"排序\",{\"1\":{\"114\":1,\"159\":2}}],[\"用户评测\",{\"1\":{\"114\":1}}],[\"用循环解决\",{\"1\":{\"74\":1}}],[\"使得区间不断向右收缩\",{\"1\":{\"179\":1}}],[\"使\",{\"1\":{\"114\":1}}],[\"使用的是单向链表\",{\"1\":{\"204\":1}}],[\"使用\",{\"1\":{\"133\":1}}],[\"使用两个指针分别指向位置\",{\"1\":{\"161\":1}}],[\"使用两个集合分别存储两个数组中的元素需要\",{\"1\":{\"127\":1}}],[\"使用两个变量\",{\"1\":{\"101\":1}}],[\"使用字母的特性\",{\"1\":{\"110\":1}}],[\"使用哈希表进行记录不同字母出现的次数\",{\"1\":{\"109\":1}}],[\"使用变量\",{\"1\":{\"101\":1}}],[\"使用双指针\",{\"1\":{\"49\":1,\"59\":1}}],[\"使用指南\",{\"1\":{\"32\":2},\"2\":{\"7\":1,\"9\":1,\"28\":1,\"35\":1,\"36\":1}}],[\"更改\",{\"1\":{\"114\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"11\":1}}],[\"更新时间\",{\"1\":{\"8\":1}}],[\"您需要执行以下操作\",{\"1\":{\"114\":1}}],[\"然后返回\",{\"1\":{\"114\":1}}],[\"然后重复这个过程直到这个数变为\",{\"1\":{\"63\":1}}],[\"元素的顺序可能发生改变\",{\"1\":{\"114\":1}}],[\"原地\",{\"1\":{\"114\":1,\"116\":1}}],[\"移除所有数值等于\",{\"1\":{\"114\":1}}],[\"移除元素\",{\"0\":{\"112\":1,\"113\":1}}],[\"移除链表元素\",{\"0\":{\"69\":1,\"70\":1},\"1\":{\"184\":1}}],[\"以指示链表中的上一个节点\",{\"1\":{\"148\":1}}],[\"以一个数组来记录\",{\"1\":{\"110\":1}}],[\"以便\",{\"1\":{\"14\":1}}],[\"各字符时\",{\"1\":{\"108\":1}}],[\"各字符时执行\",{\"1\":{\"108\":1}}],[\"统计\",{\"1\":{\"108\":2}}],[\"某对应字母数量不同\",{\"1\":{\"108\":1}}],[\"长度\",{\"1\":{\"212\":2}}],[\"长度为\",{\"1\":{\"210\":2}}],[\"长度正确的预期答案\",{\"1\":{\"114\":1}}],[\"长度不相等\",{\"1\":{\"108\":1}}],[\"长度最小的子数组\",{\"0\":{\"90\":1,\"91\":1}}],[\"仅用\",{\"1\":{\"208\":1}}],[\"仅包含小写字母\",{\"1\":{\"106\":1}}],[\"仅仅是为了标识链表的实际情况\",{\"1\":{\"47\":1}}],[\"互为字母异位词\",{\"1\":{\"106\":1}}],[\"若两链表\",{\"1\":{\"210\":2}}],[\"若两字符串互为字母异位词\",{\"1\":{\"108\":1}}],[\"若\",{\"1\":{\"106\":1,\"108\":2}}],[\"就是相交点\",{\"1\":{\"211\":1}}],[\"就是链表首尾相连\",{\"1\":{\"196\":1}}],[\"就是单纯的模拟\",{\"1\":{\"182\":1}}],[\"就是我们要得到的结果\",{\"1\":{\"140\":1}}],[\"就放入对应的索引中\",{\"1\":{\"171\":1}}],[\"就像每一个人的身份证对应一个人一样\",{\"1\":{\"167\":1}}],[\"就可以很容易区分出来变化的量应该放在\",{\"1\":{\"135\":1}}],[\"就可以进行更改链表节点的交换\",{\"1\":{\"101\":1}}],[\"就会导致退出循环\",{\"1\":{\"133\":1}}],[\"就返回\",{\"1\":{\"63\":1}}],[\"待交换的节点\",{\"1\":{\"101\":1}}],[\"初始化条件\",{\"1\":{\"177\":1,\"178\":1}}],[\"初始化消耗\",{\"1\":{\"152\":1,\"155\":1}}],[\"初始化\",{\"1\":{\"148\":1}}],[\"初始化为\",{\"1\":{\"101\":1}}],[\"初始化项目并上传到github\",{\"1\":{\"5\":1}}],[\"只有这样做\",{\"1\":{\"178\":1}}],[\"只有\",{\"1\":{\"110\":1}}],[\"只能进行节点交换\",{\"1\":{\"99\":1}}],[\"只会存在一个有效答案\",{\"1\":{\"39\":1}}],[\"即不断向左收缩\",{\"1\":{\"178\":1}}],[\"即每个节点要存储本身的值\",{\"1\":{\"153\":1}}],[\"即为新的数组长度\",{\"1\":{\"116\":1}}],[\"即\",{\"1\":{\"99\":1,\"101\":1,\"177\":1,\"178\":1,\"210\":2,\"212\":1}}],[\"即看成一个链表\",{\"1\":{\"66\":1}}],[\"此时需遍历\",{\"1\":{\"212\":1}}],[\"此时\",{\"1\":{\"96\":1,\"133\":1,\"177\":1}}],[\"此文字有脚注\",{\"1\":{\"21\":1}}],[\"直接返回\",{\"1\":{\"140\":1}}],[\"直接删除\",{\"0\":{\"72\":1}}],[\"直到查询到不冲突\",{\"1\":{\"171\":1}}],[\"直到不满足\",{\"1\":{\"96\":1}}],[\"直到符合最小窗口的长度\",{\"1\":{\"96\":1}}],[\"把当前元素添加进去\",{\"1\":{\"96\":1}}],[\"滑动串口的指针和右指针\",{\"1\":{\"96\":1}}],[\"滑动窗口\",{\"0\":{\"94\":1,\"181\":1},\"1\":{\"93\":1}}],[\"继续走\",{\"1\":{\"210\":2}}],[\"继续更新子数组的最小长度\",{\"1\":{\"94\":1}}],[\"继续往右移\",{\"1\":{\"94\":1,\"95\":1}}],[\"找满足条件的最右侧的值\",{\"0\":{\"179\":1}}],[\"找满足条件的最左侧的值\",{\"0\":{\"178\":1}}],[\"找到更小的窗口长度\",{\"1\":{\"94\":1,\"95\":1}}],[\"找出该数组中满足其总和大于等于target的长度最小的\",{\"1\":{\"92\":1}}],[\"窗口的长度为子数组的最小长度\",{\"1\":{\"94\":1}}],[\"符合题目时\",{\"1\":{\"94\":1}}],[\"子字符串问题\",{\"1\":{\"181\":2}}],[\"子数组\",{\"1\":{\"92\":2}}],[\"子模块\",{\"1\":{\"5\":1}}],[\"层\",{\"1\":{\"88\":1}}],[\"递归函数的定义\",{\"1\":{\"86\":1}}],[\"递归\",{\"0\":{\"86\":1}}],[\"递归思想\",{\"1\":{\"82\":1}}],[\"反向\",{\"1\":{\"85\":1}}],[\"反转链表\",{\"0\":{\"79\":1,\"80\":1}}],[\"前\",{\"1\":{\"116\":1}}],[\"前缀和+二分查找\",{\"1\":{\"93\":1}}],[\"前驱节点\",{\"1\":{\"85\":1,\"153\":1}}],[\"前置知识\",{\"0\":{\"40\":1,\"48\":1,\"56\":1,\"64\":1,\"82\":1,\"93\":1,\"100\":1,\"107\":1,\"115\":1,\"123\":1,\"132\":1,\"139\":1,\"149\":1,\"160\":1,\"209\":1},\"1\":{\"71\":1}}],[\"引用\",{\"1\":{\"84\":1,\"148\":1}}],[\"修改节点指向\",{\"1\":{\"83\":1}}],[\"要求也按\",{\"1\":{\"159\":1}}],[\"要移除的值\",{\"1\":{\"114\":1}}],[\"要通过此题\",{\"1\":{\"114\":1}}],[\"要将\",{\"1\":{\"95\":1}}],[\"要删除一个节点\",{\"1\":{\"76\":1}}],[\"要走\",{\"1\":{\"51\":2}}],[\"虚拟头节点\",{\"0\":{\"75\":1,\"101\":1,\"184\":1}}],[\"虚拟节点\",{\"1\":{\"71\":1}}],[\"确保当前结点后还有结点\",{\"1\":{\"74\":1,\"77\":1}}],[\"可能等于答案\",{\"1\":{\"143\":1}}],[\"可能新的头结点也值相等\",{\"1\":{\"74\":1}}],[\"可以是任意值\",{\"1\":{\"208\":1}}],[\"可以很方便进行删除操作\",{\"1\":{\"184\":1}}],[\"可以通过连续跟踪\",{\"1\":{\"47\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"14\":1}}],[\"先判断长度一致\",{\"1\":{\"110\":1}}],[\"先判断头结点的情况\",{\"1\":{\"72\":1}}],[\"先存储\",{\"1\":{\"84\":1}}],[\"先走\",{\"1\":{\"57\":1,\"59\":1}}],[\"删除\",{\"1\":{\"204\":1}}],[\"删除为\",{\"1\":{\"203\":1}}],[\"删除链表的第\",{\"1\":{\"187\":1}}],[\"删除链表的中间节点\",{\"1\":{\"186\":1}}],[\"删除链表的倒数第\",{\"0\":{\"54\":1},\"1\":{\"55\":1}}],[\"删除链表的倒数第n个结点\",{\"0\":{\"53\":1}}],[\"删除链表\",{\"1\":{\"186\":1}}],[\"删除倒数第\",{\"0\":{\"186\":1},\"1\":{\"186\":1}}],[\"删除元素\",{\"1\":{\"167\":1}}],[\"删除方式一样\",{\"1\":{\"76\":1}}],[\"删除值相同的头结点后\",{\"1\":{\"74\":1}}],[\"删除节点\",{\"0\":{\"202\":1},\"1\":{\"71\":1,\"151\":1}}],[\"列表中的节点数目在范围\",{\"1\":{\"71\":1}}],[\"equals\",{\"1\":{\"202\":1}}],[\"e\",{\"1\":{\"199\":3,\"200\":3,\"201\":2}}],[\"expectednums\",{\"1\":{\"114\":3}}],[\"element\",{\"1\":{\"113\":1,\"201\":2}}],[\"elements\",{\"1\":{\"70\":1}}],[\"else\",{\"1\":{\"74\":1,\"77\":1,\"142\":2,\"143\":1,\"144\":2,\"152\":2,\"155\":2,\"163\":2,\"177\":2,\"178\":2,\"179\":2,\"199\":1,\"200\":1,\"201\":2,\"202\":1}}],[\"end++\",{\"1\":{\"96\":1}}],[\"end−start+1\",{\"1\":{\"94\":1}}],[\"end\",{\"1\":{\"54\":1,\"94\":1,\"96\":6,\"177\":1}}],[\"enhance\",{\"1\":{\"19\":1}}],[\"env\",{\"1\":{\"5\":1}}],[\"environment\",{\"1\":{\"5\":1}}],[\"enable\",{\"1\":{\"5\":1}}],[\"这两个链表不相交\",{\"1\":{\"208\":1}}],[\"这类链表题目一般都是使用双指针法解决的\",{\"1\":{\"189\":1}}],[\"这样\",{\"1\":{\"135\":1}}],[\"这样方便后续做删除操作\",{\"1\":{\"103\":1}}],[\"这是他们可以开始的最远的距离\",{\"1\":{\"67\":1}}],[\"这意味着你可以在\",{\"1\":{\"34\":1}}],[\"k−1\",{\"1\":{\"67\":2}}],[\"k\",{\"1\":{\"67\":1,\"114\":11,\"116\":1,\"189\":1}}],[\"key上\",{\"1\":{\"168\":1}}],[\"key\",{\"1\":{\"42\":1,\"167\":1,\"168\":1}}],[\"假设一种极端情况\",{\"1\":{\"178\":1}}],[\"假设链表中的所有节点下标从\",{\"1\":{\"148\":1}}],[\"假设\",{\"1\":{\"114\":1}}],[\"假设循环中有\",{\"1\":{\"67\":1}}],[\"假如这个重复元素是解\",{\"1\":{\"41\":1}}],[\"成本是\",{\"1\":{\"67\":1}}],[\"快慢指针法\",{\"1\":{\"180\":1}}],[\"快慢指针\",{\"0\":{\"185\":1},\"1\":{\"67\":1}}],[\"快乐数\",{\"0\":{\"61\":1,\"62\":1},\"1\":{\"63\":2,\"66\":1}}],[\"计数\",{\"1\":{\"127\":1}}],[\"计算滑动窗口的总和\",{\"1\":{\"94\":1}}],[\"计算每一位的平方和\",{\"1\":{\"67\":1}}],[\"计划\",{\"1\":{\"24\":2}}],[\"8\",{\"1\":{\"122\":1,\"131\":1,\"178\":1,\"208\":7}}],[\"81\",{\"1\":{\"67\":4}}],[\"82\",{\"1\":{\"63\":3}}],[\"最差情况下\",{\"1\":{\"212\":1}}],[\"最大子数组问题\",{\"1\":{\"181\":1}}],[\"最大的平方和为\",{\"1\":{\"67\":2}}],[\"最小\",{\"1\":{\"181\":1}}],[\"最小窗口长度右移\",{\"1\":{\"96\":1}}],[\"最左的下标为\",{\"1\":{\"178\":1}}],[\"最多为\",{\"1\":{\"88\":1}}],[\"最后一个节点的指针域指向\",{\"1\":{\"192\":1}}],[\"最后一个节点的后驱节点是新节点\",{\"1\":{\"152\":1}}],[\"最后返回\",{\"1\":{\"178\":1}}],[\"最后返回的结果\",{\"1\":{\"178\":1}}],[\"最后返回的时候是\",{\"1\":{\"76\":1}}],[\"最后循环\",{\"1\":{\"178\":1}}],[\"最后\",{\"1\":{\"116\":1}}],[\"最后会返回1\",{\"1\":{\"67\":1}}],[\"最终\",{\"1\":{\"49\":1,\"178\":1}}],[\"操作视为寻找下一个数\",{\"1\":{\"66\":1}}],[\"将这种情况视为\",{\"1\":{\"169\":1}}],[\"将一个值为\",{\"1\":{\"148\":3}}],[\"将在\",{\"1\":{\"138\":1}}],[\"将虚拟头结点指向head\",{\"1\":{\"103\":1}}],[\"将\",{\"1\":{\"66\":1,\"86\":1,\"94\":1}}],[\"定义好上下左右四个边界\",{\"1\":{\"133\":1}}],[\"定义两个指针\",{\"1\":{\"94\":1}}],[\"定义两个指针slow和fast\",{\"1\":{\"65\":1}}],[\"定义为\",{\"1\":{\"63\":1}}],[\"检测一个链表是否有环\",{\"1\":{\"65\":1}}],[\"那就出现一种情况\",{\"1\":{\"179\":1}}],[\"那问题就直接转换为\",{\"1\":{\"65\":1}}],[\"那么现在头节点和尾节点都是\",{\"1\":{\"199\":1}}],[\"那么该节点会被追加到链表的末尾\",{\"1\":{\"148\":1}}],[\"那么快跑者需要\",{\"1\":{\"67\":1}}],[\"那么fast将先到达\",{\"1\":{\"67\":1}}],[\"那么存在一个环使得算法无限循环\",{\"1\":{\"67\":1}}],[\"那么这个数就是快乐数\",{\"1\":{\"63\":1}}],[\"那么必定是两个重复元素的和等于\",{\"1\":{\"41\":1}}],[\"得到的链是一个隐式的链表\",{\"1\":{\"65\":1}}],[\"但始终变不到\",{\"1\":{\"63\":1}}],[\"但是我们选择的是左闭右开区间\",{\"1\":{\"140\":1}}],[\"但是\",{\"1\":{\"39\":1}}],[\"编写一个函数来判断\",{\"1\":{\"106\":1}}],[\"编写一个算法来判断一个数\",{\"1\":{\"63\":1}}],[\"编辑此页链接\",{\"1\":{\"8\":1}}],[\"刚好指向倒数第\",{\"1\":{\"59\":1}}],[\"刚好走好倒数第\",{\"1\":{\"57\":1}}],[\"怎么知道是倒数第\",{\"1\":{\"59\":1}}],[\"倒数第\",{\"1\":{\"58\":1}}],[\"当退出循环时\",{\"1\":{\"177\":1}}],[\"当我们使用数组实现哈希表时\",{\"1\":{\"168\":1}}],[\"当我们选择\",{\"1\":{\"140\":1}}],[\"当left\",{\"1\":{\"163\":1}}],[\"当索引小于链表长度的一半时\",{\"1\":{\"154\":1}}],[\"当区间长度为\",{\"1\":{\"143\":1}}],[\"当链表还剩下两个节点时\",{\"1\":{\"101\":1}}],[\"当窗口符合条件时\",{\"1\":{\"95\":1}}],[\"当第一次递归时\",{\"1\":{\"87\":1}}],[\"当前节点\",{\"1\":{\"85\":1}}],[\"当\",{\"1\":{\"57\":1,\"94\":1,\"133\":1,\"154\":1,\"177\":1,\"179\":1,\"210\":2}}],[\"存储头节点\",{\"1\":{\"57\":1}}],[\"存储虚拟头节点\",{\"1\":{\"57\":2}}],[\"存在\",{\"1\":{\"41\":1,\"177\":1}}],[\"并且\",{\"1\":{\"114\":2}}],[\"并且返回链表的头结点\",{\"1\":{\"55\":1}}],[\"并返回交换后链表的头节点\",{\"1\":{\"99\":1}}],[\"并返回其长度\",{\"1\":{\"92\":1}}],[\"并返回反转后的链表\",{\"1\":{\"81\":1}}],[\"并返回\",{\"1\":{\"71\":1}}],[\"并返回它们的数组下标\",{\"1\":{\"39\":1}}],[\"给定两个数组\",{\"1\":{\"122\":1}}],[\"给定两个字符串\",{\"1\":{\"106\":1}}],[\"给定一个\",{\"1\":{\"138\":1}}],[\"给定一个含有\",{\"1\":{\"92\":1}}],[\"给定一个链表的头节点\",{\"1\":{\"47\":1}}],[\"给定一个整数数组\",{\"1\":{\"39\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"208\":1}}],[\"给你一个按\",{\"1\":{\"159\":1}}],[\"给你一个正整数\",{\"1\":{\"131\":1}}],[\"给你一个数组\",{\"1\":{\"114\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"71\":1}}],[\"给你一个链表\",{\"1\":{\"55\":1,\"99\":1}}],[\"给你单链表的头节点\",{\"1\":{\"81\":1}}],[\"第一次\",{\"1\":{\"211\":1}}],[\"第一次符合条件为窗口长度\",{\"1\":{\"96\":1}}],[\"第一次相遇时\",{\"1\":{\"51\":1}}],[\"第一次相遇\",{\"1\":{\"51\":1}}],[\"第二次相遇\",{\"1\":{\"51\":1}}],[\"在遍历对方的链表\",{\"1\":{\"211\":1}}],[\"在遍历过程过程\",{\"1\":{\"154\":1}}],[\"在遍历过程中如果出现数字与需要移除的值\",{\"1\":{\"116\":1}}],[\"在链表第\",{\"1\":{\"187\":1}}],[\"在链表的最后面插入一个节点\",{\"1\":{\"187\":1}}],[\"在链表的最前面插入一个节点\",{\"1\":{\"187\":1}}],[\"在循环过程中\",{\"1\":{\"178\":1}}],[\"在数组中\",{\"1\":{\"178\":1}}],[\"在区间\",{\"1\":{\"178\":1}}],[\"在上面的\",{\"1\":{\"177\":1}}],[\"在冲突的地方继续往前查询\",{\"1\":{\"171\":1}}],[\"在负数\",{\"1\":{\"163\":1}}],[\"在正数\",{\"1\":{\"163\":1}}],[\"在插入完成后\",{\"1\":{\"148\":1}}],[\"在\",{\"1\":{\"143\":1,\"208\":4}}],[\"在左闭右开的情况是找不到这个位置的\",{\"1\":{\"140\":1}}],[\"在左闭右开的情况\",{\"1\":{\"140\":1}}],[\"在每一次移动过程中\",{\"1\":{\"83\":1}}],[\"在虚拟头节点下\",{\"1\":{\"76\":1}}],[\"在环中它们由于步速不一致\",{\"1\":{\"67\":1}}],[\"在继续往下后\",{\"1\":{\"67\":1}}],[\"在次相遇就是环入口\",{\"1\":{\"51\":1}}],[\"在页面禁用功能与布局\",{\"1\":{\"8\":1}}],[\"一个指向上一个节点\",{\"1\":{\"195\":1}}],[\"一个指向下一个节点\",{\"1\":{\"195\":1}}],[\"一部分是\",{\"1\":{\"192\":2}}],[\"一定不等于\",{\"1\":{\"179\":1}}],[\"一定会在循环中\",{\"1\":{\"65\":1}}],[\"一定会在环中相遇\",{\"1\":{\"49\":1}}],[\"一直向左边靠近\",{\"1\":{\"178\":1}}],[\"一直保持不变\",{\"1\":{\"178\":1}}],[\"一旦两个指针都在循环中\",{\"1\":{\"67\":1}}],[\"一起走\",{\"1\":{\"57\":1}}],[\"一起同时\",{\"1\":{\"51\":1}}],[\"让一个指针先走\",{\"1\":{\"59\":1}}],[\"让\",{\"1\":{\"51\":1,\"57\":1,\"59\":2}}],[\"个元素有序的\",{\"1\":{\"138\":1}}],[\"个元素不等于\",{\"1\":{\"116\":1}}],[\"个元素之外留下了什么并不重要\",{\"1\":{\"114\":2}}],[\"个元素\",{\"1\":{\"114\":1}}],[\"个元素包含不等于\",{\"1\":{\"114\":1}}],[\"个数字\",{\"1\":{\"67\":1}}],[\"个节点前面插入一个节点\",{\"1\":{\"187\":1}}],[\"个节点的数值\",{\"1\":{\"187\":2}}],[\"个节点之后的\",{\"1\":{\"186\":1}}],[\"个节点\",{\"0\":{\"186\":1},\"1\":{\"65\":2,\"186\":3,\"189\":1,\"208\":4,\"212\":1}}],[\"个节点位置\",{\"1\":{\"58\":1}}],[\"个\",{\"1\":{\"57\":1,\"59\":2,\"110\":1,\"178\":2}}],[\"个结点\",{\"0\":{\"54\":1},\"1\":{\"55\":1}}],[\"个环\",{\"1\":{\"51\":2}}],[\"个或者以上的重复元素\",{\"1\":{\"41\":1}}],[\"如何找到这个环的入口\",{\"1\":{\"50\":1}}],[\"如果两个链表相交则不能为\",{\"1\":{\"208\":2}}],[\"如果两个链表没有交点\",{\"1\":{\"208\":1}}],[\"如果之前的头节点为null\",{\"1\":{\"199\":1}}],[\"如果非要用\",{\"1\":{\"177\":1}}],[\"如果没有找到的情况下\",{\"1\":{\"177\":1}}],[\"如果没有循环\",{\"1\":{\"67\":1}}],[\"如果遍历结束没有找到\",{\"1\":{\"154\":1}}],[\"如果下标有效\",{\"1\":{\"148\":1}}],[\"如果下标无效\",{\"1\":{\"148\":1}}],[\"如果是双向链表\",{\"1\":{\"148\":1}}],[\"如果是快乐数\",{\"1\":{\"67\":1}}],[\"如果超过了这个条件\",{\"1\":{\"140\":1}}],[\"如果目标值存在返回下标\",{\"1\":{\"138\":1}}],[\"如果相同的时候\",{\"1\":{\"116\":1}}],[\"如果相遇\",{\"1\":{\"67\":1}}],[\"如果所有的断言都通过\",{\"1\":{\"114\":1}}],[\"如果输入字符串包含\",{\"1\":{\"106\":1}}],[\"如果不存在符合条件的子数组\",{\"1\":{\"92\":1}}],[\"如果不存在环\",{\"1\":{\"49\":1}}],[\"如果他们的起点是相隔\",{\"1\":{\"67\":1}}],[\"如果这个过程\",{\"1\":{\"63\":1}}],[\"如果存在环\",{\"1\":{\"49\":1}}],[\"如果\",{\"1\":{\"47\":1,\"63\":1,\"65\":2,\"140\":1,\"148\":2,\"178\":2,\"208\":2}}],[\"如果链表中有某个节点\",{\"1\":{\"47\":1}}],[\"如果链表无环\",{\"1\":{\"47\":1}}],[\"如果只有两个重复元素\",{\"1\":{\"41\":1}}],[\"如果有环\",{\"1\":{\"50\":1}}],[\"如果有\",{\"1\":{\"41\":1}}],[\"如果你已经实现o\",{\"1\":{\"92\":1}}],[\"如果你是一个新手\",{\"1\":{\"15\":1}}],[\"如果你文档需要\",{\"1\":{\"5\":1}}],[\"恰好等于\",{\"1\":{\"49\":1}}],[\"圈的环长度\",{\"1\":{\"49\":1}}],[\"加上\",{\"1\":{\"49\":1}}],[\"其实这也是写程序中的重要原则\",{\"1\":{\"182\":1}}],[\"其实相当于告诉我们\",{\"1\":{\"178\":1}}],[\"其中\",{\"1\":{\"49\":1,\"152\":1,\"155\":1}}],[\"其尾部连接到第一个节点\",{\"1\":{\"47\":1}}],[\"其尾部连接到第二个节点\",{\"1\":{\"47\":1}}],[\"走完\",{\"1\":{\"210\":2}}],[\"走两步\",{\"1\":{\"67\":1}}],[\"走一步\",{\"1\":{\"67\":1}}],[\"走了\",{\"1\":{\"51\":2}}],[\"走过的节点数为\",{\"1\":{\"49\":2}}],[\"走到空节点时时\",{\"1\":{\"57\":1}}],[\"走到\",{\"1\":{\"49\":1}}],[\"相等\",{\"1\":{\"211\":2}}],[\"相交的位置在\",{\"1\":{\"212\":2}}],[\"相交部分长度为\",{\"1\":{\"210\":1}}],[\"相交节点前有\",{\"1\":{\"208\":4}}],[\"相交节点的值为\",{\"1\":{\"208\":2}}],[\"相当于闭区间\",{\"1\":{\"177\":1}}],[\"相当于缩小左边界\",{\"1\":{\"135\":1}}],[\"相当于缩小下边界\",{\"1\":{\"135\":1}}],[\"相当于缩小右边界\",{\"1\":{\"135\":1}}],[\"相当于缩小上边界\",{\"1\":{\"135\":1}}],[\"相同类型数据\",{\"1\":{\"174\":1}}],[\"相遇点到入环点的距离\",{\"1\":{\"49\":1}}],[\"相遇时\",{\"1\":{\"49\":1}}],[\"相关配置文档请见\",{\"1\":{\"2\":1}}],[\"z\",{\"1\":{\"49\":1,\"51\":1}}],[\"再到环形入口节点节点数为\",{\"1\":{\"49\":1}}],[\"从各自的表头开始算起\",{\"1\":{\"208\":3}}],[\"从而将\",{\"1\":{\"181\":1}}],[\"从前往后遍历\",{\"1\":{\"154\":1}}],[\"从下向上填充\",{\"1\":{\"135\":2}}],[\"从下到上\",{\"1\":{\"133\":1}}],[\"从右向左填充\",{\"1\":{\"135\":2}}],[\"从右到左\",{\"1\":{\"133\":1}}],[\"从上向下填充\",{\"1\":{\"135\":2}}],[\"从上到下\",{\"1\":{\"133\":1}}],[\"从左向右填充\",{\"1\":{\"135\":1}}],[\"从左到右填充\",{\"1\":{\"135\":1}}],[\"从左到右\",{\"1\":{\"133\":1}}],[\"从当前节点的后驱节点进行遍历\",{\"1\":{\"72\":1}}],[\"从链表头部到入环点的距离\",{\"1\":{\"49\":1}}],[\"从\",{\"1\":{\"49\":1,\"210\":2}}],[\"从相遇节点\",{\"1\":{\"49\":1}}],[\"从头节点到环形入口节点的节点数为\",{\"1\":{\"49\":1}}],[\"从头节点出发\",{\"1\":{\"49\":1}}],[\"your\",{\"1\":{\"152\":1}}],[\"y+z\",{\"1\":{\"49\":3}}],[\"y\",{\"1\":{\"49\":1}}],[\"yml\",{\"1\":{\"5\":2}}],[\"会将所有的key能映射到数组上对应的索引\",{\"1\":{\"168\":1}}],[\"会相遇\",{\"1\":{\"67\":1}}],[\"会先到\",{\"1\":{\"65\":1}}],[\"会先于\",{\"1\":{\"49\":1}}],[\"会使用\",{\"1\":{\"17\":1}}],[\"由于这两个链表不相交\",{\"1\":{\"208\":1}}],[\"由于我们更新\",{\"1\":{\"179\":1}}],[\"由于需要根据索引来查找节点\",{\"1\":{\"150\":1}}],[\"由于要进行删除操作\",{\"1\":{\"58\":1}}],[\"由于\",{\"1\":{\"49\":1,\"143\":1}}],[\"步骤1\",{\"1\":{\"199\":2}}],[\"步骤二\",{\"1\":{\"103\":1}}],[\"步骤三\",{\"1\":{\"103\":1}}],[\"步骤一\",{\"1\":{\"103\":1}}],[\"步才能到达慢跑者\",{\"1\":{\"67\":1}}],[\"步\",{\"1\":{\"49\":1,\"51\":2,\"57\":1,\"59\":1}}],[\"环形入口节点到\",{\"1\":{\"49\":1}}],[\"环形证明\",{\"1\":{\"48\":1}}],[\"环形链表\",{\"0\":{\"45\":1,\"46\":1,\"189\":1},\"1\":{\"189\":1}}],[\"空间解决此题\",{\"1\":{\"47\":1}}],[\"空间复杂度为\",{\"1\":{\"116\":1}}],[\"空间复杂度主要取决于递归调用的栈空间\",{\"1\":{\"88\":1}}],[\"空间复杂度\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"155\":1,\"163\":1,\"212\":1}}],[\"59\",{\"0\":{\"129\":1,\"130\":1}}],[\"5000\",{\"1\":{\"81\":3}}],[\"50\",{\"1\":{\"71\":2,\"114\":1}}],[\"5\",{\"1\":{\"47\":2,\"55\":2,\"71\":2,\"81\":2,\"106\":1,\"114\":2,\"122\":1,\"131\":1,\"138\":2,\"178\":1,\"208\":9}}],[\"内存的解决方案\",{\"1\":{\"208\":1}}],[\"内存地址是连续\",{\"1\":{\"175\":1}}],[\"内部定义一个\",{\"1\":{\"150\":1}}],[\"内\",{\"1\":{\"47\":1,\"71\":1,\"99\":1}}],[\"内容\",{\"1\":{\"17\":1}}],[\"链长度为\",{\"1\":{\"212\":2}}],[\"链中的所有其他数字都是节点\",{\"1\":{\"65\":1}}],[\"链表必须\",{\"1\":{\"208\":1}}],[\"链表性能分析\",{\"0\":{\"203\":1}}],[\"链表操作\",{\"0\":{\"198\":1}}],[\"链表节点类\",{\"1\":{\"197\":1}}],[\"链表节点交换的指针变动\",{\"1\":{\"102\":1}}],[\"链表的组成单位是\",{\"1\":{\"197\":1}}],[\"链表的基本操作\",{\"0\":{\"187\":1}}],[\"链表在内存中可不是连续分布的\",{\"1\":{\"197\":1}}],[\"链表存储方式\",{\"0\":{\"197\":1}}],[\"链表类型\",{\"0\":{\"193\":1}}],[\"链表是通过\",{\"1\":{\"197\":1}}],[\"链表是一种通过指针串联在一起的线性结构\",{\"1\":{\"192\":1}}],[\"链表是什么\",{\"0\":{\"192\":1}}],[\"链表理论基础\",{\"0\":{\"191\":1}}],[\"链表相交\",{\"0\":{\"188\":1,\"206\":1,\"207\":1},\"1\":{\"188\":1}}],[\"链表总结篇\",{\"0\":{\"183\":1}}],[\"链表基本操作\",{\"1\":{\"149\":1}}],[\"链表结果\",{\"1\":{\"149\":1}}],[\"链表变为\",{\"1\":{\"148\":2}}],[\"链表可以选用迭代或递归方式完成反转\",{\"1\":{\"81\":1}}],[\"链表中数据的插入\",{\"1\":{\"204\":1}}],[\"链表中节点的数目在范围\",{\"1\":{\"99\":1}}],[\"链表中节点的数目范围是\",{\"1\":{\"81\":1}}],[\"链表中节点的数目范围在范围\",{\"1\":{\"47\":1}}],[\"链表中结点的数目为\",{\"1\":{\"55\":1}}],[\"链表中没有环\",{\"1\":{\"47\":1}}],[\"链表中有一个环\",{\"1\":{\"47\":2}}],[\"链表\",{\"1\":{\"47\":1,\"48\":1,\"56\":1,\"71\":1,\"82\":1,\"100\":1,\"167\":1,\"208\":6,\"209\":1},\"2\":{\"52\":1,\"60\":1,\"78\":1,\"89\":1,\"156\":1,\"190\":1,\"205\":1,\"213\":1}}],[\"链接在内存中各个节点\",{\"1\":{\"197\":1}}],[\"链接\",{\"1\":{\"8\":1}}],[\"不涉及到什么算法\",{\"1\":{\"182\":1}}],[\"不断调节子序列的起始位置\",{\"1\":{\"181\":1}}],[\"不要立即返回\",{\"1\":{\"179\":1}}],[\"不在数组中\",{\"1\":{\"178\":1}}],[\"不管是因为什么原因导致的\",{\"1\":{\"177\":1}}],[\"不会插入\",{\"1\":{\"148\":1}}],[\"不考虑输出结果的顺序\",{\"1\":{\"122\":1}}],[\"不相同\",{\"1\":{\"116\":1}}],[\"不同的元素的数量\",{\"1\":{\"114\":1}}],[\"不是快乐数\",{\"1\":{\"65\":1,\"67\":1}}],[\"不是\",{\"1\":{\"63\":1}}],[\"不允许修改\",{\"1\":{\"47\":1}}],[\"不作为参数进行传递\",{\"1\":{\"47\":1}}],[\"不存在\",{\"1\":{\"41\":1,\"138\":1,\"177\":1}}],[\"开始相交\",{\"1\":{\"208\":1}}],[\"开始\",{\"1\":{\"47\":1,\"148\":1,\"175\":1}}],[\"索引从\",{\"1\":{\"47\":1,\"175\":1}}],[\"来定义左边界\",{\"1\":{\"140\":1}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"47\":1}}],[\"来解析\",{\"1\":{\"17\":1}}],[\"评测机将使用以下代码测试您的解决方案\",{\"1\":{\"114\":1}}],[\"评测系统内部使用整数\",{\"1\":{\"47\":1}}],[\"评论\",{\"1\":{\"8\":1,\"11\":1}}],[\"指向下一节点的引用\",{\"1\":{\"197\":1}}],[\"指向头节点\",{\"1\":{\"83\":1}}],[\"指向虚拟节点\",{\"1\":{\"83\":1}}],[\"指针\",{\"1\":{\"210\":2}}],[\"指针域的指针\",{\"1\":{\"197\":1}}],[\"指针域\",{\"1\":{\"192\":1}}],[\"指针相遇节点节点数为\",{\"1\":{\"49\":1}}],[\"指针与\",{\"1\":{\"49\":1}}],[\"指针再次到达\",{\"1\":{\"47\":1}}],[\"指南\",{\"2\":{\"12\":1}}],[\"则删除链表中下标为\",{\"1\":{\"148\":1}}],[\"则还需要属性\",{\"1\":{\"148\":1}}],[\"则跳过该数字不进行拷贝覆盖\",{\"1\":{\"116\":1}}],[\"则进行拷贝覆盖\",{\"1\":{\"116\":1}}],[\"则最终哈希表中所有字符统计数值都应为\",{\"1\":{\"108\":1}}],[\"则\",{\"1\":{\"108\":2}}],[\"则称\",{\"1\":{\"106\":1}}],[\"则说明不是快乐数\",{\"1\":{\"67\":1}}],[\"则就说明没有循环\",{\"1\":{\"65\":1}}],[\"则在该链表中没有环\",{\"1\":{\"47\":1}}],[\"则链表中存在环\",{\"1\":{\"47\":1}}],[\"则返回\",{\"1\":{\"47\":1,\"63\":1,\"148\":1,\"154\":1}}],[\"则将\",{\"1\":{\"41\":1}}],[\"令\",{\"1\":{\"43\":1,\"59\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"155\":1,\"163\":1,\"212\":1}}],[\"复杂度分析\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"155\":1,\"163\":1,\"212\":1}}],[\"<target\",{\"1\":{\"140\":1,\"143\":1}}],[\"<\",{\"1\":{\"43\":1,\"59\":1,\"96\":1,\"110\":2,\"114\":1,\"127\":1,\"142\":2,\"143\":1,\"144\":1,\"155\":1,\"163\":2,\"177\":3,\"178\":3,\"179\":2}}],[\"<=bottom\",{\"1\":{\"135\":1}}],[\"<=\",{\"1\":{\"39\":6,\"47\":2,\"55\":6,\"63\":2,\"71\":4,\"81\":2,\"92\":6,\"99\":2,\"106\":2,\"114\":6,\"122\":4,\"131\":2,\"135\":2,\"144\":1,\"148\":2,\"152\":1,\"155\":1,\"159\":4,\"177\":1,\"208\":8}}],[\"语言支持\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"85\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"152\":1,\"163\":1,\"212\":1}}],[\"语法\",{\"0\":{\"23\":1},\"1\":{\"19\":1,\"34\":1}}],[\"语法进行了扩展\",{\"1\":{\"18\":1}}],[\"语法扩展\",{\"1\":{\"17\":1}}],[\"代表当前节点\",{\"1\":{\"101\":1}}],[\"代表这个重复元素不可能是解\",{\"1\":{\"41\":1}}],[\"代码随想录\",{\"1\":{\"83\":1}}],[\"代码\",{\"0\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"155\":1,\"163\":1,\"212\":1}}],[\"每一个节点有两个指针域\",{\"1\":{\"195\":1}}],[\"每一个节点由两部分组成\",{\"1\":{\"192\":1}}],[\"每一次将该数替换为它每个位置上的数字的平方和\",{\"1\":{\"63\":1}}],[\"每移动一次就减小\",{\"1\":{\"154\":1}}],[\"每次循环的\",{\"1\":{\"178\":1}}],[\"每次比较两个指针对应的数\",{\"1\":{\"161\":1}}],[\"每次取出的数字变量为\",{\"1\":{\"116\":1}}],[\"每次走一步\",{\"1\":{\"49\":1}}],[\"每次走\",{\"1\":{\"49\":1}}],[\"每次走两步\",{\"1\":{\"49\":2}}],[\"每种输入只会对应一个答案\",{\"1\":{\"42\":1}}],[\"每个节点存放着下一个节点的内存地址\",{\"1\":{\"197\":1}}],[\"每个数字的平方\",{\"1\":{\"159\":1}}],[\"每个\",{\"1\":{\"34\":1}}],[\"关键点\",{\"0\":{\"42\":1,\"50\":1,\"58\":1,\"66\":1,\"73\":1,\"76\":1,\"84\":1,\"87\":1,\"95\":1,\"102\":1,\"109\":1,\"117\":1,\"126\":1,\"134\":1,\"141\":1,\"151\":1,\"154\":1,\"162\":1,\"211\":1}}],[\"关于这些扩展\",{\"1\":{\"18\":1}}],[\"关于本站\",{\"0\":{\"5\":1}}],[\"关于我\",{\"0\":{\"3\":1,\"4\":1}}],[\"同时指向\",{\"1\":{\"210\":1}}],[\"同时指向第一个相交节点\",{\"1\":{\"210\":1}}],[\"同时设置一个下标\",{\"1\":{\"116\":1}}],[\"同时每个页面包含\",{\"1\":{\"11\":1}}],[\"同样的道理\",{\"1\":{\"41\":1}}],[\"插入和删除元素\",{\"1\":{\"175\":1}}],[\"插入\",{\"1\":{\"151\":1,\"203\":1}}],[\"插入哈希表\",{\"1\":{\"41\":1}}],[\"插件来实现\",{\"1\":{\"17\":1}}],[\"x+y+n\",{\"1\":{\"49\":2}}],[\"x+y\",{\"1\":{\"49\":2,\"51\":1}}],[\"x\",{\"1\":{\"41\":5,\"42\":2,\"49\":2,\"51\":2,\"131\":1,\"197\":2,\"201\":7,\"202\":12,\"212\":2}}],[\"思路改进\",{\"0\":{\"143\":1}}],[\"思路2\",{\"0\":{\"75\":1,\"86\":1}}],[\"思路1\",{\"0\":{\"72\":1,\"83\":1,\"94\":1,\"101\":1}}],[\"思路\",{\"0\":{\"41\":1,\"49\":1,\"57\":1,\"65\":1,\"108\":1,\"116\":1,\"125\":1,\"133\":1,\"140\":1,\"150\":1,\"153\":1,\"161\":1,\"210\":1}}],[\"进行下一轮的判断并且交换\",{\"1\":{\"101\":1}}],[\"进行遍历\",{\"1\":{\"57\":1}}],[\"进行引用\",{\"1\":{\"33\":1}}],[\"进阶\",{\"1\":{\"39\":1,\"47\":1,\"55\":1,\"81\":1,\"92\":1,\"106\":1,\"159\":1,\"208\":1}}],[\"提示\",{\"1\":{\"39\":1,\"47\":1,\"55\":1,\"63\":1,\"71\":1,\"81\":1,\"92\":1,\"99\":1,\"106\":1,\"114\":1,\"122\":1,\"131\":1,\"138\":1,\"148\":1,\"159\":1,\"208\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"19\":1}}],[\"62\",{\"1\":{\"63\":1}}],[\"68\",{\"1\":{\"63\":1}}],[\"6\",{\"1\":{\"39\":2,\"71\":3,\"131\":1,\"208\":2}}],[\"404\",{\"1\":{\"214\":1}}],[\"49\",{\"1\":{\"159\":1}}],[\"4位数只会降到3位数\",{\"1\":{\"67\":1}}],[\"4\",{\"1\":{\"39\":2,\"47\":2,\"55\":1,\"71\":3,\"81\":2,\"92\":5,\"99\":2,\"106\":1,\"114\":3,\"122\":5,\"131\":1,\"138\":2,\"159\":5,\"208\":13}}],[\"349\",{\"0\":{\"120\":1,\"121\":1}}],[\"324\",{\"1\":{\"67\":1}}],[\"30\",{\"1\":{\"55\":1}}],[\"3\",{\"0\":{\"179\":1},\"1\":{\"39\":4,\"41\":1,\"47\":2,\"55\":3,\"71\":3,\"81\":3,\"92\":4,\"99\":3,\"114\":6,\"131\":2,\"133\":1,\"138\":2,\"144\":1,\"148\":6,\"159\":3,\"208\":9}}],[\"返回反转之后的头节点\",{\"1\":{\"86\":1}}],[\"返回索引为\",{\"1\":{\"47\":2}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"47\":1}}],[\"返回\",{\"1\":{\"39\":1,\"47\":1,\"92\":1,\"114\":1,\"122\":1,\"148\":2,\"159\":1,\"208\":1}}],[\"返回顶部按钮\",{\"1\":{\"8\":1,\"11\":1}}],[\"因为\",{\"1\":{\"39\":1}}],[\"因此返回\",{\"1\":{\"208\":1}}],[\"因此下次\",{\"1\":{\"177\":1}}],[\"因此提供查询节点的方法\",{\"1\":{\"150\":1}}],[\"因此我们不能跳过这个\",{\"1\":{\"143\":1}}],[\"因此我们更新左边界的时候\",{\"1\":{\"140\":1}}],[\"因此右边界我们是判断不到的\",{\"1\":{\"140\":1}}],[\"因此它们并不计入评测\",{\"1\":{\"114\":2}}],[\"因此空间复杂度为常数\",{\"1\":{\"110\":1}}],[\"因此要找到\",{\"1\":{\"58\":1}}],[\"因此可以借助于\",{\"1\":{\"17\":1}}],[\"因此\",{\"1\":{\"14\":1}}],[\"解释\",{\"1\":{\"39\":1,\"47\":3,\"63\":1,\"92\":1,\"114\":2,\"122\":1,\"138\":2,\"148\":1,\"159\":1,\"208\":3}}],[\"07\",{\"0\":{\"206\":1,\"207\":1},\"1\":{\"188\":1}}],[\"02\",{\"0\":{\"207\":1},\"1\":{\"63\":2,\"188\":1}}],[\"0\",{\"1\":{\"39\":4,\"43\":2,\"47\":5,\"55\":1,\"59\":1,\"67\":2,\"71\":2,\"81\":1,\"92\":2,\"96\":6,\"99\":2,\"103\":1,\"108\":1,\"110\":3,\"114\":11,\"118\":1,\"122\":1,\"127\":4,\"135\":2,\"138\":2,\"140\":1,\"142\":1,\"143\":1,\"144\":1,\"148\":2,\"152\":4,\"154\":1,\"155\":3,\"159\":4,\"161\":1,\"163\":1,\"175\":1,\"177\":2,\"178\":6,\"179\":2,\"208\":12,\"210\":2}}],[\"06\",{\"1\":{\"5\":3}}],[\"输出结果中的每个元素一定是\",{\"1\":{\"122\":1}}],[\"输出一个节点\",{\"1\":{\"86\":1}}],[\"输出\",{\"1\":{\"39\":3,\"47\":3,\"55\":3,\"63\":2,\"71\":3,\"81\":3,\"92\":3,\"99\":3,\"106\":2,\"114\":2,\"122\":2,\"131\":2,\"138\":2,\"148\":1,\"159\":2,\"208\":3}}],[\"输入数组\",{\"1\":{\"114\":1}}],[\"输入\",{\"1\":{\"39\":3,\"47\":3,\"55\":3,\"63\":2,\"71\":3,\"81\":3,\"92\":3,\"99\":3,\"106\":2,\"114\":2,\"122\":2,\"131\":2,\"138\":2,\"148\":1,\"159\":2,\"208\":3}}],[\"977\",{\"0\":{\"157\":1,\"158\":1}}],[\"9999\",{\"1\":{\"138\":2}}],[\"9^2+9^2+9^2\",{\"1\":{\"67\":1}}],[\"92\",{\"1\":{\"63\":1}}],[\"9\",{\"1\":{\"39\":6,\"122\":5,\"131\":1,\"138\":4,\"159\":5,\"208\":2}}],[\"707\",{\"0\":{\"146\":1,\"147\":1},\"1\":{\"187\":1}}],[\"704\",{\"0\":{\"136\":1,\"137\":1}}],[\"7\",{\"1\":{\"39\":1,\"71\":5,\"92\":1,\"131\":1,\"159\":1,\"178\":1}}],[\"示例\",{\"1\":{\"39\":3,\"47\":3,\"55\":3,\"63\":2,\"71\":3,\"81\":3,\"92\":3,\"99\":3,\"106\":2,\"114\":2,\"122\":2,\"131\":2,\"138\":2,\"148\":1,\"159\":2,\"208\":3}}],[\"两两交换其中相邻的节点\",{\"1\":{\"99\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"97\":1,\"98\":1}}],[\"两个存储数组都是固定长度\",{\"1\":{\"127\":1}}],[\"两个数组的交集\",{\"0\":{\"120\":1,\"121\":1}}],[\"两个\",{\"1\":{\"39\":1}}],[\"两数之和\",{\"0\":{\"37\":1,\"38\":1}}],[\"力扣\",{\"0\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"++\",{\"1\":{\"110\":1,\"127\":2}}],[\"++i\",{\"1\":{\"43\":1}}],[\"+1\",{\"1\":{\"108\":1,\"142\":1}}],[\"+=\",{\"1\":{\"67\":1,\"96\":1}}],[\"+z\",{\"1\":{\"49\":1}}],[\"+\",{\"1\":{\"34\":1,\"39\":1,\"63\":5,\"67\":3,\"96\":2,\"142\":1,\"143\":1,\"144\":2,\"177\":4,\"178\":2,\"179\":5,\"208\":2}}],[\"标签为\",{\"1\":{\"32\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"31\":1}}],[\"标题和页面信息\",{\"1\":{\"11\":1}}],[\"分析如下\",{\"1\":{\"177\":1}}],[\"分别出发\",{\"1\":{\"210\":1}}],[\"分别从\",{\"1\":{\"210\":1}}],[\"分别指向滑动窗口的开始位置和结束位置\",{\"1\":{\"94\":1}}],[\"分别定义为\",{\"1\":{\"49\":1}}],[\"分类为\",{\"1\":{\"32\":1}}],[\"分支\",{\"1\":{\"5\":1}}],[\"日\",{\"1\":{\"32\":1}}],[\"月\",{\"1\":{\"32\":1}}],[\"年\",{\"1\":{\"32\":1}}],[\"的头节点\",{\"1\":{\"199\":1}}],[\"的暴力解法降为\",{\"1\":{\"181\":1}}],[\"的操作发生\",{\"1\":{\"179\":1}}],[\"的下界\",{\"1\":{\"179\":1}}],[\"的下标就是答案\",{\"1\":{\"41\":1}}],[\"的下标与\",{\"1\":{\"41\":1}}],[\"的上界right\",{\"1\":{\"178\":1}}],[\"的集合\",{\"1\":{\"174\":1}}],[\"的情况\",{\"1\":{\"169\":1}}],[\"的算法解决本问题\",{\"1\":{\"159\":1}}],[\"的算法吗\",{\"1\":{\"39\":1}}],[\"的次数不超过\",{\"1\":{\"148\":1}}],[\"的时候\",{\"1\":{\"140\":1}}],[\"的时间\",{\"1\":{\"127\":1}}],[\"的每个元素都将在\",{\"1\":{\"138\":1}}],[\"的第一个还是第二个\",{\"1\":{\"135\":1}}],[\"的值都在target的右侧\",{\"1\":{\"178\":1}}],[\"的值\",{\"1\":{\"154\":1,\"178\":1}}],[\"的值排序\",{\"1\":{\"114\":1}}],[\"的值为\",{\"1\":{\"47\":1}}],[\"的大小并不重要\",{\"1\":{\"114\":1}}],[\"的其余元素和\",{\"1\":{\"114\":1}}],[\"的前驱节点为\",{\"1\":{\"199\":1}}],[\"的前\",{\"1\":{\"114\":2}}],[\"的元素有\",{\"1\":{\"178\":2}}],[\"的元素数量为\",{\"1\":{\"114\":1}}],[\"的元素\",{\"1\":{\"114\":2}}],[\"的字母异位词\",{\"1\":{\"106\":1}}],[\"的节点之前\",{\"1\":{\"148\":1}}],[\"的节点插入到链表中下标为\",{\"1\":{\"148\":1}}],[\"的节点插入到链表中第一个元素之前\",{\"1\":{\"148\":1}}],[\"的节点追加到链表中作为链表的最后一个元素\",{\"1\":{\"148\":1}}],[\"的节点的值\",{\"1\":{\"148\":1}}],[\"的节点\",{\"1\":{\"71\":1,\"148\":1}}],[\"的位置正好是答案\",{\"1\":{\"140\":1}}],[\"的位置明显不是答案\",{\"1\":{\"140\":1}}],[\"的位置我们是可以取到的\",{\"1\":{\"140\":1}}],[\"的位置\",{\"1\":{\"67\":1,\"143\":1}}],[\"的步速大于\",{\"1\":{\"49\":1}}],[\"的链表节点\",{\"1\":{\"47\":2}}],[\"的那\",{\"1\":{\"39\":1}}],[\"的\",{\"1\":{\"31\":1,\"32\":1,\"122\":1}}],[\"about\",{\"0\":{\"215\":1}}],[\"abs\",{\"1\":{\"163\":6}}],[\"a+b\",{\"1\":{\"212\":3}}],[\"a+\",{\"1\":{\"210\":1}}],[\"at\",{\"1\":{\"208\":2}}],[\"algo\",{\"1\":{\"168\":1}}],[\"addatindex\",{\"1\":{\"148\":4,\"152\":3,\"155\":3}}],[\"addattail\",{\"1\":{\"148\":4,\"152\":5,\"155\":4}}],[\"addathead\",{\"1\":{\"148\":4,\"152\":4,\"155\":4}}],[\"add\",{\"1\":{\"127\":1}}],[\"array\",{\"1\":{\"158\":1}}],[\"arraylist<>\",{\"1\":{\"127\":1}}],[\"arrays\",{\"1\":{\"121\":1}}],[\"actuallength\",{\"1\":{\"114\":1}}],[\"action\",{\"1\":{\"5\":2}}],[\"actions\",{\"1\":{\"5\":2}}],[\"a\",{\"1\":{\"110\":2,\"158\":1,\"208\":5,\"210\":4,\"212\":5}}],[\"and\",{\"1\":{\"152\":1}}],[\"anagram\",{\"1\":{\"105\":1,\"106\":1}}],[\"ans++\",{\"1\":{\"118\":1}}],[\"ans\",{\"1\":{\"96\":6,\"116\":4,\"118\":3}}],[\"assert\",{\"1\":{\"114\":2}}],[\"as\",{\"1\":{\"31\":1,\"152\":1}}],[\"hello\",{\"1\":{\"168\":1}}],[\"headb\",{\"1\":{\"208\":1,\"210\":5,\"212\":4}}],[\"heada\",{\"1\":{\"208\":1,\"210\":5,\"212\":4}}],[\"head\",{\"1\":{\"47\":4,\"51\":6,\"55\":3,\"59\":4,\"71\":4,\"72\":2,\"74\":9,\"77\":1,\"81\":4,\"85\":2,\"86\":2,\"88\":8,\"99\":3,\"103\":5,\"152\":18,\"153\":1,\"155\":9}}],[\"hash\",{\"1\":{\"168\":1}}],[\"hash2\",{\"1\":{\"127\":3}}],[\"hash1\",{\"1\":{\"127\":3}}],[\"hashmap<>\",{\"1\":{\"43\":1}}],[\"happy\",{\"1\":{\"62\":1}}],[\"https\",{\"1\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"hope\",{\"1\":{\"32\":1}}],[\"h1\",{\"1\":{\"31\":2}}],[\"h2o\",{\"1\":{\"26\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"30\":1}}],[\"注意这五个元素可以任意顺序返回\",{\"1\":{\"114\":1}}],[\"注意\",{\"1\":{\"5\":1,\"47\":1,\"106\":1,\"140\":1,\"177\":3,\"178\":3,\"179\":1,\"208\":3}}],[\"上的\",{\"1\":{\"174\":1}}],[\"上边界缩减\",{\"1\":{\"133\":1}}],[\"上下角标\",{\"0\":{\"26\":1}}],[\"上一篇\",{\"1\":{\"8\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"25\":1}}],[\"27\",{\"0\":{\"112\":1,\"113\":1}}],[\"26\",{\"1\":{\"110\":3}}],[\"242\",{\"0\":{\"104\":1,\"105\":1}}],[\"24\",{\"0\":{\"97\":1,\"98\":1}}],[\"243\",{\"1\":{\"67\":1}}],[\"2⋅logn\",{\"1\":{\"67\":1}}],[\"231\",{\"1\":{\"63\":1}}],[\"22\",{\"1\":{\"63\":1}}],[\"2n\",{\"1\":{\"51\":1}}],[\"2\",{\"0\":{\"178\":1},\"1\":{\"24\":1,\"39\":6,\"47\":3,\"49\":1,\"55\":5,\"59\":2,\"63\":2,\"65\":1,\"71\":3,\"81\":5,\"85\":3,\"92\":4,\"99\":3,\"106\":1,\"114\":12,\"122\":6,\"131\":3,\"138\":3,\"142\":1,\"143\":1,\"144\":2,\"148\":5,\"155\":1,\"159\":2,\"177\":1,\"178\":2,\"179\":1,\"208\":13}}],[\"2000\",{\"1\":{\"148\":1}}],[\"209\",{\"0\":{\"90\":1,\"91\":1}}],[\"206\",{\"0\":{\"79\":1,\"80\":1},\"1\":{\"185\":1}}],[\"203\",{\"0\":{\"69\":1,\"70\":1},\"1\":{\"184\":1}}],[\"202\",{\"0\":{\"61\":1,\"62\":1}}],[\"2020\",{\"1\":{\"32\":1}}],[\"2024\",{\"1\":{\"5\":3}}],[\"20\",{\"1\":{\"5\":1,\"131\":1}}],[\"−1\",{\"1\":{\"23\":1,\"108\":1}}],[\"rat\",{\"1\":{\"106\":1}}],[\"right+1\",{\"1\":{\"177\":1}}],[\"right时\",{\"1\":{\"163\":1}}],[\"right=mid−1\",{\"1\":{\"140\":1}}],[\"right=mid\",{\"1\":{\"140\":1}}],[\"right\",{\"1\":{\"96\":1,\"133\":1,\"135\":7,\"140\":2,\"142\":4,\"143\":4,\"144\":4,\"163\":12,\"177\":17,\"178\":12,\"179\":5}}],[\"ret\",{\"1\":{\"152\":3,\"163\":6}}],[\"return\",{\"1\":{\"43\":2,\"51\":3,\"59\":2,\"67\":3,\"74\":2,\"77\":1,\"85\":1,\"88\":2,\"96\":2,\"103\":2,\"110\":3,\"118\":1,\"127\":1,\"135\":1,\"142\":2,\"143\":2,\"144\":2,\"152\":6,\"155\":5,\"163\":1,\"177\":3,\"178\":6,\"179\":2,\"201\":1,\"202\":3,\"212\":2}}],[\"res\",{\"1\":{\"127\":3,\"135\":6}}],[\"reslist\",{\"1\":{\"127\":4}}],[\"reverselist\",{\"1\":{\"85\":1,\"88\":2}}],[\"reverse\",{\"1\":{\"80\":1}}],[\"removeelement\",{\"1\":{\"114\":1,\"118\":1}}],[\"removeelements\",{\"1\":{\"74\":1,\"77\":1}}],[\"removenthfromend\",{\"1\":{\"59\":1}}],[\"remove\",{\"1\":{\"54\":1,\"70\":1,\"113\":1,\"202\":1}}],[\"regarded\",{\"1\":{\"31\":1}}],[\"r−i​\",{\"1\":{\"23\":1}}],[\"r−i+1\",{\"1\":{\"23\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"23\":1}}],[\"run\",{\"1\":{\"5\":3}}],[\"runs\",{\"1\":{\"5\":1}}],[\"=num\",{\"1\":{\"116\":1}}],[\"=null\",{\"1\":{\"72\":1,\"77\":1}}],[\"=val\",{\"1\":{\"72\":1}}],[\"=o\",{\"1\":{\"67\":1}}],[\"=>\",{\"1\":{\"49\":1,\"177\":1}}],[\"==target\",{\"1\":{\"140\":1,\"143\":1}}],[\"==\",{\"1\":{\"39\":1,\"51\":5,\"59\":2,\"67\":2,\"71\":1,\"74\":3,\"88\":2,\"96\":2,\"103\":2,\"114\":2,\"143\":1,\"144\":1,\"152\":4,\"155\":4,\"163\":2,\"177\":6,\"178\":8,\"179\":3,\"199\":1,\"200\":1,\"201\":2,\"202\":2,\"208\":2,\"210\":1,\"212\":4}}],[\"=\",{\"1\":{\"23\":1,\"39\":6,\"43\":4,\"47\":6,\"49\":2,\"51\":10,\"55\":6,\"59\":12,\"63\":6,\"67\":11,\"71\":6,\"74\":9,\"77\":3,\"81\":3,\"85\":12,\"88\":3,\"92\":6,\"96\":8,\"99\":3,\"101\":4,\"103\":14,\"106\":4,\"110\":5,\"114\":13,\"118\":3,\"122\":4,\"127\":7,\"131\":2,\"133\":1,\"135\":15,\"138\":4,\"142\":5,\"143\":5,\"144\":5,\"148\":1,\"152\":27,\"155\":32,\"159\":2,\"162\":1,\"163\":8,\"168\":1,\"177\":9,\"178\":11,\"179\":11,\"197\":1,\"199\":5,\"200\":5,\"201\":10,\"202\":6,\"208\":15,\"210\":1,\"212\":7}}],[\"ωyω​\",{\"1\":{\"23\":2}}],[\"∂ωr∂r​\",{\"1\":{\"23\":1}}],[\"导入文件\",{\"0\":{\"22\":1}}],[\"导航栏\",{\"1\":{\"8\":1,\"11\":1}}],[\"脚注\",{\"0\":{\"21\":1}}],[\"对象当成链表中的节点\",{\"1\":{\"150\":1}}],[\"对象\",{\"1\":{\"148\":1,\"197\":1}}],[\"对于变量的边界怎么定义\",{\"1\":{\"135\":1}}],[\"对于一个四位数来说\",{\"1\":{\"67\":1}}],[\"对于一个三位数来说\",{\"1\":{\"67\":1}}],[\"对于一个正整数\",{\"1\":{\"63\":1}}],[\"对于每个\",{\"1\":{\"41\":1}}],[\"对于\",{\"1\":{\"33\":1}}],[\"对\",{\"1\":{\"18\":1,\"65\":1}}],[\"为\",{\"1\":{\"152\":1,\"154\":1,\"155\":1,\"199\":1,\"208\":7,\"212\":2}}],[\"为奇数时\",{\"1\":{\"133\":1}}],[\"为nums1数组长度\",{\"1\":{\"127\":1}}],[\"为起点的链表进行反转\",{\"1\":{\"86\":1}}],[\"为链表长度\",{\"1\":{\"85\":1,\"88\":1,\"103\":1,\"152\":1,\"155\":1}}],[\"为走过的环的圈数\",{\"1\":{\"49\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"47\":1}}],[\"为了丰富文档写作\",{\"1\":{\"18\":1}}],[\"为数组长度\",{\"1\":{\"43\":1,\"59\":1,\"74\":1,\"77\":1,\"96\":1,\"110\":1,\"118\":1,\"135\":1,\"142\":1,\"163\":1}}],[\"为每个\",{\"1\":{\"16\":1}}],[\"扩展\",{\"0\":{\"17\":1,\"18\":1},\"1\":{\"18\":1}}],[\"了解详情\",{\"1\":{\"16\":1}}],[\"请不要使用内置的\",{\"1\":{\"148\":1}}],[\"请尝试设计一个\",{\"1\":{\"92\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"208\":1}}],[\"请你\",{\"1\":{\"159\":1}}],[\"请你反转链表\",{\"1\":{\"81\":1}}],[\"请你删除链表中所有满足\",{\"1\":{\"71\":1}}],[\"请你在该数组中找出\",{\"1\":{\"39\":1}}],[\"请使用绝对链接\",{\"1\":{\"33\":1}}],[\"请阅读\",{\"1\":{\"16\":1,\"18\":1}}],[\"请先阅读\",{\"1\":{\"15\":1}}],[\"中节点数目为\",{\"1\":{\"208\":2}}],[\"中\",{\"1\":{\"204\":1,\"208\":4}}],[\"中继续搜索\",{\"1\":{\"178\":1}}],[\"中因此返回\",{\"1\":{\"138\":1}}],[\"中并且下标为\",{\"1\":{\"138\":1}}],[\"中心数字无法在迭代过程中被填充\",{\"1\":{\"133\":1}}],[\"中不等于\",{\"1\":{\"114\":1}}],[\"中与\",{\"1\":{\"114\":1}}],[\"中每个字符出现的次数都相同\",{\"1\":{\"106\":1}}],[\"中使用\",{\"1\":{\"34\":1}}],[\"中设置页面信息\",{\"1\":{\"32\":1}}],[\"中设置页面标题\",{\"1\":{\"31\":1}}],[\"中的所有元素是不重复的\",{\"1\":{\"138\":1}}],[\"中的前五个元素为\",{\"1\":{\"114\":1}}],[\"中的前两个元素均为\",{\"1\":{\"114\":1}}],[\"中的第一个\",{\"1\":{\"31\":1}}],[\"中的\",{\"1\":{\"18\":1,\"138\":1}}],[\"中很重要的一个概念\",{\"1\":{\"16\":1}}],[\"中自定义它们\",{\"1\":{\"11\":1}}],[\"是指向下一个节点的指针\",{\"1\":{\"148\":1}}],[\"是当前节点的值\",{\"1\":{\"148\":1}}],[\"是可以合并起来的\",{\"1\":{\"143\":1}}],[\"是为了解决当\",{\"1\":{\"133\":1}}],[\"是否是\",{\"1\":{\"106\":1}}],[\"是否存在于哈希表中\",{\"1\":{\"41\":1}}],[\"是该条件下的长度最小的子数组\",{\"1\":{\"92\":1}}],[\"是快乐数\",{\"1\":{\"65\":1}}],[\"是不是快乐数\",{\"1\":{\"63\":1}}],[\"是\",{\"1\":{\"16\":1,\"42\":1,\"47\":1,\"63\":1,\"178\":1,\"179\":1}}],[\"通过添加虚拟头节点的方式\",{\"1\":{\"184\":1}}],[\"通过一个快指针和慢指针在一个\",{\"1\":{\"180\":1}}],[\"通过某种算法将\",{\"1\":{\"168\":1}}],[\"通过建立键\",{\"1\":{\"167\":1}}],[\"通过上面的总结会发现边界的起始和结束与方向是对应的\",{\"1\":{\"135\":1}}],[\"通过反复调用\",{\"1\":{\"65\":1}}],[\"通过查询\",{\"1\":{\"41\":1}}],[\"通过\",{\"1\":{\"16\":1,\"19\":1,\"114\":1}}],[\"配置\",{\"0\":{\"16\":1}}],[\"配置项的相关说明详见\",{\"1\":{\"0\":1}}],[\"演示\",{\"1\":{\"15\":1}}],[\"和一个\",{\"1\":{\"153\":1}}],[\"和一个目标值\",{\"1\":{\"138\":1}}],[\"和一个值\",{\"1\":{\"114\":1}}],[\"和一个整数\",{\"1\":{\"71\":1}}],[\"和一个整数目标值\",{\"1\":{\"39\":1}}],[\"和为目标值\",{\"1\":{\"39\":1}}],[\"和\",{\"1\":{\"15\":1,\"32\":1,\"42\":1,\"49\":2,\"51\":1,\"57\":1,\"65\":1,\"94\":1,\"101\":2,\"106\":4,\"122\":1,\"143\":1,\"148\":2,\"152\":1,\"153\":1,\"155\":1,\"161\":1,\"186\":1,\"208\":4,\"212\":1}}],[\"你在返回的\",{\"1\":{\"114\":2}}],[\"你的函数应该返回\",{\"1\":{\"114\":1}}],[\"你的函数函数应该返回\",{\"1\":{\"114\":1}}],[\"你的解决方案将会\",{\"1\":{\"114\":1}}],[\"你需要\",{\"1\":{\"114\":1}}],[\"你需要创建并编写\",{\"1\":{\"14\":1}}],[\"你必须在不修改节点内部的值的情况下完成本题\",{\"1\":{\"99\":1}}],[\"你能否设计一个时间复杂度\",{\"1\":{\"208\":1}}],[\"你能否调整你的解法来应对这种情况\",{\"1\":{\"106\":1}}],[\"你能否用两种方法解决这道题\",{\"1\":{\"81\":1}}],[\"你能尝试使用一趟扫描实现吗\",{\"1\":{\"55\":1}}],[\"你是否可以使用\",{\"1\":{\"47\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"34\":1}}],[\"你可以选择使用单链表或者双链表\",{\"1\":{\"148\":1}}],[\"你可以假设\",{\"1\":{\"138\":1}}],[\"你可以假设每种输入只会对应一个答案\",{\"1\":{\"39\":1}}],[\"你可以想出一个时间复杂度小于\",{\"1\":{\"39\":1}}],[\"你可以按任意顺序返回答案\",{\"1\":{\"39\":1}}],[\"你可以将图片和\",{\"1\":{\"33\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"33\":1}}],[\"你可以在\",{\"1\":{\"31\":1,\"32\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"11\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"14\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"8\":1}}],[\"展示\",{\"0\":{\"14\":1}}],[\"打印按钮\",{\"1\":{\"11\":1}}],[\"夜间模式按钮\",{\"1\":{\"11\":1}}],[\"文章标题列表\",{\"1\":{\"11\":1}}],[\"文件夹的图片\",{\"1\":{\"33\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"33\":1}}],[\"文件生成页面\",{\"1\":{\"14\":1}}],[\"文件\",{\"1\":{\"5\":1}}],[\"布局包括\",{\"1\":{\"11\":1}}],[\"布局\",{\"0\":{\"11\":1},\"2\":{\"13\":1}}],[\"布局与功能禁用\",{\"0\":{\"8\":1}}],[\"禁用\",{\"2\":{\"10\":1}}],[\"禁用了如下功能\",{\"1\":{\"8\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"34\":1}}],[\"页面内容\",{\"0\":{\"33\":1}}],[\"页面标题\",{\"0\":{\"31\":1},\"1\":{\"31\":1}}],[\"页面配置\",{\"0\":{\"30\":1},\"1\":{\"32\":1},\"2\":{\"36\":1}}],[\"页面引入配置\",{\"1\":{\"16\":1}}],[\"页面信息\",{\"0\":{\"32\":1},\"1\":{\"8\":1}}],[\"页脚\",{\"1\":{\"8\":1,\"11\":1}}],[\"贡献者\",{\"1\":{\"8\":1,\"11\":1}}],[\"路径导航\",{\"1\":{\"8\":1,\"11\":1}}],[\"侧边栏\",{\"1\":{\"8\":1,\"11\":1}}],[\"本页面就是一个示例\",{\"1\":{\"8\":1}}],[\"主操作不变\",{\"1\":{\"67\":1}}],[\"主题扩展了更多\",{\"1\":{\"19\":1}}],[\"主题扩展\",{\"0\":{\"19\":1}}],[\"主题也带有以下元素\",{\"1\":{\"11\":1}}],[\"主要从\",{\"1\":{\"14\":1}}],[\"主要功能与配置演示\",{\"0\":{\"6\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\">target\",{\"1\":{\"140\":1}}],[\">=\",{\"1\":{\"96\":1,\"135\":2,\"152\":2}}],[\">2\",{\"1\":{\"85\":1}}],[\">\",{\"1\":{\"5\":1,\"67\":1,\"127\":2,\"142\":1,\"143\":1,\"148\":3,\"152\":1,\"155\":1,\"163\":1,\"177\":3,\"178\":2,\"179\":1,\"210\":1}}],[\"b+a\",{\"1\":{\"212\":1}}],[\"b+\",{\"1\":{\"210\":1}}],[\"b\",{\"1\":{\"208\":5,\"210\":4,\"212\":5}}],[\"bugstack\",{\"1\":{\"199\":1,\"200\":1,\"201\":1,\"202\":1}}],[\"build\",{\"1\":{\"5\":1}}],[\"binarysearch\",{\"1\":{\"177\":1}}],[\"binary\",{\"1\":{\"137\":1}}],[\"bound\",{\"1\":{\"178\":1}}],[\"bootom\",{\"1\":{\"135\":1}}],[\"boolean\",{\"1\":{\"67\":1,\"110\":1,\"155\":1,\"202\":1}}],[\"bottom\",{\"1\":{\"133\":1,\"135\":5}}],[\"break\",{\"1\":{\"51\":1}}],[\"branch\",{\"1\":{\"5\":1}}],[\"branches\",{\"1\":{\"5\":1}}],[\"be\",{\"1\":{\"31\":1,\"152\":1}}],[\"overflow\",{\"1\":{\"177\":1}}],[\"obj\",{\"1\":{\"152\":6}}],[\"object\",{\"1\":{\"152\":1,\"202\":1}}],[\"of\",{\"1\":{\"54\":1,\"121\":1,\"158\":1,\"207\":1}}],[\"o\",{\"1\":{\"39\":1,\"43\":2,\"47\":1,\"51\":2,\"59\":2,\"67\":4,\"74\":2,\"77\":2,\"85\":2,\"88\":2,\"92\":1,\"96\":2,\"103\":2,\"110\":2,\"116\":1,\"118\":2,\"127\":3,\"135\":2,\"142\":2,\"152\":6,\"155\":7,\"159\":1,\"163\":2,\"167\":9,\"175\":2,\"181\":2,\"202\":3,\"203\":1,\"208\":2,\"212\":2}}],[\"old\",{\"1\":{\"5\":1}}],[\"options\",{\"1\":{\"5\":1}}],[\"on\",{\"1\":{\"5\":2}}],[\"lcci\",{\"1\":{\"207\":1}}],[\"l\",{\"1\":{\"143\":2,\"200\":4}}],[\"l<r∣∣t<b\",{\"1\":{\"133\":1}}],[\"last\",{\"1\":{\"88\":2,\"199\":1,\"200\":2,\"201\":1}}],[\"latest\",{\"1\":{\"5\":1}}],[\"linklast\",{\"1\":{\"200\":1}}],[\"linkfirst\",{\"1\":{\"199\":1}}],[\"linkedlist\",{\"1\":{\"148\":1,\"204\":1}}],[\"linked\",{\"1\":{\"46\":1,\"51\":1,\"59\":1,\"70\":1,\"74\":1,\"77\":1,\"80\":1,\"85\":1,\"103\":1,\"147\":1,\"207\":1,\"212\":1}}],[\"listb\",{\"1\":{\"208\":7,\"210\":3,\"212\":1}}],[\"lista\",{\"1\":{\"208\":7,\"210\":3,\"212\":1}}],[\"lists\",{\"1\":{\"207\":1}}],[\"list<integer>\",{\"1\":{\"127\":1}}],[\"listnode\",{\"1\":{\"51\":6,\"59\":12,\"74\":9,\"77\":11,\"85\":11,\"88\":3,\"103\":13,\"197\":3,\"212\":8}}],[\"list\",{\"1\":{\"46\":1,\"51\":1,\"54\":1,\"59\":1,\"70\":1,\"74\":1,\"77\":1,\"80\":1,\"85\":1,\"103\":1,\"147\":1,\"212\":1}}],[\"left=mid+1\",{\"1\":{\"140\":1}}],[\"left++\",{\"1\":{\"135\":1,\"163\":1}}],[\"left\",{\"1\":{\"96\":1,\"133\":1,\"135\":6,\"140\":2,\"142\":4,\"143\":4,\"144\":4,\"163\":9,\"177\":19,\"178\":26,\"179\":16}}],[\"length\",{\"1\":{\"39\":1,\"43\":1,\"92\":1,\"96\":1,\"106\":2,\"110\":3,\"114\":2,\"122\":2,\"142\":1,\"143\":1,\"144\":1,\"159\":1,\"163\":2,\"177\":2,\"178\":6,\"179\":1}}],[\"leetcode\",{\"0\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"165\":1,\"207\":1},\"1\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"log\",{\"1\":{\"92\":1}}],[\"logn\",{\"1\":{\"67\":2,\"142\":1}}],[\"logy\",{\"1\":{\"23\":2}}],[\"lockfile\",{\"1\":{\"5\":1}}],[\"f\",{\"1\":{\"199\":4}}],[\"final\",{\"1\":{\"199\":2,\"200\":2,\"201\":3}}],[\"first=cur\",{\"1\":{\"101\":1}}],[\"firstindex\",{\"1\":{\"43\":2}}],[\"first\",{\"1\":{\"31\":1,\"43\":2,\"57\":4,\"59\":8,\"101\":4,\"103\":4,\"199\":2,\"200\":1,\"201\":1,\"202\":2,\"212\":6}}],[\"false\",{\"1\":{\"63\":2,\"106\":1,\"110\":2,\"202\":1}}],[\"fastrunner\",{\"1\":{\"67\":8}}],[\"fast在链表前进\",{\"1\":{\"65\":1}}],[\"fast\",{\"1\":{\"49\":8,\"51\":12,\"65\":2,\"67\":1}}],[\"found\",{\"1\":{\"214\":1}}],[\"for循环中变量定义成i或j的细节\",{\"1\":{\"135\":1}}],[\"for\",{\"1\":{\"43\":1,\"51\":1,\"59\":2,\"74\":1,\"77\":1,\"85\":1,\"103\":1,\"110\":2,\"114\":1,\"118\":1,\"127\":4,\"135\":4,\"152\":1,\"155\":1,\"180\":2,\"202\":2,\"212\":1}}],[\"folder\",{\"1\":{\"5\":1}}],[\"from\",{\"1\":{\"54\":1}}],[\"frontmatter\",{\"1\":{\"8\":1,\"11\":1,\"16\":4,\"31\":1,\"32\":1}}],[\"frozen\",{\"1\":{\"5\":1}}],[\"fetch\",{\"1\":{\"5\":1}}],[\"i代表行\",{\"1\":{\"135\":1}}],[\"i++\",{\"1\":{\"59\":1,\"110\":2,\"114\":1,\"127\":1,\"135\":1,\"152\":1}}],[\"ii\",{\"0\":{\"45\":1,\"46\":1,\"129\":1,\"130\":1},\"1\":{\"46\":1,\"130\":1,\"189\":1}}],[\"if\",{\"1\":{\"43\":1,\"51\":3,\"59\":1,\"67\":1,\"74\":2,\"77\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":2,\"118\":1,\"127\":1,\"142\":2,\"143\":2,\"144\":2,\"152\":6,\"155\":6,\"163\":3,\"177\":3,\"178\":6,\"179\":4,\"199\":1,\"200\":1,\"201\":2,\"202\":3,\"212\":1}}],[\"i\",{\"1\":{\"34\":1,\"39\":1,\"43\":7,\"59\":2,\"92\":1,\"110\":7,\"114\":5,\"122\":2,\"127\":11,\"135\":7,\"152\":2,\"159\":1}}],[\"instantiated\",{\"1\":{\"152\":1}}],[\"install\",{\"1\":{\"5\":1}}],[\"indexprenode\",{\"1\":{\"152\":3}}],[\"indexnode\",{\"1\":{\"152\":3}}],[\"index++\",{\"1\":{\"127\":1}}],[\"index\",{\"1\":{\"127\":1,\"148\":9,\"152\":17,\"154\":2,\"155\":16,\"163\":5,\"168\":1,\"187\":3}}],[\"intersected\",{\"1\":{\"208\":2}}],[\"intersectval\",{\"1\":{\"208\":6}}],[\"intersection\",{\"1\":{\"121\":1,\"127\":1,\"207\":1}}],[\"integer\",{\"1\":{\"96\":2}}],[\"integer>\",{\"1\":{\"43\":1}}],[\"int\",{\"1\":{\"43\":8,\"51\":2,\"59\":5,\"67\":7,\"74\":4,\"77\":4,\"85\":3,\"96\":7,\"103\":3,\"110\":4,\"114\":5,\"118\":5,\"127\":14,\"135\":10,\"142\":6,\"143\":6,\"144\":6,\"148\":7,\"152\":13,\"155\":11,\"163\":7,\"177\":6,\"178\":6,\"179\":6,\"197\":2,\"212\":2}}],[\"in\",{\"1\":{\"31\":1,\"98\":1}}],[\"ir⋯\",{\"1\":{\"23\":1}}],[\"item\",{\"1\":{\"201\":2,\"202\":2}}],[\"it\",{\"1\":{\"17\":2}}],[\"isleft\",{\"1\":{\"155\":4}}],[\"isanagram\",{\"1\":{\"110\":1}}],[\"ishappy\",{\"1\":{\"67\":1}}],[\"is\",{\"1\":{\"2\":1}}],[\"||\",{\"1\":{\"51\":2,\"88\":1,\"103\":1,\"212\":1}}],[\"|\",{\"1\":{\"5\":2}}],[\"安装依赖\",{\"1\":{\"5\":1}}],[\"void\",{\"1\":{\"148\":4,\"152\":4,\"155\":4,\"199\":1,\"200\":1}}],[\"valid\",{\"1\":{\"105\":1}}],[\"value\",{\"1\":{\"96\":2,\"167\":1,\"168\":1}}],[\"val==val\",{\"1\":{\"77\":1}}],[\"val\",{\"1\":{\"47\":1,\"51\":2,\"55\":1,\"59\":7,\"71\":8,\"72\":1,\"74\":12,\"77\":9,\"81\":1,\"85\":7,\"99\":1,\"103\":7,\"114\":11,\"116\":1,\"118\":2,\"148\":9,\"152\":15,\"155\":13,\"197\":2,\"208\":1,\"212\":2}}],[\"vue\",{\"1\":{\"34\":2}}],[\"vuepress\",{\"0\":{\"18\":1},\"1\":{\"5\":2,\"14\":2,\"16\":2,\"17\":1,\"18\":2,\"19\":1,\"33\":1}}],[\"version\",{\"1\":{\"5\":1}}],[\"v4\",{\"1\":{\"5\":4}}],[\"j++\",{\"1\":{\"135\":1}}],[\"j\",{\"1\":{\"135\":7}}],[\"j代表列\",{\"1\":{\"135\":1}}],[\"java\",{\"1\":{\"43\":2,\"51\":2,\"59\":2,\"67\":2,\"74\":2,\"85\":2,\"96\":2,\"103\":2,\"110\":2,\"118\":2,\"127\":2,\"135\":2,\"142\":1,\"152\":2,\"163\":2,\"204\":1,\"212\":2}}],[\"jamesives\",{\"1\":{\"5\":1}}],[\"js\",{\"1\":{\"5\":1}}],[\"jobs\",{\"1\":{\"5\":1}}],[\"n2\",{\"1\":{\"135\":1,\"181\":1}}],[\"nagaram\",{\"1\":{\"106\":1}}],[\"name\",{\"1\":{\"5\":7}}],[\"n个正整数的数组和一个正整数\",{\"1\":{\"92\":1}}],[\"n+1\",{\"1\":{\"57\":1,\"58\":1}}],[\"nth\",{\"1\":{\"54\":1}}],[\"n−1\",{\"1\":{\"49\":1,\"161\":1}}],[\"next=pre\",{\"1\":{\"84\":1}}],[\"next=prev\",{\"1\":{\"77\":1}}],[\"next=head\",{\"1\":{\"77\":1}}],[\"next=cur\",{\"1\":{\"73\":1,\"84\":1}}],[\"next\",{\"1\":{\"47\":1,\"51\":9,\"59\":12,\"73\":2,\"74\":11,\"76\":1,\"77\":10,\"84\":2,\"85\":8,\"88\":5,\"101\":7,\"103\":17,\"148\":2,\"152\":21,\"155\":15,\"197\":1,\"199\":1,\"200\":1,\"201\":8,\"202\":2,\"212\":4}}],[\"newnode\",{\"1\":{\"152\":10,\"199\":4,\"200\":4}}],[\"new\",{\"1\":{\"43\":3,\"59\":1,\"103\":1,\"110\":1,\"127\":4,\"135\":1,\"148\":1,\"152\":5,\"155\":5,\"163\":1,\"199\":1,\"200\":1}}],[\"num<=tar\",{\"1\":{\"133\":1}}],[\"num\",{\"1\":{\"116\":1,\"118\":3}}],[\"number\",{\"1\":{\"62\":1}}],[\"nums2\",{\"1\":{\"122\":5,\"127\":2}}],[\"nums1\",{\"1\":{\"122\":5,\"127\":2}}],[\"numsr\",{\"1\":{\"92\":2}}],[\"numsl+1\",{\"1\":{\"92\":1}}],[\"numsl\",{\"1\":{\"92\":1}}],[\"nums\",{\"1\":{\"39\":8,\"43\":5,\"92\":5,\"96\":4,\"114\":20,\"116\":2,\"118\":3,\"138\":8,\"140\":3,\"142\":4,\"143\":7,\"144\":4,\"159\":6,\"163\":17,\"177\":9,\"178\":15,\"179\":9}}],[\"null\",{\"1\":{\"47\":2,\"49\":1,\"51\":7,\"59\":3,\"74\":3,\"85\":3,\"88\":3,\"103\":4,\"148\":5,\"152\":5,\"154\":1,\"155\":3,\"192\":1,\"199\":2,\"200\":2,\"201\":5,\"202\":4,\"208\":3,\"210\":1,\"211\":1,\"212\":6}}],[\"n\",{\"0\":{\"54\":1,\"186\":1},\"1\":{\"39\":1,\"43\":3,\"49\":2,\"51\":2,\"55\":5,\"57\":1,\"59\":7,\"63\":5,\"65\":4,\"67\":10,\"74\":2,\"77\":2,\"85\":2,\"88\":4,\"92\":3,\"96\":5,\"103\":2,\"110\":2,\"118\":2,\"127\":1,\"131\":7,\"133\":2,\"135\":8,\"138\":2,\"142\":1,\"152\":4,\"155\":3,\"159\":1,\"163\":2,\"167\":3,\"175\":1,\"181\":1,\"186\":3,\"203\":1,\"208\":4}}],[\"not\",{\"1\":{\"214\":1}}],[\"nojekyll\",{\"1\":{\"5\":1}}],[\"node<>\",{\"1\":{\"199\":1,\"200\":1}}],[\"node<e>\",{\"1\":{\"199\":2,\"200\":2,\"201\":3,\"202\":2}}],[\"nodes\",{\"1\":{\"98\":1}}],[\"node\",{\"1\":{\"5\":4,\"47\":1,\"54\":1,\"55\":1,\"71\":2,\"81\":1,\"99\":1,\"150\":1,\"152\":17,\"155\":34,\"197\":1,\"208\":1}}],[\"tail\",{\"1\":{\"153\":1,\"155\":9}}],[\"table\",{\"1\":{\"110\":4}}],[\"target\",{\"1\":{\"39\":6,\"41\":3,\"42\":1,\"43\":3,\"92\":5,\"96\":2,\"135\":2,\"138\":4,\"142\":3,\"143\":3,\"144\":3,\"177\":6,\"178\":14,\"179\":8}}],[\"t\",{\"1\":{\"106\":8,\"108\":3,\"110\":3}}],[\"top++\",{\"1\":{\"135\":1}}],[\"top==bottom\",{\"1\":{\"133\":1}}],[\"top\",{\"1\":{\"133\":1,\"135\":6}}],[\"totalsum\",{\"1\":{\"67\":3}}],[\"toc\",{\"1\":{\"11\":1}}],[\"twosum\",{\"1\":{\"43\":1}}],[\"two\",{\"1\":{\"38\":1,\"121\":1,\"207\":1}}],[\"title\",{\"1\":{\"31\":3}}],[\"the\",{\"1\":{\"31\":1}}],[\"this\",{\"1\":{\"2\":1,\"59\":3,\"74\":3,\"77\":3,\"85\":3,\"103\":3,\"152\":1}}],[\"tex\",{\"0\":{\"23\":1}}],[\"true\",{\"1\":{\"5\":1,\"51\":1,\"63\":2,\"67\":1,\"106\":1,\"110\":1,\"202\":2}}],[\"skipb\",{\"1\":{\"208\":6}}],[\"skipa\",{\"1\":{\"208\":6}}],[\"squares\",{\"1\":{\"158\":1}}],[\"spiral\",{\"1\":{\"130\":1}}],[\"space\",{\"1\":{\"5\":1}}],[\"sortedsquares\",{\"1\":{\"163\":1}}],[\"sorted\",{\"1\":{\"158\":1}}],[\"sort\",{\"1\":{\"114\":1}}],[\"solution\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"77\":1,\"85\":1,\"88\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"163\":1,\"212\":1}}],[\"s\",{\"1\":{\"106\":8,\"108\":3,\"110\":4}}],[\"swappairs\",{\"1\":{\"103\":1}}],[\"swap\",{\"1\":{\"98\":1}}],[\"string\",{\"1\":{\"110\":2}}],[\"start++\",{\"1\":{\"96\":1}}],[\"start\",{\"1\":{\"94\":2,\"95\":1,\"96\":5}}],[\"steps\",{\"1\":{\"5\":1}}],[\"search\",{\"1\":{\"137\":1,\"142\":1,\"143\":1,\"144\":1,\"179\":1}}],[\"secod\",{\"1\":{\"101\":1}}],[\"second=cur\",{\"1\":{\"101\":1}}],[\"second\",{\"1\":{\"57\":3,\"59\":6,\"101\":3,\"103\":4,\"212\":5}}],[\"setup\",{\"1\":{\"5\":2}}],[\"sz\",{\"1\":{\"55\":3,\"155\":2}}],[\"size++\",{\"1\":{\"152\":3,\"155\":3,\"199\":1,\"200\":1}}],[\"size\",{\"1\":{\"91\":1,\"127\":1,\"151\":1,\"152\":7,\"155\":4,\"201\":1}}],[\"size=8192\",{\"1\":{\"5\":1}}],[\"singly\",{\"1\":{\"51\":1,\"59\":1,\"74\":1,\"77\":1,\"85\":1,\"103\":1,\"212\":1}}],[\"slow将到达链表中的一半\",{\"1\":{\"67\":1}}],[\"slowrunner\",{\"1\":{\"67\":4}}],[\"slow在链表中前进\",{\"1\":{\"65\":1}}],[\"slow\",{\"1\":{\"49\":8,\"51\":12,\"65\":1,\"67\":1}}],[\"such\",{\"1\":{\"152\":1}}],[\"subarray\",{\"1\":{\"91\":1}}],[\"submodules\",{\"1\":{\"5\":1}}],[\"sum\",{\"1\":{\"38\":1,\"91\":1,\"94\":2,\"96\":4}}],[\"src\",{\"1\":{\"5\":2}}],[\"while\",{\"1\":{\"51\":2,\"59\":1,\"67\":2,\"74\":2,\"77\":1,\"85\":1,\"96\":2,\"103\":1,\"135\":1,\"142\":1,\"143\":1,\"144\":1,\"152\":1,\"163\":1,\"177\":3,\"178\":2,\"179\":1,\"212\":1}}],[\"will\",{\"1\":{\"31\":1,\"152\":1}}],[\"with\",{\"1\":{\"5\":3}}],[\"write\",{\"1\":{\"5\":1}}],[\"unlink\",{\"1\":{\"201\":1,\"202\":2}}],[\"unicode\",{\"1\":{\"106\":1}}],[\"uses\",{\"1\":{\"5\":4}}],[\"ubuntu\",{\"1\":{\"5\":1}}],[\"c=0\",{\"1\":{\"212\":1}}],[\"c\",{\"1\":{\"210\":5,\"212\":3}}],[\"c1\",{\"1\":{\"208\":1}}],[\"charat\",{\"1\":{\"110\":2}}],[\"checkout\",{\"1\":{\"5\":2}}],[\"cap\",{\"1\":{\"168\":1}}],[\"called\",{\"1\":{\"152\":1}}],[\"car\",{\"1\":{\"106\":1}}],[\"cache\",{\"1\":{\"5\":1}}],[\"cur=dummy\",{\"1\":{\"101\":1}}],[\"cur=next\",{\"1\":{\"84\":1}}],[\"curr\",{\"1\":{\"85\":7}}],[\"cur\",{\"1\":{\"73\":1,\"83\":1,\"84\":1,\"101\":3,\"103\":7,\"155\":18}}],[\"cycle\",{\"1\":{\"46\":1}}],[\"class\",{\"1\":{\"43\":1,\"51\":2,\"59\":2,\"67\":1,\"74\":2,\"77\":2,\"85\":2,\"88\":1,\"96\":1,\"103\":2,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":2,\"155\":2,\"163\":1,\"197\":1,\"212\":2}}],[\"condition\",{\"1\":{\"177\":1}}],[\"containskey\",{\"1\":{\"43\":1}}],[\"contents\",{\"1\":{\"5\":1}}],[\"count++\",{\"1\":{\"135\":4}}],[\"count\",{\"1\":{\"135\":2}}],[\"code\",{\"1\":{\"43\":1,\"51\":1,\"59\":1,\"67\":1,\"74\":1,\"85\":1,\"96\":1,\"103\":1,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"152\":1,\"163\":1,\"212\":1}}],[\"corepack\",{\"1\":{\"5\":1}}],[\"cn\",{\"1\":{\"5\":1,\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"199\":1,\"200\":1,\"201\":1,\"202\":1,\"207\":1}}],[\"m\",{\"1\":{\"186\":1,\"208\":3}}],[\"mylinkedlist\",{\"1\":{\"148\":13,\"152\":5,\"155\":2}}],[\"mid+\",{\"1\":{\"179\":1}}],[\"mid+1\",{\"1\":{\"177\":1}}],[\"mid−1\",{\"1\":{\"140\":1,\"177\":1}}],[\"mid\",{\"1\":{\"140\":6,\"142\":6,\"143\":8,\"144\":6,\"177\":12,\"178\":11,\"179\":10}}],[\"min\",{\"1\":{\"96\":1}}],[\"minsubarraylen\",{\"1\":{\"96\":1}}],[\"minimum\",{\"1\":{\"91\":1}}],[\"m+n\",{\"1\":{\"127\":3}}],[\"m为nums2数组长度\",{\"1\":{\"127\":1}}],[\"ms\",{\"1\":{\"32\":1}}],[\"more\",{\"1\":{\"30\":1}}],[\"md\",{\"1\":{\"19\":1}}],[\"matrix\",{\"1\":{\"130\":1,\"131\":1}}],[\"math\",{\"1\":{\"96\":1,\"163\":6}}],[\"map\",{\"1\":{\"43\":4}}],[\"map<integer\",{\"1\":{\"43\":1}}],[\"markdown\",{\"0\":{\"14\":1,\"15\":1,\"16\":1,\"17\":1},\"1\":{\"14\":2,\"15\":3,\"16\":1,\"17\":3,\"18\":2,\"19\":1,\"31\":3,\"32\":1,\"33\":2,\"34\":2},\"2\":{\"29\":1}}],[\"max\",{\"1\":{\"5\":1,\"96\":2}}],[\"master\",{\"1\":{\"5\":2}}],[\"me\",{\"1\":{\"2\":1}}],[\"param\",{\"1\":{\"152\":1}}],[\"pairs\",{\"1\":{\"98\":1}}],[\"pages\",{\"1\":{\"5\":4}}],[\"page\",{\"1\":{\"5\":1,\"31\":1}}],[\"pre=cur\",{\"1\":{\"84\":1}}],[\"pre\",{\"1\":{\"83\":1}}],[\"prevent\",{\"1\":{\"177\":1}}],[\"prev=prev\",{\"1\":{\"77\":1}}],[\"prev=dummynode\",{\"1\":{\"77\":1}}],[\"prev\",{\"1\":{\"74\":7,\"77\":3,\"85\":5,\"148\":1,\"155\":17,\"199\":1,\"201\":8}}],[\"problems\",{\"1\":{\"38\":1,\"46\":1,\"54\":1,\"62\":1,\"70\":1,\"80\":1,\"91\":1,\"98\":1,\"105\":1,\"113\":1,\"121\":1,\"130\":1,\"137\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"pos\",{\"1\":{\"47\":7}}],[\"put\",{\"1\":{\"43\":1}}],[\"public\",{\"1\":{\"33\":1,\"43\":1,\"51\":2,\"59\":2,\"67\":2,\"74\":2,\"77\":2,\"85\":2,\"88\":1,\"96\":1,\"103\":2,\"110\":1,\"118\":1,\"127\":1,\"135\":1,\"142\":1,\"143\":1,\"144\":1,\"152\":7,\"155\":6,\"163\":1,\"177\":1,\"179\":1,\"202\":1,\"212\":3}}],[\"push\",{\"1\":{\"5\":1}}],[\"plugin\",{\"1\":{\"19\":1}}],[\"pnpm\",{\"1\":{\"5\":5}}],[\"permissions\",{\"1\":{\"5\":1}}],[\"部署文档\",{\"1\":{\"5\":3}}],[\"部署到\",{\"1\":{\"5\":1}}],[\"部署到ssh\",{\"1\":{\"5\":1}}],[\"generatematrix\",{\"1\":{\"135\":1}}],[\"getintersectionnode\",{\"1\":{\"212\":1}}],[\"getnode\",{\"1\":{\"150\":1,\"152\":4,\"155\":4}}],[\"getnext\",{\"1\":{\"65\":2,\"67\":5}}],[\"get\",{\"1\":{\"43\":1,\"148\":6,\"152\":3,\"155\":2}}],[\"git\",{\"1\":{\"5\":1}}],[\"github\",{\"1\":{\"5\":2}}],[\"gh\",{\"1\":{\"5\":3}}],[\"1<\",{\"1\":{\"85\":1}}],[\"121\",{\"1\":{\"159\":1}}],[\"12\",{\"1\":{\"63\":2,\"138\":2}}],[\"19\",{\"0\":{\"53\":1,\"54\":1},\"1\":{\"63\":1,\"186\":1}}],[\"19th\",{\"1\":{\"26\":1}}],[\"142\",{\"0\":{\"45\":1,\"46\":1},\"1\":{\"189\":1}}],[\"105\",{\"1\":{\"92\":2}}],[\"109\",{\"1\":{\"92\":1}}],[\"1002\",{\"1\":{\"127\":3}}],[\"10000\",{\"1\":{\"138\":1}}],[\"1000\",{\"1\":{\"122\":2,\"148\":1}}],[\"100\",{\"1\":{\"55\":1,\"63\":1,\"99\":2,\"114\":2,\"159\":3}}],[\"10\",{\"1\":{\"39\":5,\"47\":3,\"67\":2,\"71\":1,\"106\":1,\"159\":4,\"208\":2}}],[\"11\",{\"1\":{\"39\":1,\"92\":1,\"159\":1}}],[\"15\",{\"1\":{\"5\":1,\"39\":1}}],[\"1\",{\"0\":{\"37\":1,\"38\":1,\"57\":1,\"116\":1,\"177\":1},\"1\":{\"5\":1,\"21\":1,\"24\":1,\"32\":2,\"34\":2,\"39\":6,\"47\":9,\"49\":2,\"51\":2,\"55\":10,\"59\":3,\"63\":7,\"65\":2,\"67\":3,\"71\":5,\"74\":1,\"77\":2,\"81\":5,\"85\":4,\"92\":16,\"96\":3,\"99\":5,\"103\":1,\"106\":2,\"110\":1,\"114\":4,\"116\":2,\"118\":1,\"122\":4,\"131\":6,\"135\":4,\"138\":7,\"142\":2,\"143\":2,\"144\":5,\"148\":13,\"152\":8,\"155\":8,\"159\":6,\"163\":2,\"167\":6,\"175\":1,\"177\":9,\"178\":7,\"179\":9,\"203\":1,\"208\":15,\"212\":1}}],[\"16\",{\"1\":{\"5\":1,\"159\":3}}],[\"17\",{\"1\":{\"5\":1}}],[\"dummy\",{\"1\":{\"103\":4}}],[\"dummynode=new\",{\"1\":{\"77\":1}}],[\"dummynode\",{\"1\":{\"76\":1,\"77\":2}}],[\"dummyhead\",{\"1\":{\"57\":1,\"59\":3}}],[\"d\",{\"1\":{\"67\":3}}],[\"deleteatindex\",{\"1\":{\"148\":4,\"152\":2,\"155\":1}}],[\"design\",{\"1\":{\"147\":1}}],[\"description\",{\"1\":{\"46\":1,\"54\":1,\"70\":1,\"98\":1,\"105\":1,\"147\":1,\"158\":1,\"207\":1}}],[\"detectcycle\",{\"1\":{\"51\":1}}],[\"definition\",{\"1\":{\"51\":1,\"59\":1,\"74\":1,\"77\":1,\"85\":1,\"103\":1,\"212\":1}}],[\"depth\",{\"1\":{\"5\":1}}],[\"deploy\",{\"1\":{\"5\":4}}],[\"dist\",{\"1\":{\"5\":2}}],[\"docs\",{\"1\":{\"5\":1}}],[\"doublew2w\",{\"1\":{\"5\":1}}],[\"域名解析\",{\"1\":{\"5\":1}}],[\"完善\",{\"1\":{\"5\":2}}],[\"介绍\",{\"0\":{\"2\":1,\"15\":1},\"1\":{\"15\":1,\"16\":1}}],[\"档案主页\",{\"0\":{\"1\":1},\"1\":{\"2\":1}}],[\"项目主页配置\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
