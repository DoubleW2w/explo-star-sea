const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":588,\"nextId\":588,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2#你到底有没有认真学\",\"3\":\"2#你的成熟方案呢\",\"4\":\"2#你不够擅长-还是你走偏了\",\"5\":\"2#总结\",\"6\":\"2@0\",\"7\":\"3\",\"8\":\"3#总览\",\"9\":\"3#创建型模式\",\"10\":\"3#结构型模式\",\"11\":\"3#行为模式\",\"12\":\"3@0\",\"13\":\"4\",\"14\":\"4#意图\",\"15\":\"4#真实世界\",\"16\":\"4#uml\",\"17\":\"4#实现\",\"18\":\"4@0\",\"19\":\"5\",\"20\":\"5#特征\",\"21\":\"5#适用场景\",\"22\":\"5#✨饿汉实例化\",\"23\":\"5#静态代码块实例化\",\"24\":\"5#懒汉实例化\",\"25\":\"5#线程安全-synchronized-关键字\",\"26\":\"5#✨双重锁\",\"27\":\"5#✨私有内部类\",\"28\":\"5#枚举类\",\"29\":\"5@0\",\"30\":\"6\",\"31\":\"6#意图\",\"32\":\"6#uml\",\"33\":\"6#实现\",\"34\":\"6@0\",\"35\":\"7\",\"36\":\"7#概念\",\"37\":\"7#uml\",\"38\":\"7#实现\",\"39\":\"7@0\",\"40\":\"8\",\"41\":\"8#意图\",\"42\":\"8#uml\",\"43\":\"8#实现\",\"44\":\"8@0\",\"45\":\"9\",\"46\":\"9#意图\",\"47\":\"9#uml\",\"48\":\"9#实现\",\"49\":\"9#jdk\",\"50\":\"9@0\",\"51\":\"10\",\"52\":\"10#概念\",\"53\":\"10#uml\",\"54\":\"10#实现\",\"55\":\"10@0\",\"56\":\"11\",\"57\":\"11#题目地址-1-两数之和-力扣-leetcode\",\"58\":\"11#题目描述\",\"59\":\"11#前置知识\",\"60\":\"11#思路\",\"61\":\"11#关键点\",\"62\":\"11#代码\",\"63\":\"11@0\",\"64\":\"11@1\",\"65\":\"12\",\"66\":\"12#题目地址-101-对称二叉树-力扣-leetcode\",\"67\":\"12#题目描述\",\"68\":\"12#思路-1-递归\",\"69\":\"12#关键点\",\"70\":\"12#代码\",\"71\":\"12#思路-2-迭代\",\"72\":\"12#代码-1\",\"73\":\"12@0\",\"74\":\"12@1\",\"75\":\"13\",\"76\":\"13#题目地址-104-二叉树的最大深度-力扣-leetcode\",\"77\":\"13#题目描述\",\"78\":\"13#前置知识\",\"79\":\"13#思路-1-dfs\",\"80\":\"13#关键点\",\"81\":\"13#代码\",\"82\":\"13#思路-2-bfs\",\"83\":\"13#代码-1\",\"84\":\"13@0\",\"85\":\"13@1\",\"86\":\"14\",\"87\":\"14#题目地址-1047-删除字符串中的所有相邻重复项-力扣-leetcode\",\"88\":\"14#题目描述\",\"89\":\"14#前置知识\",\"90\":\"14#思路-1-双端队列\",\"91\":\"14#关键点\",\"92\":\"14#代码\",\"93\":\"14#思路-2-数组\",\"94\":\"14#关键点-1\",\"95\":\"14#代码-1\",\"96\":\"14@0\",\"97\":\"14@1\",\"98\":\"15\",\"99\":\"15#题目地址-111-二叉树的最小深度-力扣-leetcode\",\"100\":\"15#题目描述\",\"101\":\"15#前置知识\",\"102\":\"15#思路\",\"103\":\"15#关键点\",\"104\":\"15#代码\",\"105\":\"15@0\",\"106\":\"15@1\",\"107\":\"16\",\"108\":\"16#题目地址-116-填充每个节点的下一个右侧节点指针-力扣-leetcode\",\"109\":\"16#题目描述\",\"110\":\"16#前置知识\",\"111\":\"16#思路\",\"112\":\"16#关键点\",\"113\":\"16#代码\",\"114\":\"16@0\",\"115\":\"16@1\",\"116\":\"17\",\"117\":\"17#题目地址-117-填充每个节点的下一个右侧节点指针-ii-力扣-leetcode\",\"118\":\"17#题目描述\",\"119\":\"17#思路-1-出队串联\",\"120\":\"17#关键点\",\"121\":\"17#代码\",\"122\":\"17#思路-2-模拟链表串联\",\"123\":\"17#代码-1\",\"124\":\"17@0\",\"125\":\"17@1\",\"126\":\"18\",\"127\":\"18#题目地址-142-环形链表-ii-力扣-leetcode\",\"128\":\"18#题目描述\",\"129\":\"18#前置知识\",\"130\":\"18#思路\",\"131\":\"18#关键点\",\"132\":\"18#代码\",\"133\":\"18@0\",\"134\":\"18@1\",\"135\":\"19\",\"136\":\"19#题目地址-15-三数之和-力扣-leetcode\",\"137\":\"19#题目描述\",\"138\":\"19#前置知识\",\"139\":\"19#思路-排序-双指针\",\"140\":\"19#关键点\",\"141\":\"19#代码\",\"142\":\"19@0\",\"143\":\"19@1\",\"144\":\"20\",\"145\":\"20#题目地址-151-反转字符串中的单词-力扣-leetcode\",\"146\":\"20#题目描述\",\"147\":\"20#前置知识\",\"148\":\"20#思路-1-字符串-api\",\"149\":\"20#代码\",\"150\":\"20#思路-2-倒序遍历-双指针\",\"151\":\"20#代码-1\",\"152\":\"20#思路3-手写字符串api\",\"153\":\"20#代码-2\",\"154\":\"20@0\",\"155\":\"20@1\",\"156\":\"21\",\"157\":\"21#题目地址-18-四数之和-力扣-leetcode\",\"158\":\"21#题目描述\",\"159\":\"21#前置知识\",\"160\":\"21#思路\",\"161\":\"21#关键点\",\"162\":\"21#代码\",\"163\":\"21@0\",\"164\":\"21@1\",\"165\":\"22\",\"166\":\"22#题目地址-19-删除链表的倒数第-n-个结点-力扣-leetcode\",\"167\":\"22#题目描述\",\"168\":\"22#前置知识\",\"169\":\"22#思路-1-双指针\",\"170\":\"22#关键点\",\"171\":\"22#代码\",\"172\":\"22@0\",\"173\":\"22@1\",\"174\":\"23\",\"175\":\"23#题目地址-199-二叉树的右视图-力扣-leetcode\",\"176\":\"23#题目描述\",\"177\":\"23#前置知识\",\"178\":\"23#思路1-层序遍历\",\"179\":\"23#关键点\",\"180\":\"23#代码\",\"181\":\"23#思路2-层序遍历——递归方式\",\"182\":\"23#代码-1\",\"183\":\"23@0\",\"184\":\"23@1\",\"185\":\"24\",\"186\":\"24#题目地址-20-有效的括号-力扣-leetcode\",\"187\":\"24#题目描述\",\"188\":\"24#前置知识\",\"189\":\"24#思路\",\"190\":\"24#关键点\",\"191\":\"24#代码\",\"192\":\"24@0\",\"193\":\"24@1\",\"194\":\"25\",\"195\":\"25#题目地址-202-快乐数-力扣-leetcode\",\"196\":\"25#题目描述\",\"197\":\"25#前置知识\",\"198\":\"25#思路\",\"199\":\"25#关键点\",\"200\":\"25#代码\",\"201\":\"25@0\",\"202\":\"25@1\",\"203\":\"26\",\"204\":\"26#题目地址-203-移除链表元素-力扣-leetcode\",\"205\":\"26#题目描述\",\"206\":\"26#思路1-直接删除\",\"207\":\"26#关键点\",\"208\":\"26#代码\",\"209\":\"26#思路2-虚拟头节点\",\"210\":\"26#关键点-1\",\"211\":\"26#代码-1\",\"212\":\"26@0\",\"213\":\"26@1\",\"214\":\"27\",\"215\":\"27#题目地址-206-反转链表-力扣-leetcode\",\"216\":\"27#题目描述\",\"217\":\"27#前置知识\",\"218\":\"27#思路1-双指针\",\"219\":\"27#关键点\",\"220\":\"27#代码\",\"221\":\"27#思路2-递归\",\"222\":\"27#关键点-1\",\"223\":\"27#代码-1\",\"224\":\"27@0\",\"225\":\"27@1\",\"226\":\"28\",\"227\":\"28#题目地址-209-长度最小的子数组-力扣-leetcode\",\"228\":\"28#题目描述\",\"229\":\"28#前置知识\",\"230\":\"28#思路1-滑动窗口\",\"231\":\"28#关键点\",\"232\":\"28#代码\",\"233\":\"28@0\",\"234\":\"29\",\"235\":\"29#题目地址-225-用队列实现栈-力扣-leetcode\",\"236\":\"29#题目描述\",\"237\":\"29#前置知识\",\"238\":\"29#思路\",\"239\":\"29#代码\",\"240\":\"29@0\",\"241\":\"29@1\",\"242\":\"30\",\"243\":\"30#题目地址-226-翻转二叉树-力扣-leetcode\",\"244\":\"30#题目描述\",\"245\":\"30#关键点\",\"246\":\"30#代码\",\"247\":\"30#思路-2-层序遍历\",\"248\":\"30#代码-1\",\"249\":\"30@0\",\"250\":\"30@1\",\"251\":\"31\",\"252\":\"31#题目地址-232-用栈实现队列-力扣-leetcode\",\"253\":\"31#题目描述\",\"254\":\"31#前置知识\",\"255\":\"31#思路\",\"256\":\"31#代码\",\"257\":\"31@0\",\"258\":\"31@1\",\"259\":\"32\",\"260\":\"32#题目地址-236-二叉树的最近公共祖先-力扣-leetcode\",\"261\":\"32#题目描述\",\"262\":\"32#关键点\",\"263\":\"32#代码\",\"264\":\"33\",\"265\":\"33#题目地址-24-两两交换链表中的节点-力扣-leetcode\",\"266\":\"33#题目描述\",\"267\":\"33#前置知识\",\"268\":\"33#思路1-虚拟头节点\",\"269\":\"33#关键点\",\"270\":\"33#代码\",\"271\":\"33@0\",\"272\":\"34\",\"273\":\"34#题目地址-242-有效的字母异位词-力扣-leetcode\",\"274\":\"34#题目描述\",\"275\":\"34#前置知识\",\"276\":\"34#思路-哈希表记录\",\"277\":\"34#关键点\",\"278\":\"34#代码\",\"279\":\"34@0\",\"280\":\"34@1\",\"281\":\"35\",\"282\":\"35#题目地址-27-移除元素-力扣-leetcode\",\"283\":\"35#题目描述\",\"284\":\"35#前置知识\",\"285\":\"35#思路-1\",\"286\":\"35#关键点\",\"287\":\"35#代码\",\"288\":\"35@0\",\"289\":\"35@1\",\"290\":\"36\",\"291\":\"36#题目地址-344-反转字符串-力扣-leetcode\",\"292\":\"36#题目描述\",\"293\":\"36#前置知识\",\"294\":\"36#思路\",\"295\":\"36#关键点\",\"296\":\"36#代码\",\"297\":\"36@0\",\"298\":\"36@1\",\"299\":\"37\",\"300\":\"37#题目地址-349-两个数组的交集-力扣-leetcode\",\"301\":\"37#题目描述\",\"302\":\"37#前置知识\",\"303\":\"37#公司\",\"304\":\"37#思路\",\"305\":\"37#关键点\",\"306\":\"37#代码\",\"307\":\"37@0\",\"308\":\"37@1\",\"309\":\"38\",\"310\":\"38#题目地址-383-赎金信-力扣-leetcode\",\"311\":\"38#题目描述\",\"312\":\"38#前置知识\",\"313\":\"38#思路\",\"314\":\"38#关键点\",\"315\":\"38#代码\",\"316\":\"38@0\",\"317\":\"38@1\",\"318\":\"39\",\"319\":\"39#题目地址-429-n-叉树的层序遍历-力扣-leetcode\",\"320\":\"39#题目描述\",\"321\":\"39#前置知识\",\"322\":\"39#思路-1-bfs\",\"323\":\"39#关键点\",\"324\":\"39#代码-1\",\"325\":\"39#思路-2-dfs\",\"326\":\"39#代码\",\"327\":\"39@0\",\"328\":\"39@1\",\"329\":\"40\",\"330\":\"40#题目地址-454-四数相加-ii-力扣-leetcode\",\"331\":\"40#题目描述\",\"332\":\"40#前置知识\",\"333\":\"40#思路\",\"334\":\"40#代码\",\"335\":\"40@0\",\"336\":\"40@1\",\"337\":\"41\",\"338\":\"41#题目地址-501-二叉搜索树中的众数-力扣-leetcode\",\"339\":\"41#题目描述\",\"340\":\"41#思路\",\"341\":\"41#关键点\",\"342\":\"41#代码\",\"343\":\"41@0\",\"344\":\"41@1\",\"345\":\"42\",\"346\":\"42#题目地址-515-在每个树行中找最大值-力扣-leetcode\",\"347\":\"42#题目描述\",\"348\":\"42#前置知识\",\"349\":\"42#思路-1-dfs\",\"350\":\"42#关键点\",\"351\":\"42#代码\",\"352\":\"42#思路-2-bfs\",\"353\":\"42#代码-1\",\"354\":\"42@0\",\"355\":\"42@1\",\"356\":\"43\",\"357\":\"43#题目地址-530-二叉搜索树的最小绝对差-力扣-leetcode\",\"358\":\"43#题目描述\",\"359\":\"43#思路-中序遍历\",\"360\":\"43#关键点\",\"361\":\"43#代码\",\"362\":\"43#迭代写法\",\"363\":\"43@0\",\"364\":\"43@1\",\"365\":\"44\",\"366\":\"44#题目地址-541-反转字符串-ii-力扣-leetcode\",\"367\":\"44#题目描述\",\"368\":\"44#前置知识\",\"369\":\"44#思路\",\"370\":\"44#关键点\",\"371\":\"44#代码\",\"372\":\"44@0\",\"373\":\"44@1\",\"374\":\"45\",\"375\":\"45#题目地址-59-螺旋矩阵-ii-力扣-leetcode\",\"376\":\"45#题目描述\",\"377\":\"45#前置知识\",\"378\":\"45#思路\",\"379\":\"45#关键点\",\"380\":\"45#代码\",\"381\":\"45@0\",\"382\":\"46\",\"383\":\"46#题目地址-617-合并二叉树-力扣-leetcode\",\"384\":\"46#题目描述\",\"385\":\"46#思路-前序遍历\",\"386\":\"46#代码\",\"387\":\"46#思路-迭代\",\"388\":\"46#代码-1\",\"389\":\"46@0\",\"390\":\"46@1\",\"391\":\"47\",\"392\":\"47#题目地址-700-二叉搜索树中的搜索-力扣-leetcode\",\"393\":\"47#题目描述\",\"394\":\"47#思路-中序遍历\",\"395\":\"47#关键点\",\"396\":\"47#代码\",\"397\":\"47@0\",\"398\":\"47@1\",\"399\":\"48\",\"400\":\"48#题目地址-704-二分查找-力扣-leetcode\",\"401\":\"48#题目描述\",\"402\":\"48#前置知识\",\"403\":\"48#思路\",\"404\":\"48#关键点\",\"405\":\"48#代码\",\"406\":\"48#思路改进\",\"407\":\"48#左闭右必区间\",\"408\":\"48@0\",\"409\":\"48@1\",\"410\":\"49\",\"411\":\"49#题目地址-707-设计链表-力扣-leetcode\",\"412\":\"49#题目描述\",\"413\":\"49#前置知识\",\"414\":\"49#思路-单链表实现\",\"415\":\"49#关键点\",\"416\":\"49#代码\",\"417\":\"49#思路-双链表实现\",\"418\":\"49#关键点-1\",\"419\":\"49#代码-1\",\"420\":\"49@0\",\"421\":\"49@1\",\"422\":\"50\",\"423\":\"50#题目地址-977-有序数组的平方-力扣-leetcode\",\"424\":\"50#题目描述\",\"425\":\"50#前置知识\",\"426\":\"50#思路\",\"427\":\"50#关键点\",\"428\":\"50#代码\",\"429\":\"50@0\",\"430\":\"50@1\",\"431\":\"51\",\"432\":\"51#题目地址-98-验证二叉搜索树-力扣-leetcode\",\"433\":\"51#题目描述\",\"434\":\"51#思路-中序遍历-双指针\",\"435\":\"51#关键点\",\"436\":\"51#代码1\",\"437\":\"51#代码2\",\"438\":\"51@0\",\"439\":\"51@1\",\"440\":\"52\",\"441\":\"52#我们的目标是刷穿leetcode\",\"442\":\"53\",\"443\":\"53#总览\",\"444\":\"53#冒泡排序\",\"445\":\"53#概念及演示\",\"446\":\"53#代码模板\",\"447\":\"53#选择排序\",\"448\":\"53#概念及演示-1\",\"449\":\"53#代码模板-1\",\"450\":\"53#插入排序\",\"451\":\"53#代码模板-2\",\"452\":\"53#✨希尔排序\",\"453\":\"53#✨归并排序\",\"454\":\"53#✨快速排序\",\"455\":\"53#✨堆排序\",\"456\":\"53#计数排序\",\"457\":\"53#桶排序\",\"458\":\"53#基数排序\",\"459\":\"53@1\",\"460\":\"54\",\"461\":\"54#哈希表是什么\",\"462\":\"54#哈希函数\",\"463\":\"54#哈希冲突\",\"464\":\"54#拉链法\",\"465\":\"54#线性探测法\",\"466\":\"54@0\",\"467\":\"54@1\",\"468\":\"55\",\"469\":\"55#是什么\",\"470\":\"55#解决什么问题\",\"471\":\"55#如何理解以及模板\",\"472\":\"55@0\",\"473\":\"55@1\",\"474\":\"56\",\"475\":\"56#数组\",\"476\":\"56#操作时间复杂度\",\"477\":\"56#源码分析\",\"478\":\"56#成员变量\",\"479\":\"56#构造函数\",\"480\":\"56#根据初始容量来创建\",\"481\":\"56#无参构造函数\",\"482\":\"56#根据集合的构造函数\",\"483\":\"56#总结\",\"484\":\"56#添加操作-第一次扩容\",\"485\":\"56#添加操作-第二次扩容\",\"486\":\"56#总结-1\",\"487\":\"56@0\",\"488\":\"56@1\",\"489\":\"57\",\"490\":\"57#了解-hashmap\",\"491\":\"57#hashcode-为什么使用-31-作为乘数\",\"492\":\"57#hashmap\",\"493\":\"57#扰动函数\",\"494\":\"57#初始化容量\",\"495\":\"57#负载因子\",\"496\":\"57#扩容\",\"497\":\"57@0\",\"498\":\"57@1\",\"499\":\"58\",\"500\":\"58#什么是数组\",\"501\":\"58#数组的特点\",\"502\":\"58#二分法\",\"503\":\"58#二分查找模板-1\",\"504\":\"58#二分查找模版-2-找满足条件的最左侧的值\",\"505\":\"58#二分查找模版-3-找满足条件的最右侧的值\",\"506\":\"58#双指针法\",\"507\":\"58#滑动窗口\",\"508\":\"58#模拟行为\",\"509\":\"58@0\",\"510\":\"59\",\"511\":\"59#理论\",\"512\":\"59#arraydeque\",\"513\":\"59#问题\",\"514\":\"59@0\",\"515\":\"59@1\",\"516\":\"60\",\"517\":\"60#概念\",\"518\":\"60#类型\",\"519\":\"60#满二叉树\",\"520\":\"60#完全二叉树\",\"521\":\"60#平衡二叉树\",\"522\":\"60#二叉搜索树\",\"523\":\"60#遍历\",\"524\":\"60#层序遍历\",\"525\":\"60#bfs遍历\",\"526\":\"60#bfs遍历的副产物-层序遍历-迭代写法\",\"527\":\"60#bfs遍历的副产物-层序遍历-递归写法\",\"528\":\"60#前、中、后序遍历\",\"529\":\"60#前序遍历\",\"530\":\"60#中序遍历\",\"531\":\"60#后序遍历\",\"532\":\"60#迭代遍历\",\"533\":\"60#前序遍历-1\",\"534\":\"60#中序遍历-1\",\"535\":\"60#后序遍历-1\",\"536\":\"60#迭代遍历统一法\",\"537\":\"60#前序遍历-2\",\"538\":\"60#表示\",\"539\":\"60#完美二叉树\",\"540\":\"60#任意二叉树\",\"541\":\"60#avl树\",\"542\":\"60#递归三要素\",\"543\":\"60#递归可视化\",\"544\":\"60#题目\",\"545\":\"60@0\",\"546\":\"60@1\",\"547\":\"61\",\"548\":\"61#虚拟头节点\",\"549\":\"61#快慢指针\",\"550\":\"61#删除倒数第-n-个节点\",\"551\":\"61#链表的基本操作\",\"552\":\"61#链表相交\",\"553\":\"61#环形链表\",\"554\":\"61@0\",\"555\":\"61@1\",\"556\":\"62\",\"557\":\"62#链表是什么\",\"558\":\"62#链表类型\",\"559\":\"62#单链表\",\"560\":\"62#双链表\",\"561\":\"62#循环链表\",\"562\":\"62#链表存储方式\",\"563\":\"62#链表操作\",\"564\":\"62#头插节点\",\"565\":\"62#尾插节点\",\"566\":\"62#拆链操作\",\"567\":\"62#删除节点\",\"568\":\"62#链表性能分析\",\"569\":\"62#问题\",\"570\":\"62@0\",\"571\":\"62@1\",\"572\":\"63\",\"573\":\"63#理论\",\"574\":\"63#题目\",\"575\":\"63@0\",\"576\":\"63@1\",\"577\":\"64\",\"578\":\"64#题目地址-面试题-02-07-链表相交-力扣-leetcode\",\"579\":\"64#题目描述\",\"580\":\"64#前置知识\",\"581\":\"64#思路\",\"582\":\"64#关键点\",\"583\":\"64#代码\",\"584\":\"64@0\",\"585\":\"64@1\",\"586\":\"65\",\"587\":\"66\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,88],\"1\":[1],\"2\":[2,52],\"3\":[2,45],\"4\":[3,37],\"5\":[1,20],\"6\":[null,null,1],\"7\":[1],\"8\":[1,7],\"9\":[1,12],\"10\":[1,7],\"11\":[1,7],\"12\":[null,null,1],\"13\":[1],\"14\":[1,14],\"15\":[1,44],\"16\":[1,13],\"17\":[1,47],\"18\":[null,null,1],\"19\":[1],\"20\":[1,11],\"21\":[1,4],\"22\":[1,14],\"23\":[1,16],\"24\":[1,19],\"25\":[3,18],\"26\":[1,22],\"27\":[1,20],\"28\":[1,10],\"29\":[null,null,1],\"30\":[1],\"31\":[1,18],\"32\":[1,13],\"33\":[1,43],\"34\":[null,null,1],\"35\":[1],\"36\":[1,26],\"37\":[1],\"38\":[1,15],\"39\":[null,null,1],\"40\":[1],\"41\":[1,23],\"42\":[1],\"43\":[1,32],\"44\":[null,null,1],\"45\":[1],\"46\":[1,22],\"47\":[1,9],\"48\":[1,35],\"49\":[1,3],\"50\":[null,null,1],\"51\":[1],\"52\":[1,8],\"53\":[1],\"54\":[1,15],\"55\":[null,null,1],\"56\":[2],\"57\":[6,7],\"58\":[1,45],\"59\":[1,1],\"60\":[1,21],\"61\":[1,7],\"62\":[1,37],\"63\":[null,null,1],\"64\":[null,null,1],\"65\":[2],\"66\":[6,8],\"67\":[1,25],\"68\":[3,18],\"69\":[1,13],\"70\":[1,43],\"71\":[3,13],\"72\":[1,46],\"73\":[null,null,1],\"74\":[null,null,1],\"75\":[2],\"76\":[6,11],\"77\":[1,29],\"78\":[1,4],\"79\":[3,23],\"80\":[1,8],\"81\":[1,38],\"82\":[3,11],\"83\":[1,41],\"84\":[null,null,1],\"85\":[null,null,1],\"86\":[2],\"87\":[6,12],\"88\":[1,35],\"89\":[1,3],\"90\":[3,13],\"91\":[1,1],\"92\":[1,47],\"93\":[3,16],\"94\":[1],\"95\":[1,45],\"96\":[null,null,1],\"97\":[null,null,1],\"98\":[2],\"99\":[6,11],\"100\":[1,30],\"101\":[1,3],\"102\":[1,9],\"103\":[1],\"104\":[1,47],\"105\":[null,null,1],\"106\":[null,null,2],\"107\":[2],\"108\":[6,13],\"109\":[1,59],\"110\":[1,2],\"111\":[1,22],\"112\":[1,6],\"113\":[1,42],\"114\":[null,null,1],\"115\":[null,null,1],\"116\":[3],\"117\":[7,13],\"118\":[1,57],\"119\":[3,6],\"120\":[1,16],\"121\":[1,53],\"122\":[3,4],\"123\":[1,55],\"124\":[null,null,1],\"125\":[null,null,2],\"126\":[3],\"127\":[7,10],\"128\":[1,57],\"129\":[1,2],\"130\":[1,49],\"131\":[1,3],\"132\":[1,52],\"133\":[null,null,1],\"134\":[null,null,1],\"135\":[2],\"136\":[6,7],\"137\":[1,38],\"138\":[1,1],\"139\":[2,58],\"140\":[1,7],\"141\":[1,82],\"142\":[null,null,1],\"143\":[null,null,2],\"144\":[2],\"145\":[6,11],\"146\":[1,55],\"147\":[1,2],\"148\":[4,5],\"149\":[1,36],\"150\":[3,10],\"151\":[1,47],\"152\":[2,6],\"153\":[1,64],\"154\":[null,null,1],\"155\":[null,null,1],\"156\":[2],\"157\":[6,7],\"158\":[1,35],\"159\":[1,2],\"160\":[1,13],\"161\":[1,4],\"162\":[1,68],\"163\":[null,null,1],\"164\":[null,null,2],\"165\":[2],\"166\":[8,13],\"167\":[1,27],\"168\":[1,2],\"169\":[3,17],\"170\":[1,5],\"171\":[1,51],\"172\":[null,null,1],\"173\":[null,null,1],\"174\":[2],\"175\":[6,11],\"176\":[1,23],\"177\":[1,3],\"178\":[2,4],\"179\":[1,2],\"180\":[1,51],\"181\":[3,4],\"182\":[1,48],\"183\":[null,null,1],\"184\":[null,null,3],\"185\":[2],\"186\":[6,8],\"187\":[1,23],\"188\":[1,2],\"189\":[1,13],\"190\":[1,2],\"191\":[1,44],\"192\":[null,null,1],\"193\":[null,null,2],\"194\":[2],\"195\":[6,7],\"196\":[1,41],\"197\":[1,1],\"198\":[1,25],\"199\":[1,4],\"200\":[1,75],\"201\":[null,null,1],\"202\":[null,null,1],\"203\":[2],\"204\":[6,10],\"205\":[1,32],\"206\":[2,6],\"207\":[1,4],\"208\":[1,39],\"209\":[2],\"210\":[1,6],\"211\":[1,40],\"212\":[null,null,1],\"213\":[null,null,1],\"214\":[2],\"215\":[6,8],\"216\":[1,24],\"217\":[1,3],\"218\":[2,8],\"219\":[1,8],\"220\":[1,40],\"221\":[2,6],\"222\":[1,3],\"223\":[1,25],\"224\":[null,null,1],\"225\":[null,null,1],\"226\":[2],\"227\":[6,9],\"228\":[1,39],\"229\":[1,3],\"230\":[2,15],\"231\":[1,5],\"232\":[1,50],\"233\":[null,null,1],\"234\":[2],\"235\":[6,10],\"236\":[1,67],\"237\":[1,2],\"238\":[1,6],\"239\":[1,51],\"240\":[null,null,1],\"241\":[null,null,2],\"242\":[2],\"243\":[6,9],\"244\":[1,45],\"245\":[1,7],\"246\":[1,51],\"247\":[3,16],\"248\":[1,51],\"249\":[null,null,1],\"250\":[null,null,1],\"251\":[2],\"252\":[6,10],\"253\":[1,78],\"254\":[1,1],\"255\":[1,14],\"256\":[1,58],\"257\":[null,null,1],\"258\":[null,null,1],\"259\":[2],\"260\":[6,13],\"261\":[1,128],\"262\":[1,5],\"263\":[1,48],\"264\":[2],\"265\":[6,10],\"266\":[1,23],\"267\":[1,1],\"268\":[2,19],\"269\":[1,2],\"270\":[1,46],\"271\":[null,null,1],\"272\":[2],\"273\":[6,8],\"274\":[1,37],\"275\":[1,1],\"276\":[2,16],\"277\":[1,2],\"278\":[1,44],\"279\":[null,null,1],\"280\":[null,null,1],\"281\":[2],\"282\":[6,7],\"283\":[1,76],\"284\":[1,1],\"285\":[2,25],\"286\":[1,1],\"287\":[1,27],\"288\":[null,null,1],\"289\":[null,null,1],\"290\":[2],\"291\":[6,7],\"292\":[1,35],\"293\":[1,2],\"294\":[1,14],\"295\":[1,6],\"296\":[1,34],\"297\":[null,null,1],\"298\":[null,null,1],\"299\":[2],\"300\":[6,9],\"301\":[1,30],\"302\":[1],\"303\":[1,1],\"304\":[1],\"305\":[1],\"306\":[1,48],\"307\":[null,null,1],\"308\":[null,null,2],\"309\":[2],\"310\":[6,8],\"311\":[1,33],\"312\":[1,1],\"313\":[1,21],\"314\":[1,7],\"315\":[1,44],\"316\":[null,null,1],\"317\":[null,null,1],\"318\":[3],\"319\":[7,12],\"320\":[1,38],\"321\":[1,5],\"322\":[3,13],\"323\":[1,8],\"324\":[3,49],\"325\":[3,8],\"326\":[1,47],\"327\":[null,null,1],\"328\":[null,null,3],\"329\":[3],\"330\":[7,8],\"331\":[1,33],\"332\":[1,1],\"333\":[1,21],\"334\":[1,47],\"335\":[null,null,1],\"336\":[null,null,2],\"337\":[2],\"338\":[6,12],\"339\":[1,42],\"340\":[1,43],\"341\":[1,1],\"342\":[1,67],\"343\":[null,null,1],\"344\":[null,null,1],\"345\":[2],\"346\":[6,13],\"347\":[1,23],\"348\":[1,3],\"349\":[3,9],\"350\":[1,2],\"351\":[1,50],\"352\":[3,9],\"353\":[1,52],\"354\":[null,null,1],\"355\":[null,null,3],\"356\":[2],\"357\":[6,11],\"358\":[1,41],\"359\":[2,29],\"360\":[1,1],\"361\":[1,49],\"362\":[1,39],\"363\":[null,null,1],\"364\":[null,null,1],\"365\":[3],\"366\":[7,9],\"367\":[1,34],\"368\":[1,2],\"369\":[1,20],\"370\":[1,10],\"371\":[1,56],\"372\":[null,null,1],\"373\":[null,null,2],\"374\":[3],\"375\":[7,8],\"376\":[1,26],\"377\":[1,2],\"378\":[1,32],\"379\":[1,2],\"380\":[1,67],\"381\":[null,null,1],\"382\":[2],\"383\":[6,10],\"384\":[1,39],\"385\":[2,31],\"386\":[1,44],\"387\":[2,19],\"388\":[1,47],\"389\":[null,null,1],\"390\":[null,null,1],\"391\":[2],\"392\":[6,12],\"393\":[1,32],\"394\":[2,29],\"395\":[1,4],\"396\":[1,39],\"397\":[null,null,1],\"398\":[null,null,1],\"399\":[2],\"400\":[6,7],\"401\":[1,38],\"402\":[1,1],\"403\":[1,45],\"404\":[1,2],\"405\":[1,34],\"406\":[1,35],\"407\":[1,23],\"408\":[null,null,1],\"409\":[null,null,2],\"410\":[2],\"411\":[6,9],\"412\":[1,75],\"413\":[1,2],\"414\":[2,7],\"415\":[1,4],\"416\":[1,73],\"417\":[2,14],\"418\":[1,17],\"419\":[1,55],\"420\":[null,null,1],\"421\":[null,null,1],\"422\":[2],\"423\":[6,11],\"424\":[1,42],\"425\":[1,1],\"426\":[1,7],\"427\":[1,6],\"428\":[1,50],\"429\":[null,null,1],\"430\":[null,null,2],\"431\":[2],\"432\":[6,10],\"433\":[1,38],\"434\":[2,33],\"435\":[1,2],\"436\":[1,48],\"437\":[1,37],\"438\":[null,null,1],\"439\":[null,null,1],\"440\":[1],\"441\":[1],\"442\":[1],\"443\":[1,41],\"444\":[1],\"445\":[1,19],\"446\":[1,42],\"447\":[1],\"448\":[1,13],\"449\":[1,29],\"450\":[1,27],\"451\":[1,32],\"452\":[1,34],\"453\":[1,48],\"454\":[1,42],\"455\":[1,42],\"456\":[1,40],\"457\":[1,64],\"458\":[1,71],\"459\":[null,null,1],\"460\":[1],\"461\":[1,17],\"462\":[1,16],\"463\":[1,6],\"464\":[1,2],\"465\":[1,4],\"466\":[null,null,1],\"467\":[null,null,1],\"468\":[1],\"469\":[1,12],\"470\":[1,19],\"471\":[1,26],\"472\":[null,null,1],\"473\":[null,null,1],\"474\":[2],\"475\":[1,21],\"476\":[1,11],\"477\":[1],\"478\":[1,37],\"479\":[1,13],\"480\":[1,27],\"481\":[1,15],\"482\":[1,37],\"483\":[1,5],\"484\":[3,82],\"485\":[3,62],\"486\":[1,75],\"487\":[null,null,1],\"488\":[null,null,2],\"489\":[2],\"490\":[2,23],\"491\":[5,105],\"492\":[1,5],\"493\":[1,33],\"494\":[1,36],\"495\":[1,19],\"496\":[1],\"497\":[null,null,1],\"498\":[null,null,2],\"499\":[1],\"500\":[2,6],\"501\":[1,10],\"502\":[1],\"503\":[2,61],\"504\":[3,72],\"505\":[3,42],\"506\":[1,7],\"507\":[1,12],\"508\":[1,6],\"509\":[null,null,1],\"510\":[1],\"511\":[1,25],\"512\":[1,9],\"513\":[1,9],\"514\":[null,null,1],\"515\":[null,null,1],\"516\":[1],\"517\":[1,67],\"518\":[1],\"519\":[1,18],\"520\":[1,11],\"521\":[1,11],\"522\":[1,17],\"523\":[1,19],\"524\":[1,16],\"525\":[1,33],\"526\":[3,78],\"527\":[3,43],\"528\":[3,18],\"529\":[1,29],\"530\":[1,26],\"531\":[1,45],\"532\":[1,14],\"533\":[1,45],\"534\":[1,30],\"535\":[1,37],\"536\":[1,14],\"537\":[1,48],\"538\":[1],\"539\":[1,12],\"540\":[1,17],\"541\":[1,13],\"542\":[1,11],\"543\":[1,55],\"544\":[1,24],\"545\":[null,null,1],\"546\":[null,null,1],\"547\":[1],\"548\":[1,5],\"549\":[1,2],\"550\":[3,12],\"551\":[1,10],\"552\":[1,4],\"553\":[1,9],\"554\":[null,null,1],\"555\":[null,null,1],\"556\":[1],\"557\":[2,7],\"558\":[1],\"559\":[1,2],\"560\":[1,4],\"561\":[1,4],\"562\":[1,20],\"563\":[1],\"564\":[1,38],\"565\":[1,22],\"566\":[1,21],\"567\":[1,24],\"568\":[1,7],\"569\":[1,12],\"570\":[null,null,1],\"571\":[null,null,1],\"572\":[1],\"573\":[1,13],\"574\":[1,162],\"575\":[null,null,1],\"576\":[null,null,1],\"577\":[3],\"578\":[8,12],\"579\":[1,76],\"580\":[1,3],\"581\":[1,38],\"582\":[1,7],\"583\":[1,57],\"584\":[null,null,1],\"585\":[null,null,1],\"586\":[1,3],\"587\":[1]},\"averageFieldLength\":[1.7334104328707212,25.009640715349022,0.6518618946365075],\"storedFields\":{\"0\":{\"h\":\"关于本站\",\"t\":[\"2024-06-17\",\"完善 deploy,yml，部署到SSH 域名解析 doublew2w.cn\",\"2024-06-16\",\"完善 deploy.yml 文件，部署到 github-page\",\"注意\",\"记得建立 gh-pages 分支\",\"name: 部署文档 on: push: branches: - master permissions: contents: write jobs: deploy-gh-pages: runs-on: ubuntu-latest environment: master steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 1 # 如果你文档需要 Git 子模块，取消注释下一行 # submodules: true - name: 设置 pnpm uses: pnpm/action-setup@v4 - name: 设置 Node.js uses: actions/setup-node@v4 with: node-version: 20 cache: \\\"pnpm\\\" - name: 安装依赖 run: | corepack enable pnpm install --frozen-lockfile - name: 构建文档 env: NODE_OPTIONS: --max_old_space_size=8192 run: |- pnpm run docs:build > src/.vuepress/dist/.nojekyll - name: 部署文档 uses: JamesIves/github-pages-deploy-action@v4 with: # 部署文档 branch: gh-pages folder: src/.vuepress/dist\",\"2024-06-15\",\"初始化项目并上传到github\"]},\"1\":{\"h\":\"底层逻辑与蝴蝶效应\"},\"2\":{\"h\":\"你到底有没有认真学？\",\"t\":[\"回想了一下自己大学的学习过程，很喜欢“钻研”东西。在这里它表示是贬义的，表现出来的是一种固执。\",\"为什么我说它是固执的。以我现在工作几年的经历，在回头看那时的自己，真心觉得那真是一个傻小子，不知变通。\",\"学习的时候，遇到问题，总是喜欢扎进去深究，但却偏离了最初学习的目的。举个简单的例子就是高数课程上，某个章节学习到了泰勒公式，但是在做题时，却跑到了推导泰勒公式的道上来。觉得自己能搞懂，瞎琢磨。但你说实在的话，琢磨也没问题，会让人学的更加透彻，可那个人他忘了得先完成作业啊，不然不还得扣你分嘛？\",\"思考了一下原因，从小到大，自己的升学历程很顺利，属于当时被家长、父母、老师夸夸神童的程度。学习成绩也都是属一属二的程度，就算自己瞎玩，也能考得比那些埋头苦读的人的成绩好。于是，一颗自以为是”高精尖儿“的种子就这么埋下了。\",\"来到大学以后，不管是学习还是做事，总喜欢往细处扣，自以为自己能把这原理、规律掌握，但这东西可是前人花了好大力气才得出来，怎么能靠单纯的思考就能的出来呢？于是就容易陷于死胡同，那为了让自己不要那么纠结，于是就变成了无脑乐观派。\",\"自以为自己是科研人才，但其实差了十万八千里的思维方式。😗\"]},\"3\":{\"h\":\"你的成熟方案呢？\",\"t\":[\"本人经历过两次考研，都失败了。心理上很受打击，当时归咎的原因无非就是做题做少了、哪天没睡好，身体不舒服之类，但唯独没归咎到自身的问题上。\",\"在今天来看，不管是工作还是学习，以结果导向的方式去做事带来的收益会大一些。\",\"之所以这么说，是因为就目前而来，不管是工作上还是学习上遇到的障碍，其实外面都充满着答案，铺天盖地都是成熟方案。也就是说某种情况对应某个答案，形成一种模板。却未曾去寻找那对应的模板，我这里说的不是粘贴复制，而是采取先“运行”后“优化”的行动策略。\",\"对于某个题型，就是直接用这种方式，别独自在脑子里面深究，你是不是也有过那种“明明看这个人木的很，为什么成绩比我好的那么多”，以往听到的解释是人家在你睡着的时候偷偷卷了。\",\"大多数情况并非如此，而是因为人家解决问题的方式跟钻研的方式是不一样的。前者是为了解决，为了得分，后者则是为了深挖，如果可以还想创新。\",\"工作上也是如此，一个从来没使用过的技术，突然让你使用它来完成甲方需求，你应该是找市面上存在的成熟方案，然后利用demo去修改。而不是从头到尾，把这门技术的祖宗十八代都挖出来。\"]},\"4\":{\"h\":\"你不够擅长？还是你走偏了？\",\"t\":[\"以前脑海中总有一个疑问\",\"我现在做事很痛苦，是因为我不足够擅长才痛苦，还是本身就不合适？\",\"直到现在，依然还有这个疑问。\",\"我能想到的一些解决方式是寻找正确的反馈。它与问题中的“痛苦”并不是一个东西，痛苦它只是一种感觉，它并非是你给予事物一定的作用力之后，所返给你的一些反作用力。\",\"准确来说，它更像一种客观存在，它并不以你的主观感受为主。懂或者不懂，而并非痛苦或者不痛苦，但我们容易把后者误当成前者。说的更简单一点，你可不可以用上一些工具就能把这个事情做好，而不是要钻研这个工具、这个事情的原理。\",\"有这么一个问题，那你打开一个游戏，你是会先玩，还是会先查攻略。 以前我特别希望有一片小天地，能写一写自己的所思所想。于是就可以研究起了博客。还没把博客搭建起来时，我就先跑去查看博客的美化功能了。当花费一番经历，阅读完博客网站美化以后，累了，脑子里面的那篇反思也就消失的无影无踪了。\"]},\"5\":{\"h\":\"总结\",\"t\":[\"认清自己就不是搞钻研这一块，莫要时时刻刻把所有事物的原理搞清楚\",\"任何时候都要去寻找反馈，通过反馈你才能时刻修正自己\",\"这个地球已经存在这么多年，你遇到的问题，很多人都遇到过。别自己瞎捣鼓，市面有很多解决方案，况且你自己瞎捣鼓的方案还不如外面的好用\",\"要时不时接受市场的检验，这样你才不会成为温水里的青蛙。\",\"复盘总结并不是流水账日记，也不是长篇大论。而是从具体的某件事中，你看到了什么，过去又发生了什么，而你又学到了什么，就够了。\"]},\"6\":{\"c\":[\"乱写一通\"]},\"7\":{\"h\":\"设计模式总览\"},\"8\":{\"h\":\"总览\",\"t\":[\"图片来自：https://refactoringguru.cn/design-patterns/catalog\"]},\"9\":{\"h\":\"创建型模式\",\"t\":[\"图片来自：https://refactoringguru.cn/design-patterns/creational-patterns\",\"简单工厂\",\"抽象工厂\",\"工厂方法\",\"单例模式\",\"生成器\"]},\"10\":{\"h\":\"结构型模式\",\"t\":[\"图片来自：https://refactoringguru.cn/design-patterns/structural-patterns\"]},\"11\":{\"h\":\"行为模式\",\"t\":[\"图片来自：https://refactoringguru.cn/design-patterns/behavioral-patterns\"]},\"12\":{\"c\":[\"设计模式\"]},\"13\":{\"h\":\"代理模式\"},\"14\":{\"h\":\"意图\",\"t\":[\"代理模式（Proxy）是指实现了一个类「代替」另外一个类的功能，它能控制对于原对象的访问。\",\" 图片来自：https://refactoringguru.cn/design-patterns/proxy \"]},\"15\":{\"h\":\"真实世界\",\"t\":[\"在《大话设计模式》中有这样一个故事，「A 男孩」喜欢 「C 女孩」，但是由于羞耻不敢于表达。于是 「A 男孩」就“拜托”与「C 女孩」同班的「B 男孩」帮助他。「A 男孩」买了很多礼物，委托「B 男孩」去送给「C 女孩」。由于每次都是「C 女孩」与「B 男孩」相处，而且「C 女孩」每次都从「B 男孩」手里接过礼物，最后两个人在一起了。\",\"追求者「A 男孩」\",\"被追求者「C 女孩」\",\"代理「B 男孩」\",\"所以他们三个人之间的关系是追求者「A 男孩」委托 代理「B 男孩」，通过代理给被追求者「C 女孩」送礼物。而被追求者「C 女孩」只与代理「B 男孩」进行接触。也就是说代理「B 男孩」代表了追求者「A 男孩」的 送礼物功能，被追求者「C 女孩」只与代理「B 男孩」接触就收到了礼物。\",\"信用卡是银行账户的代理，而银行账户则是一大捆现金的代理。它们都可以实现相同的支付功能。\",\"windows里的快捷方式。\"]},\"16\":{\"h\":\"UML\",\"t\":[\"ServiceInterface：定义了 Service 和 Proxy 的共用操作\",\"Service：实现了操作逻辑\",\"Proxy：保存了 Service 的一个引用可以使得代理可以访问 Service，并提供一个与 Service 的接口相同的接口，这样就可以代替 Service。\"]},\"17\":{\"h\":\"实现\",\"t\":[\"// 目标对象接口 interface Image { void display(); }\",\"// 目标对象实现 class RealImage implements Image { private String fileName; public RealImage(String fileName) { this.fileName = fileName; loadFromDisk(fileName); } private void loadFromDisk(String fileName) { System.out.println(\\\"Loading \\\" + fileName); } @Override public void display() { System.out.println(\\\"Displaying \\\" + fileName); } }\",\"// 代理类 class ProxyImage implements Image { private RealImage realImage; private String fileName; public ProxyImage(String fileName) { this.fileName = fileName; } // 延迟初始化 private void checkAndLoad() { if (realImage == null) { realImage = new RealImage(fileName); } } @Override public void display() { checkAndLoad(); realImage.display(); } }\",\"// 客户端代码 public class ProxyPatternDemo { public static void main(String[] args) { Image image = new ProxyImage(\\\"test_image.png\\\"); // 显示图片，此时代理对象会检查RealImage是否已经加载，如果没有则加载 image.display(); // 再次显示图片，RealImage已经被加载，代理对象直接调用其display方法 image.display(); } }\"]},\"18\":{\"c\":[\"设计模式\"]},\"19\":{\"h\":\"单例模式\"},\"20\":{\"h\":\"特征\",\"t\":[\"创建私有构造函数以避免使用 new 操作实例化对象\",\"声明一个类的「私有」、「静态」实例\",\"提供一个「公共静态方法」，该方法将返回单例类的实例变量。\"]},\"21\":{\"h\":\"适用场景\",\"t\":[\"当希望类只能有一个实例时。\",\"需要维护某种全局状态时。\",\"控制对共享资源的并发访问。\"]},\"22\":{\"h\":\"✨饿汉实例化\",\"t\":[\"public class EagerInitializedSingleton { private static final EagerInitializedSingleton instance = new EagerInitializedSingleton(); private EagerInitializedSingleton(){} public static EagerInitializedSingleton getInstance() { return instance; } }\",\"实例在类加载时创建。\",\"缺点是不使用该类时，也会创建实例对象\"]},\"23\":{\"h\":\"静态代码块实例化\",\"t\":[\"public class StaticBlockSingleton { private static StaticBlockSingleton instance; private StaticBlockSingleton(){} static { try { instance = new StaticBlockSingleton(); } catch (Exception e) { //... } } public static StaticBlockSingleton getInstance() { return instance; } }\",\"类的实例对象在 try..catch 语句块创建\"]},\"24\":{\"h\":\"懒汉实例化\",\"t\":[\"public class LazyInitializedSingleton { private static LazyInitializedSingleton instance; private LazyInitializedSingleton(){} public static LazyInitializedSingleton getInstance() { if (instance == null) { instance = new LazyInitializedSingleton(); } return instance; } }\",\"在需要的时候，在进行实例化\",\"缺点是：多个线程同时处于 if 语句时，容易出现实例化多个对象的情况\"]},\"25\":{\"h\":\"线程安全-synchronized 关键字\",\"t\":[\"public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton(){} public static synchronized ThreadSafeSingleton getInstance() { if (instance == null) { instance = new ThreadSafeSingleton(); } return instance; } }\",\"线程安全，每次只有一个线程进入 getInstance() 方法。\",\"同步方法会造成性能降低\"]},\"26\":{\"h\":\"✨双重锁\",\"t\":[\"package com.journaldev.singleton; public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton(){} public static ThreadSafeSingleton getInstanceUsingDoubleLocking() { if (instance == null) { synchronized (ThreadSafeSingleton.class) { if (instance == null) { instance = new ThreadSafeSingleton(); } } } return instance; } }\",\"双重检查锁： if 内部使用同步代码块，并增加额外一个检查。\"]},\"27\":{\"h\":\"✨私有内部类\",\"t\":[\"public class BillPughSingleton { private BillPughSingleton(){} private static class SingletonHelper { private static final BillPughSingleton INSTANCE = new BillPughSingleton(); } public static BillPughSingleton getInstance() { return SingletonHelper.INSTANCE; } }\",\"当 BillPughSingleton 加载时，私有静态内部类 SingletonHelper 不会被加载到内存中\",\"当调用 getInstance() 时，内部类才会被加载并且实例化单例类。\"]},\"28\":{\"h\":\"枚举类\",\"t\":[\"public enum EnumSingleton { INSTANCE; public static void doSomething() { // do something } }\"]},\"29\":{\"c\":[\"设计模式\"]},\"30\":{\"h\":\"原型模式\"},\"31\":{\"h\":\"意图\",\"t\":[\"假设有一个对象，你希望生成与其完全相同的一个对象。正常情况下：\",\"新建一个相同类型的对象\",\"遍历原对象的属性，并设置新对象的属性\",\"效率低，并且有时候原对象的某些属性是私有的。\",\"原型模式能够使你用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。\",\"通过复制一个已存在的实例，返回新的实例（没有新建实例），原型指被复制的实例\",\"实现克隆操作，必须实现 Cloneable接口。\"]},\"32\":{\"h\":\"UML\",\"t\":[\"原型模式将克隆过程委派给被克隆的实际对象。 模式为所有支持克隆的对象（即原型）声明了一个通用接口， 该接口让你能够克隆对象， 同时又无需将代码和对象所属类耦合。\",\"原型 （Prototype） ：声明克隆方法\",\"具体原型（Concrete Prototype）：实现克隆方法。\"]},\"33\":{\"h\":\"实现\",\"t\":[\"// 定义一个原型接口，所有可克隆的类都将实现这个接口 interface Prototype { Prototype clone(); // 克隆方法 }\",\"class Sheep implements Prototype, Cloneable { private String name; public Sheep(String name) { this.name = name; } // 重写clone方法 @Override public Prototype clone() { try { return (Sheep) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); return null; } } // Getter和Setter方法 }\",\"// 使用原型模式创建对象 public class PrototypePatternDemo { public static void main(String[] args) { Sheep sheep1 = new Sheep(\\\"Sheep1\\\"); Sheep sheep2 = sheep1.clone(); System.out.println(\\\"Sheep1: \\\" + sheep1); System.out.println(\\\"Sheep2: \\\" + sheep2); } }\"]},\"34\":{\"c\":[\"设计模式\"]},\"35\":{\"h\":\"工厂方法\"},\"36\":{\"h\":\"概念\",\"t\":[\"在父类中提供一个「创建对象」的方法，允许子类决定实例化对象的类型。\",\"简单理解就是将 new 操作放到工厂方法中。\",\"图片来自：https://refactoringguru.cn/design-patterns/factory-method\",\"创建者：声明一个工厂方法，并返回对应类型的产品对象\",\"产品：产品接口\",\"具体产品：产品接口的不同实现\",\"具体创建者：创建者的不同实现，重写工厂方法。\"]},\"37\":{\"h\":\"UML\"},\"38\":{\"h\":\"实现\",\"t\":[\"public interface Product {} public class ConcreteProduct1 implements Product{} public class ConcreteProduct2 implements Product{}\",\"public abstract IFactory { public abstract Product factoryMethod(); } public ConcreteFactory1 implements IFactory { public Product factoryMethod() { return new ConcreteProduct1(); } } public ConcreteFactory2 implements IFactory { public Product factoryMethod() { return new ConcreteProduct2(); } }\"]},\"39\":{\"c\":[\"工厂方法\"]},\"40\":{\"h\":\"抽象工厂\"},\"41\":{\"h\":\"意图\",\"t\":[\"抽象工厂也是一种工厂，跟简单工厂不同的是抽象工厂是创建一系列相关的对象，而无需指定具体的类。\",\"而简单工厂只是决定用什么子类来实例化出的一个对象。\",\"所谓的一系列相关的对象指的是你为了完成某个指令，需要用到A类型、B类型、C类型对象，但是为了保持风格的一致。对于A1、B1、C1是一种风格，而A1、B2、C1会导致风格会不一致。。\",\"图片来自：https://refactoringguru.cn/design-patterns/abstract-factory\"]},\"42\":{\"h\":\"UML\"},\"43\":{\"h\":\"实现\",\"t\":[\"public class ProductA { } public class ProductB { }\",\"public class ProductA1 extends ProductA { } public class ProductA2 extends ProductA { } public class ProductB1 extends ProductB { }\",\"public abstract class AbstractFactory { abstract ProductA createProductA(); abstract ProductB createProductB(); } public class ConcreteFactory1 extends AbstractFactory { ProductA createProductA(){ return new ProductA1(); } ProductB createProductB(){ return new ProductB1(); } } public class ConcreteFactory2 extends AbstractFactory { ProductA createProductA(){ return new ProductA2(); } ProductB createProductB(){ return null; } }\",\"public class Client { public static void main(String[] args) { AbstractFactory abstractFactory = new ConcreteFactory1(); ProductA productA = abstractFactory.createProductA(); ProductB productB = abstractFactory.createProductB(); // do something with productA and productB } }\"]},\"44\":{\"c\":[\"设计模式\"]},\"45\":{\"h\":\"生成器\"},\"46\":{\"h\":\"意图\",\"t\":[\"当你有一个复杂的对象需要创建时，生成器模式是让你能够逐步创建该复杂对象，从而生成不同形式的对象。\",\"就像我们要画一个人，要有头、身体、手、脚。不管是什么类型的人，我们都会使用这四个相同的步骤：「画头」、「画脚」、「画手」、「画脚」。而每个部分也跟其他部分有不一样的参数，所以才有使用同样的构建过程可以创建出不同的表示。\",\"图片来自：https://refactoringguru.cn/design-patterns/builder\"]},\"47\":{\"h\":\"UML\",\"t\":[\"生成器：声明通用的构建步骤\",\"具体生成器：提供构造过程的不同实现\",\"产品：最终生成的对象\",\"主管：定义调用构造步骤的顺序、可以创建和复用特定的产品配置\"]},\"48\":{\"h\":\"实现\",\"t\":[\"public abstract class PersonBuilder { public abstract void buildHead(); public abstract void buildBody(); public abstract void buildArm(); public abstract void buildLeg(); } public class PersonFatBuilder extends PersonBuilder { public void buildHead() { // 画一个胖头 } public void buildBody() { // 画一个胖身 } public void buildArm() { // 画一双胖手 } public void buildLeg() { // 画一双胖脚 } } public class PersonThinBuilder extends PersonBuilder { public void buildHead() { // 画一个瘦头 } public void buildBody() { // 画一个瘦身 } public void buildArm() { // 画一双瘦手 } public void buildLeg() { // 画一双瘦脚 } }\",\"public class PersonDirector { private PersonBuilder pb; public PersonDirector(PersonBuilder pb) { this.pb = pb; } public void createPerson() { pb.buildHead(); pb.buildBody(); pb.buildArm(); pb.buildLeg(); } }\",\"public class BuilderMain { public static void main(String[] args) { PersonDirector personDirector = new PersonDirector(new PersonThinBuilder()); personDirector.createPerson(); // 你也可以用实际的类来接收产品 } }\"]},\"49\":{\"h\":\"JDK\",\"t\":[\"java.lang.StringBuilder\"]},\"50\":{\"c\":[\"设计模式\"]},\"51\":{\"h\":\"简单工厂\"},\"52\":{\"h\":\"概念\",\"t\":[\"使用一个「单独的类」来实现具体的实例化过程，这个类就是一个「简单工厂类」，它可以决定应用什么子类来实例化。\",\"客户端不需要知道有哪些子类，或者实例化什么子类\"]},\"53\":{\"h\":\"UML\"},\"54\":{\"h\":\"实现\",\"t\":[\"public interface Product { } public class Product1 implements Product { } public class Product2 implements Product { } public class Product3 implements Product { }\",\"public class SimpleFactory { public Product createProduct(int type) { //.. 根据 type 返回对应的产品 } }\"]},\"55\":{\"c\":[\"设计模式\"]},\"56\":{\"h\":\"1-两数之和\"},\"57\":{\"h\":\"题目地址(1. 两数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/two-sum/\"]},\"58\":{\"h\":\"题目描述\",\"t\":[\" 给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\",\" 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\",\" 你可以按任意顺序返回答案。\",\" 示例 1：\",\" 输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释： 因为 nums [0] + nums [1] == 9 ，返回 [0, 1] 。 \",\" 示例 2：\",\" 输入： nums = [3,2,4], target = 6 输出： [1,2] \",\" 示例 3：\",\" 输入： nums = [3,3], target = 6 输出： [0,1] \",\" 提示：\",\" 2 <= nums.length <= 10 4 \",\"-10 9 <= nums [i] <= 10 9 \",\"-10 9 <= target <= 10 9 \",\" 只会存在一个有效答案 \",\" 进阶： 你可以想出一个时间复杂度小于 O(n 2 ) 的算法吗？\"]},\"59\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"60\":{\"h\":\"思路\",\"t\":[\"创建一个哈希表，对于每个 x，通过查询 target - x 是否存在于哈希表中\",\"不存在，则将 x 插入哈希表\",\"存在，x 的下标与 target-x 的下标就是答案\",\"如果有 3 个或者以上的重复元素，代表这个重复元素不可能是解\",\"如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于 target。\"]},\"61\":{\"h\":\"关键点\",\"t\":[\"每种输入只会对应一个答案\",\"哈希表存储的 key 是 x 和 target - x\"]},\"62\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; ++i) { int first = target - nums[i]; if (map.containsKey(first)) { int firstIndex = map.get(target - nums[i]); return new int[]{firstIndex, i}; } map.put(nums[i], i); } return new int[0]; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，哈希表存储元素的开销\"]},\"63\":{\"c\":[\"LeetCode\"]},\"64\":{\"c\":[\"哈希表\"]},\"65\":{\"h\":\"101-对称二叉树\"},\"66\":{\"h\":\"题目地址(101. 对称二叉树 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/symmetric-tree/description/\"]},\"67\":{\"h\":\"题目描述\",\"t\":[\" 给你一个二叉树的根节点 root ， 检查它是否轴对称。\",\" 示例 1：\",\" 输入： root = [1,2,2,3,4,4,3] 输出： true \",\" 示例 2：\",\" 输入： root = [1,2,2, null,3, null,3] 输出： false \",\" 提示：\",\" 树中节点数目在范围 [1, 1000] 内 \",\"-100 <= Node.val <= 100 \",\" 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？\"]},\"68\":{\"h\":\"思路 1：递归\",\"t\":[\"定义递归函数：\",\"参数与返回值：入参是左子节点与右子节点，返回值是对称标志\",\"单层递归逻辑： \",\"如果节点值不同，则为 false\",\"如果其中一个为空，则为 false\",\"如果都为空，则为 true\",\"判断两节点 left.left 和 right.right 是否对称\",\"判断两节点 left.right 和 right.left 是否对称\",\"终止条件：\"]},\"69\":{\"h\":\"关键点\",\"t\":[\"两个二叉树互为镜像的定义：\",\"两个二叉树的根节点的值相等\",\"每个二叉树的右子树与另一个树的左子树互为镜像\",\"如果以节点来说明：\",\"两对称节点值相同：left.val = right.val\",\"left 的左子节点与 right 的右子节点相同：left.left.val = right.right.val\",\"left 的右子节点与 right 的左子节点相同：left.right.val = right.left.val\"]},\"70\":{\"h\":\"代码\",\"t\":[\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { return root == null || recur(root.left, root.right); } public boolean recur(TreeNode left, TreeNode right){ if(left == null && right == null) return true; if(left == null || right == null || left.val != right.val) return false; return recur(left.left,right.right) && recur(left.right,right.left); } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每次判断一对节点是否对称，需要递归一次。\",\"空间复杂度：O(n)，最差情况，二叉树退化为链表，共有 2n-1 个\"]},\"71\":{\"h\":\"思路 2：迭代\",\"t\":[\"将递归逻辑写成迭代的形式。\",\"将这个二叉树看成是两个 u，v，使用队列存储遍历过程中的每一对节点\",\"对于根节点而已，入队两次，相当于处理这一对节点\",\"对于其他的一对节点 \",\"入队 u.left 和 v.right\",\"入队 u.right 和 v.left\"]},\"72\":{\"h\":\"代码\",\"t\":[\"class Solution { public boolean isSymmetric(TreeNode root) { return check(root, root); } public boolean check(TreeNode u, TreeNode v) { Queue<TreeNode> q = new LinkedList<TreeNode>(); q.offer(u); q.offer(v); while (!q.isEmpty()) { u = q.poll(); v = q.poll(); if (u == null && v == null) { continue; } if ((u == null || v == null) || (u.val != v.val)) { return false; } //1 q.offer(u.left); q.offer(v.right); //2 q.offer(u.right); q.offer(v.left); } return true; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每次判断一对节点是否对称，需要递归一次。\",\"空间复杂度：O(n)，使用一个队列维护节点，每个几点最多进队一次，队列中最多不会超过 n 个节点。\"]},\"73\":{\"c\":[\"LeetCode\"]},\"74\":{\"c\":[\"二叉树\"]},\"75\":{\"h\":\"104-二叉树的最大深度\"},\"76\":{\"h\":\"题目地址(104. 二叉树的最大深度 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/maximum-depth-of-binary-tree/submissions/\"]},\"77\":{\"h\":\"题目描述\",\"t\":[\" 给定一个二叉树 root ，返回其最大深度。\",\" 二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\",\" 示例 1：\",\" 输入： root = [3,9,20, null, null,15,7] 输出： 3 \",\" 示例 2：\",\" 输入： root = [1, null,2] 输出： 2 \",\" 提示：\",\" 树中节点的数量在 [0, 10 4 ] 区间内。\",\"-100 <= Node.val <= 100 \"]},\"78\":{\"h\":\"前置知识\",\"t\":[\"深度概念\",\"二叉树\",\"DFS、BFS\"]},\"79\":{\"h\":\"思路 1: DFS\",\"t\":[\"二叉树的最大深度 = Math.max(左子树的最大深度，右子树的最大深度) + 1\",\"递归三要素:\",\"终止条件： 当 root 为空时，说明不是叶节点，因此深度是 0\",\"单层递归逻辑：计算节点 root 的 左子树的深度 ，计算节点 root 的 右子树的深度\",\"返回值：：返回树的深度\"]},\"80\":{\"h\":\"关键点\",\"t\":[\"二叉树的最大深度 = Math.max(左子树的最大深度，右子树的最大深度) + 1\"]},\"81\":{\"h\":\"代码\",\"t\":[\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; // 单层递归逻辑：求树的大深度 // 树的最大深度 = max(左子树的最大深度 ，右子树的最大深度) + 1 return Math.max(maxDepth(root.left),maxDepth(root.right))+1; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，计算树的深度需要遍历所有节点。\",\"空间复杂度：O(n)，最差情况下（当树退化为链表时），递归深度可达到 N 。\"]},\"82\":{\"h\":\"思路 2：BFS\",\"t\":[\"树的层序遍历 / 广度优先搜索往往利用 队列 实现。\",\"关键点： 每遍历一层，则计数器 +1 ，直到遍历完成，则可得到树的深度。\"]},\"83\":{\"h\":\"代码\",\"t\":[\"class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; List<TreeNode> queue = new LinkedList<>() {{ add(root); }}, tmp; int res = 0; while (!queue.isEmpty()) { tmp = new LinkedList<>(); for(TreeNode node : queue) { if (node.left != null) tmp.add(node.left); if (node.right != null) tmp.add(node.right); } queue = tmp; res++; } return res; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，计算树的深度需要遍历所有节点。\",\"空间复杂度：O(n)，最差情况下, 队列 queue 同时存储 N/2 个节点\"]},\"84\":{\"c\":[\"LeetCode\"]},\"85\":{\"c\":[\"二叉树\"]},\"86\":{\"h\":\"1047-删除字符串中的所有相邻重复项\"},\"87\":{\"h\":\"题目地址(1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/\"]},\"88\":{\"h\":\"题目描述\",\"t\":[\" 给出由小写字母组成的字符串 S ， 重复项删除操作 会选择两个相邻且相同的字母，并删除它们。\",\" 在 S 上反复执行重复项删除操作，直到无法继续删除。\",\" 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\",\" 示例：\",\" 输入： \\\"abbaca\\\" 输出： \\\"ca\\\" 解释： 例如，在 \\\"abbaca\\\" 中，我们可以删除 \\\"bb\\\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \\\"aaca\\\"，其中又只有 \\\"aa\\\" 可以执行重复项删除操作，所以最后的字符串为 \\\"ca\\\"。 \",\" 提示：\",\" 1 <= S.length <= 20000 \",\" S 仅由小写英文字母组成。\"]},\"89\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"栈\",\"数组\"]},\"90\":{\"h\":\"思路 1：双端队列\",\"t\":[\"当字符串中同时有多组相邻重复项时，我们无论是先删除哪一个，都不会影响最终的结果。\",\"遍历字符串，使用一个集合（数字或者队列）存储遍历的情况。\",\"当前字符与队列尾部相同时，说明此时是重复项已经出现，此时将队列尾部元素删除\",\"当前字符与队列尾部不同时，说明不是重复项，放进队列中\"]},\"91\":{\"h\":\"关键点\",\"t\":[\"利用栈的思想来判断匹配情况\"]},\"92\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public String removeDuplicates(String s) { if (s == null || s.length() == 0) { return s; } Deque<Character> queue = new ArrayDeque<>(); for (char c : s.toCharArray()) { if (queue.isEmpty() || c != queue.peekLast()) { queue.offer(c); } else { queue.pollLast(); } } StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) { sb.append(queue.poll()); } return sb.toString(); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，我们只需要遍历该字符串一次。\",\"空间复杂度：O(n)，需要创建一个队列来存储情况，最坏的情况是字符串中不存在相邻重复项。\"]},\"93\":{\"h\":\"思路 2：数组\",\"t\":[\"把数组当成一个队列使用，使用两个指针来判断遍历情况\",\"hh <= tt 时说明，字符串不为空。\",\"如果数组尾元素 d[tt] == c ，说明 当前是相邻重复项，修改 tt 指向上一个元素\",\"否则就将元素放进数组\"]},\"94\":{\"h\":\"关键点\"},\"95\":{\"h\":\"代码\",\"t\":[\"class Solution { public String removeDuplicates(String s) { if (s == null || s.length() == 0) { return s; } char[] d = new char[s.length()]; // 双指针，tt 指向最后的数组末尾指针 int hh = 0, tt = -1; for (char c : s.toCharArray()) { if (hh <= tt && d[tt] == c) { tt--; } else { // 数组为空时，添加元素 // 当前字符与末尾元素不相同时，添加元素 d[++tt] = c; } } return new String(d, 0, tt + 1); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，我们只需要遍历该字符串一次。\",\"空间复杂度：O(n)，需要创建一个长度为 n 的数组来存储情况，最坏的情况是字符串中不存在相邻重复项。\"]},\"96\":{\"c\":[\"LeetCode\"]},\"97\":{\"c\":[\"字符串\"]},\"98\":{\"h\":\"111-二叉树的最小深度\"},\"99\":{\"h\":\"题目地址(111. 二叉树的最小深度 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/\"]},\"100\":{\"h\":\"题目描述\",\"t\":[\"给定一个二叉树，找出其最小深度。\",\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\",\"说明：叶子节点是指没有子节点的节点。\",\"示例 1：\",\"输入：root = [3,9,20,null,null,15,7] 输出：2 \",\"示例 2：\",\"输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 \",\"提示：\",\"树中节点数的范围在 [0, 105] 内\",\"-1000 <= Node.val <= 1000\"]},\"101\":{\"h\":\"前置知识\",\"t\":[\"二叉树\",\"DFS\",\"叶子节点\"]},\"102\":{\"h\":\"思路\",\"t\":[\"叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点\",\"只有根节点时，深度为1\",\"当根节点左右孩子有一个为空时，返回不为空的孩子节点的深度\",\"当根节点左右孩子都不为空时，返回左右孩子较小深度的节点值\"]},\"103\":{\"h\":\"关键点\"},\"104\":{\"h\":\"代码\",\"t\":[\"class Solution { public int minDepth(TreeNode root) { // 如果树是空，那么最小深度就是0 if(root == null) return 0; // 如果只有根节点,那么最小深度就是1 if(root.left == null && root.right == null) return 1; // 如果左子树为空，那么求右子树的最小深度 int ans = Integer.MAX_VALUE; if(root.left != null) { ans = Math.min(minDepth(root.left), ans); } if(root.right != null) { ans = Math.min(minDepth(root.right), ans); } return ans + 1; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n),每个节点都会遍历一次\",\"空间复杂度：O(h)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。\"]},\"105\":{\"c\":[\"LeetCode\"]},\"106\":{\"c\":[\"二叉树\",\"DFS\"]},\"107\":{\"h\":\"116-填充每个节点的下一个右侧节点指针\"},\"108\":{\"h\":\"题目地址(116. 填充每个节点的下一个右侧节点指针 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/\"]},\"109\":{\"h\":\"题目描述\",\"t\":[\" 给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\",\" struct Node { int val; Node *left; Node *right; Node *next; }\",\" 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。\",\" 初始状态下，所有 next 指针都被设置为 NULL 。\",\" 示例 1：\",\" 输入： root = [1,2,3,4,5,6,7] 输出： [1,#,2,3,#,4,5,6,7,#] 解释： 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。 \",\" 示例 2: \",\" 输入： root = [] 输出： [] \",\" 提示：\",\" 树中节点的数量在 [0, 2 12 - 1] 范围内 \",\"-1000 <= node.val <= 1000 \",\" 进阶：\",\" 你只能使用常量级额外空间。\",\" 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\"]},\"110\":{\"h\":\"前置知识\",\"t\":[\"二叉树\",\"BFS\"]},\"111\":{\"h\":\"思路\",\"t\":[\"next 指针只有两种类型：\",\"同一个父节点的两个子节点\",\"node.left.next = node.right\",\"不同父节点的子节点。将这一层的上一层串联好，就可以通过父节点的 next 找到邻居，完成处理。即第 N 层节点之间建立 next 指针后，再建立第 N+1 层节点的 next 指针。\",\"root.right.next => root.next.left\"]},\"112\":{\"h\":\"关键点\",\"t\":[\"把每一层当成一个链表进行遍历。\",\"root.right.next => root.next.left\"]},\"113\":{\"h\":\"代码\",\"t\":[\"/* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if(root == null) return root; // 从根节点开始 Node pre = root; while(pre.left!=null) { // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针 Node temp = pre; while(temp != null){ // 同一个父节点下的串联 temp.left.next = temp.right; // 如果上一层已经完成串联 if(temp.next!=null) { temp.right.next = temp.next.left; } //继续右边遍历 temp = temp.next; } //从下一层的最左边开始遍历 pre = pre.left; } return root; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点只访问一次\",\"空间复杂度：O(1)，不需要存储额外的节点\"]},\"114\":{\"c\":[\"LeetCode\"]},\"115\":{\"c\":[\"二叉树\"]},\"116\":{\"h\":\"117-填充每个节点的下一个右侧节点指针 II\"},\"117\":{\"h\":\"题目地址(117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/\"]},\"118\":{\"h\":\"题目描述\",\"t\":[\" 给定一个二叉树：\",\" struct Node { int val; Node *left; Node *right; Node *next; }\",\" 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。\",\" 初始状态下，所有 next 指针都被设置为 NULL 。\",\" 示例 1：\",\" 输入 ：root = [1,2,3,4,5, null,7] 输出： [1,#,2,3,#,4,5,7,#] 解释： 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），'#' 表示每层的末尾。\",\" 示例 2：\",\" 输入： root = [] 输出： [] \",\" 提示：\",\" 树中的节点数在范围 [0, 6000] 内 \",\"-100 <= Node.val <= 100 \",\" 进阶：\",\" 你只能使用常量级额外空间。\",\" 使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。\",\" ## 前置知识 \",\"二叉树\",\"层序遍历\"]},\"119\":{\"h\":\"思路 1：出队串联\",\"t\":[\"按照层序遍历的方式，创建一个队列存放每一层的节点，将每一层想象成一条链表。当遍历到一层时，从左到右出队将其串联起来。\"]},\"120\":{\"h\":\"关键点\",\"t\":[\"//出队 Node node = queue.poll(); //如果 pre 为空就表示 node 节点是这一行的第一个， //没有前一个节点指向他，否则就让前一个节点指向他 if (pre != null) { pre.next = node; }\"]},\"121\":{\"h\":\"代码\",\"t\":[\" /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if (root == null) return root; Deque<Node> queue = new ArrayDeque<>(); queue.addLast(root); while (!queue.isEmpty()) { int levelSize = queue.size(); Node pre = null; for (int i = 0; i < levelSize; i++) { // 出队 Node node = queue.pollFirst(); // //如果 pre 为空就表示 node 节点是这一行的第一个， if (pre != null) { pre.next = node; } // 然后再让当前节点成为前一个节点 pre = node; // 左右子节点如果不为空就入队 if (node.left != null) { queue.add(node.left); } if (node.right != null) { queue.add(node.right); } } } return root; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点最多出队和入队一次。\",\"空间复杂度：O(n)，队列存放节点所需要的空间不超过 n 个节点\"]},\"122\":{\"h\":\"思路 2：模拟链表串联\",\"t\":[\"将队列去掉，引入一个「虚拟头节点」\"]},\"123\":{\"h\":\"代码\",\"t\":[\"cur 是某一行的节点，dummy 和 pre 是下一行的头\",\"当对 cur 进行遍历时，使用 pre 去串联\",\"当 cur 遍历完，cur 更新为 dummy.next，也就是下一行的头，这样就完成向下一行的变化。\",\"class Solution { public Node connect(Node root) { // 将每一行看成一个链表进行处理 if(root == null) return root; //cur 我们可以把它看做是每一层的链表 Node cur = root; while(cur != null){ // 虚拟头节点 Node dummy = new Node(-1); //pre 表示访下一层节点的前一个节点 Node pre = dummy; while (cur != null) { if (cur.left != null) { // 如果当前层的左子节点不为空，就下一层的虚拟头节点指向它 pre.next = cur.left; // 然后再更新下一层的指针 pre = pre.next; } //同理参照左子树 if (cur.right != null) { pre.next = cur.right; pre = pre.next; } //继续访问这一行的下一个节点 cur = cur.next; } //把下一层串联成一个链表之后，让他赋值给 cur， //后续继续循环，直到 cur 为空为止 cur = dummy.next; } return root; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点最多出队和入队一次。\",\"空间复杂度：O(1)，没有额外的空间\"]},\"124\":{\"c\":[\"LeetCode\"]},\"125\":{\"c\":[\"二叉树\",\"BFS\"]},\"126\":{\"h\":\"142-环形链表 ii\"},\"127\":{\"h\":\"题目地址(142. 环形链表 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/linked-list-cycle-ii/description/\"]},\"128\":{\"h\":\"题目描述\",\"t\":[\" 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 。\",\" 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（ 索引从 0 开始 ）。如果 pos 是 -1 ，则在该链表中没有环。 注意： pos 不作为参数进行传递 ，仅仅是为了标识链表的实际情况。\",\" 不允许修改 链表。\",\" 示例 1：\",\" 输入： head = [3,2,0,-4], pos = 1 输出： 返回索引为 1 的链表节点 解释： 链表中有一个环，其尾部连接到第二个节点。 \",\" 示例 2：\",\" 输入： head = [1,2], pos = 0 输出： 返回索引为 0 的链表节点 解释： 链表中有一个环，其尾部连接到第一个节点。 \",\" 示例 3：\",\" 输入： head = [1], pos = -1 输出： 返回 null 解释： 链表中没有环。 \",\" 提示：\",\" 链表中节点的数目范围在范围 [0, 10 4 ] 内 \",\"-10 5 <= Node.val <= 10 5 \",\" pos 的值为 -1 或者链表中的一个有效索引 \",\" 进阶： 你是否可以使用 O(1) 空间解决此题？\"]},\"129\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"环形证明\"]},\"130\":{\"h\":\"思路\",\"t\":[\"使用双指针，分别定义为 fast 和 slow。从头节点出发，fast 每次走两步，slow 每次走 1 步。\",\"如果存在环，由于 fast 的步速大于 slow，最终 fast 和 slow 一定会在环中相遇\",\"如果不存在环，fast 会先于 slow 走到 null\",\"从头节点到环形入口节点的节点数为 x，环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 y。从相遇节点 再到环形入口节点节点数为 z。\",\"相遇时，slow 走过的节点数为 x+y，fast 走过的节点数为 x+y+n(y+z)，其中 n 为走过的环的圈数。\",\"fast 每次走两步，slow 每次走一步。\",\"x+y+n(y+z) = 2*(x+y) => x = (n-1)(y+z)+z\",\"从「相遇点到入环点的距离」加上「 n−1 圈的环长度」，恰好等于「从链表头部到入环点的距离」。\"]},\"131\":{\"h\":\"关键点\",\"t\":[\"判断链表是否环\",\"如果有环，如何找到这个环的入口\"]},\"132\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { if(head == null || head.next == null){ return null; } // 采用双指针的方式 ListNode fast = head,slow = head; // 第一次相遇, fast 走了 2n 个环， slow 走了 n 个环 while(true){ if(fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if(fast == slow) break; } // 让 fast 和 slow 一起同时 1，在次相遇就是环入口 fast = head; while(fast != slow){ fast = fast.next; slow = slow.next; } return slow; } }\",\"复杂度分析\",\"时间复杂度：O(n)：第一次相遇时，slow 要走 x+y 步，第二次相遇，slow 要走 z 步，总体是线性复杂度\",\"空间复杂度：O(1)：双指针使用常数大小的额外空间\"]},\"133\":{\"c\":[\"LeetCode\"]},\"134\":{\"c\":[\"链表\"]},\"135\":{\"h\":\"15-三数之和\"},\"136\":{\"h\":\"题目地址(15. 三数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/3sum/description/\"]},\"137\":{\"h\":\"题目描述\",\"t\":[\" 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums [j], nums [k]] 满足 i != j 、 i != k 且 j != k ，同时还满足 nums [i] + nums [j] + nums [k] == 0 。请 \",\" 你返回所有和为 0 且不重复的三元组。\",\" 注意： 答案中不可以包含重复的三元组。\",\" 示例 1：\",\" 输入： nums = [-1,0,1,2,-1,-4] 输出： [[-1,-1,2], [-1,0,1]] 解释： nums [0] + nums [1] + nums [2] = (-1) + 0 + 1 = 0 。 nums [1] + nums [2] + nums [4] = 0 + 1 + (-1) = 0 。 nums [0] + nums [3] + nums [4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 \",\" 示例 2：\",\" 输入： nums = [0,1,1] 输出： [] 解释： 唯一可能的三元组和不为 0 。 \",\" 示例 3：\",\" 输入： nums = [0,0,0] 输出： [[0,0,0]] 解释： 唯一可能的三元组和为 0 。 \",\" 提示：\",\" 3 <= nums.length <= 3000 \",\"-10 5 <= nums [i] <= 10 5 \"]},\"138\":{\"h\":\"前置知识\",\"t\":[\"双指针\"]},\"139\":{\"h\":\"思路：排序+双指针\",\"t\":[\"如果使用「暴力枚举」的方式，时间复杂度为 O(n3), 最后还要通过哈希表进行去重。\",\"为了「不重复」，我们先要排序。这样就能保证我们每一层循环都可以过滤掉相同的元素，而且能快速做出剪枝\",\"排序的时间复杂度为 O(nlogn)\",\"在固定两个元素的情况下，第三个元素会导致和为 <0>0=0。而两个元素的交替移动也能达到这个效果。\",\"定义三个指针 k, i, j，其中 k 指向最左的元素，双指针 i, j 分别在数组索引（k, length(nums)）处, 双指针 i , j 交替向中间移动，记录对于每个固定指针 k 的所有满足 nums [k] + nums [i] + nums [j] == 0 的 i, j 组合：\",\"如果 nums[k] > 0 ，而 nums[k] 又是最小，所以和肯定 > 0，终止循环\",\"如果 nums[k] == nums[k-1] 有可能是重复答案，处理一次即可\",\"双指针 i, j 变动情况： \",\"如果和 < 0, 说明 i 需要往 右边 移动，移动的时候要注意处理相同元素情况\",\"如果和 > 0, 说明 j 需要往 左边 移动，移动的时候要注意处理相同元素情况\",\"如果和 = 0, i 和 j 同时往中间移动的时候处理相同元素的情况\"]},\"140\":{\"h\":\"关键点\",\"t\":[\"为了 “不可以包含重复的三元组”，通过排序容易找到相同的三元组答案。\",\"为了更有效的找到有效解，双指针「交替向中间移动」\"]},\"141\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public List<List<Integer>> threeSum(int[] nums) { // 三重循环枚举，不重复则需要 // 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； // 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素； // 因此需要先排序。 // 双指针为什么要交替移动，往中间靠拢 // 在固定两重循环元素的情况，第三个元素导致的三数之和有可能导致 > 0 ,= 0 < 0，也有可能 = 0（重复答案） // 而 < 0 时，第二个枚举元素的下标要右边移动，增大总和 // 而 > 0 时，只能让第三个枚举元素的下标向左移动，减小总和 // = 0，就是当前答案，随后继续交替移动，排除重复答案、 List<List<Integer>> res = new ArrayList<>(); if(nums == null || nums.length <3){ return res; } Arrays.sort(nums); for(int k = 0;k < nums.length; k++){ if(nums[k] > 0) break; // 此时剩余两个元素都 > 0，往后的查找不满足。 if(k > 0 && nums[k] == nums[k - 1]) continue; // 找到重复答案（题目要求不重复） int i = k + 1,j = nums.length - 1; while(i < j){ int sum = nums[k] + nums[i] + nums[j]; if(sum < 0){ while(i < j && nums[i] == nums[++i]); // 不判断相同元素 }else if(sum > 0){ while(i < j && nums[j] == nums[--j]); // 不判断相同元素 }else if(sum == 0){ res.add(new ArrayList<Integer>(Arrays.asList(nums[k],nums[i],nums[j]))); while(i < j && nums[i] == nums[++i]); // 不判断相同答案的元素 while(i < j && nums[j] == nums[--j]); // 不判断相同答案的元素 } } } return res; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)，排序的时间复杂度为 O(nlogn)。双重循环的时间复杂度为 O(n2)\",\"空间复杂度：O(1)，指针使用常数大小的额外空间，忽略答案的存储空间。\"]},\"142\":{\"c\":[\"LeetCode\"]},\"143\":{\"c\":[\"双指针\",\"数组\"]},\"144\":{\"h\":\"151-反转字符串中的单词\"},\"145\":{\"h\":\"题目地址(151. 反转字符串中的单词 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-words-in-a-string/submissions/\"]},\"146\":{\"h\":\"题目描述\",\"t\":[\" 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\",\" 单词 是由非空格字符组成的字符串。 s 中使用至少一个空格将字符串中的 单词 分隔开。\",\" 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\",\" 注意： 输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\",\" 示例 1：\",\" 输入： s = \\\" the sky is blue \\\" 输出： \\\" blue is sky the \\\" \",\" 示例 2：\",\" 输入： s = \\\" hello world \\\" 输出： \\\"world hello\\\" 解释： 反转后的字符串中不能存在前导空格和尾随空格。 \",\" 示例 3：\",\" 输入： s = \\\"a good example\\\" 输出： \\\"example good a\\\" 解释： 如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 \",\" 提示：\",\" 1 <= s.length <= 10 4 \",\" s 包含英文大小写字母、数字和空格 ' '\",\" s 中 至少存在一个 单词 \",\" 进阶： 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\"]},\"147\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"148\":{\"h\":\"思路 1：字符串 API\",\"t\":[\"使用 split() ，以空格进行分割\",\"使用 reverse() 倒排字符串列表\"]},\"149\":{\"h\":\"代码\",\"t\":[\"Java Code\",\"class Solution { public String reverseWords(String s) { // 除去开头和末尾的空白字符 s = s.trim(); // 正则匹配连续的空白字符作为分隔符分割 List<String> wordList = Arrays.asList(s.split(\\\"\\\\\\\\s+\\\")); Collections.reverse(wordList); return String.join(\\\" \\\", wordList); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，线性遍历字符串。\",\"空间复杂度：O(n)，List 中的元素总长度，占用 O(N) 大小的额外空间。\"]},\"150\":{\"h\":\"思路 2：倒序遍历+双指针\",\"t\":[\"倒序遍历字符串 s，使用双指针 i，j 指向单词的范围。\",\"将单词添加到结果中\",\"并将双指针指向新的单词，最后将所有单词拼接起来。\"]},\"151\":{\"h\":\"代码\",\"t\":[\"Java Code:\",\" class Solution { public String reverseWords(String s) { s = s.trim(); // 删除首尾空格 int j = s.length() - 1, i = j; StringBuilder res = new StringBuilder(); while (i >= 0) { while (i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格 res.append(s.substring(i + 1, j + 1) + \\\" \\\"); // 添加单词 while (i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格 j = i; // j 指向下个单词的尾字符 } return res.toString().trim(); // 转化为字符串并返回 } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，线性遍历字符串。\",\"空间复杂度：O(n)，StringBuilder(Java) 中的字符串总长度，占用 O(N) 大小的额外空间。\"]},\"152\":{\"h\":\"思路3：手写字符串API\",\"t\":[\"去除空格 trimSpaces\",\"先翻转整个字符串 reverse\",\"再翻转每个单词 reverseEachWord\"]},\"153\":{\"h\":\"代码\",\"t\":[\"class Solution { public String reverseWords(String s) { StringBuilder sb = trimSpaces(s); // 翻转字符串 reverse(sb, 0, sb.length() - 1); // 翻转每个单词 reverseEachWord(sb); return sb.toString(); } // 去掉多余空格 public StringBuilder trimSpaces(String s) { int left = 0, right = s.length() - 1; // 去掉字符串开头的空白字符 while (left <= right && s.charAt(left) == ' ') { ++left; } // 去掉字符串末尾的空白字符 while (left <= right && s.charAt(right) == ' ') { --right; } // 将字符串间多余的空白字符去除 StringBuilder sb = new StringBuilder(); while (left <= right) { char c = s.charAt(left); if (c != ' ') { sb.append(c); } else if (sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } ++left; } return sb; } // 反转字符串 public void reverse(StringBuilder sb, int left, int right) { while (left < right) { char tmp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, tmp); } } // 翻转每一个单词 public void reverseEachWord(StringBuilder sb) { int n = sb.length(); int start = 0, end = 0; while (start < n) { // 循环至单词的末尾 while (end < n && sb.charAt(end) != ' ') { ++end; } // 翻转单词 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; } } }\",\"复杂度分析\",\"时间复杂度：O(n)，其中 n 为输入字符串的长度。\",\"空间复杂度：Java 和 Python 的方法需要 O(n) 的空间来存储字符串\"]},\"154\":{\"c\":[\"LeetCode\"]},\"155\":{\"c\":[\"字符串\"]},\"156\":{\"h\":\"18-四数之和\"},\"157\":{\"h\":\"题目地址(18. 四数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/4sum/description/\"]},\"158\":{\"h\":\"题目描述\",\"t\":[\"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\",\"0 <= a, b, c, d < n\",\"a、b、c 和 d互不相同\",\"nums[a] + nums[b] + nums[c] + nums[d] == target\",\"你可以按 任意顺序 返回答案 。\",\"示例 1：\",\"输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] \",\"示例 2：\",\"输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] \",\"提示：\",\"1 <= nums.length <= 200\",\"-109 <= nums[i] <= 109\",\"-109 <= target <= 109\"]},\"159\":{\"h\":\"前置知识\",\"t\":[\"哈希表\",\"三数之和\"]},\"160\":{\"h\":\"思路\",\"t\":[\"本题与「15. 三数之和」相似，解法也相似。\",\"为了避免枚举到重复四元组，则需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素，且在同一重循环中不能多次枚举到相同的元素。因此我们需要「排序」。\",\"使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。\"]},\"161\":{\"h\":\"关键点\",\"t\":[\"排序解决重复问题\",\"使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。\"]},\"162\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { Arrays.sort(nums); List<List<Integer>> ans = new ArrayList<>(); int n = nums.length; // 枚举第一个数 for (int a = 0; a < n - 3; a++) { long x = nums[a]; // 跳过重复数字 if (a > 0 && x == nums[a - 1]) continue; if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break; if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue; // 枚举第二个数 for (int b = a + 1; b < n - 2; b++) { long y = nums[b]; if (b > a + 1 && y == nums[b - 1]) continue; if (x + y + nums[b + 1] + nums[b + 2] > target) break; if (x + y + nums[n - 2] + nums[n - 1] < target) continue; int l = b + 1, r = n - 1; while (l < r) { long sum = x + y + nums[l] + nums[r]; if (sum > target) r--; else if (sum < target) l++; else { // sum == target ans.add(Arrays.asList((int)x, (int)y, nums[l], nums[r])); l++; while (l < r && nums[l] == nums[l - 1]) l++; r--; while (l < r && nums[r] == nums[r + 1]) r--; } } } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n3)，排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n3)，因此总时间复杂度为 O(n3+nlogn)=O(n3)。\",\"空间复杂度：O(n)，空间复杂度主要取决于排序额外使用的空间。可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O(n)。\"]},\"163\":{\"c\":[\"LeetCode\"]},\"164\":{\"c\":[\"双指针\",\"数组\"]},\"165\":{\"h\":\"19-删除链表的倒数第N个结点\"},\"166\":{\"h\":\"题目地址(19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\"]},\"167\":{\"h\":\"题目描述\",\"t\":[\" 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\",\" 示例 1：\",\" 输入： head = [1,2,3,4,5], n = 2 输出： [1,2,3,5] \",\" 示例 2：\",\" 输入： head = [1], n = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [1,2], n = 1 输出： [1] \",\" 提示：\",\" 链表中结点的数目为 sz \",\" 1 <= sz <= 30 \",\" 0 <= Node.val <= 100 \",\" 1 <= n <= sz \",\" 进阶： 你能尝试使用一趟扫描实现吗？\"]},\"168\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针\"]},\"169\":{\"h\":\"思路 1：双指针\",\"t\":[\"dummyHead 存储虚拟头节点，first 存储头节点，second 存储虚拟头节点，进行遍历。\",\"让 first 先走 N 步。\",\"second 和 first 一起走。\",\"当 first 走到空节点时时，second 刚好走好倒数第 N+1 个\"]},\"170\":{\"h\":\"关键点\",\"t\":[\"由于要进行删除操作，因此要找到「倒数第 n+1」个节点位置\"]},\"171\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (head.next == null && n == 1) { return null; } // 怎么知道是倒数第 2 个，使用双指针，让一个指针先走 2 步 ListNode dummyHead = new ListNode(-1, head); ListNode first = head; ListNode second = dummyHead; // 让 first 先走 n，让 first 到达尾节点，second 刚好指向倒数第 n 个 for (int i = 0; i < n; i++) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummyHead.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"172\":{\"c\":[\"LeetCode\"]},\"173\":{\"c\":[\"链表\"]},\"174\":{\"h\":\"199-二叉树的右视图\"},\"175\":{\"h\":\"题目地址(199. 二叉树的右视图 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/binary-tree-right-side-view/description/\"]},\"176\":{\"h\":\"题目描述\",\"t\":[\" 给定一个二叉树的 根节点 root ，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\",\" 示例 1: \",\" 输入: [1,2,3, null,5, null,4] 输出: [1,3,4] \",\" 示例 2: \",\" 输入: [1, null,3] 输出: [1,3] \",\" 示例 3: \",\" 输入: [] 输出: [] \",\" 提示: \",\" 二叉树的节点个数的范围是 [0,100] \",\"-100 <= Node.val <= 100 \"]},\"177\":{\"h\":\"前置知识\",\"t\":[\"二叉树\",\"层序遍历\",\"深度遍历\"]},\"178\":{\"h\":\"思路1：层序遍历\",\"t\":[\"使用一个队列存储每一层的节点，在遍历每一层节点时，直到最后一个节点才进行处理。\"]},\"179\":{\"h\":\"关键点\",\"t\":[\"每一层从左到右遍历时，直到最后一个节点才进行处理\"]},\"180\":{\"h\":\"代码\",\"t\":[\"class Solution { public List<Integer> rightSideView(TreeNode root) { // 层序遍历，从右到左 List<Integer> res = new ArrayList<>(); if (root == null) return res; Deque<TreeNode> queue = new ArrayDeque<>(); queue.offer(root); while (!queue.isEmpty()) { int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } // 单层的最后一个元素就是最右元素 if (i == levelSize - 1) { res.add(node.val); } } } return res; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点最多进队列一次，出队列一次。\",\"空间复杂度：O(n)，每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。\"]},\"181\":{\"h\":\"思路2：层序遍历——递归方式\",\"t\":[\"先递归右子树，保证首次遇到的一定是最右边的节点。\",\"在递归左子树。\"]},\"182\":{\"h\":\"代码\",\"t\":[\"class Solution { public List<Integer> rightSideView(TreeNode root) { List<Integer> ans = new ArrayList<>(); dfs(root, 0, ans); return ans; } private void dfs(TreeNode root, int depth, List<Integer> ans) { if (root == null) { return; } if (depth == ans.size()) { // 这个深度首次遇到 ans.add(root.val); } dfs(root.right, depth + 1, ans); // 先递归右子树，保证首次遇到的一定是最右边的节点 dfs(root.left, depth + 1, ans); } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点最多进队列一次，出队列一次。\",\"空间复杂度：O(h)，其中 h 是二叉树的高度。递归需要 O(h) 的栈空间。最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。\"]},\"183\":{\"c\":[\"LeetCode\"]},\"184\":{\"c\":[\"二叉树\",\"BFS\",\"DFS\"]},\"185\":{\"h\":\"20-有效的括号\"},\"186\":{\"h\":\"题目地址(20. 有效的括号 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/valid-parentheses/description/\"]},\"187\":{\"h\":\"题目描述\",\"t\":[\"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\",\"有效字符串需满足：\",\"左括号必须用相同类型的右括号闭合。\",\"左括号必须以正确的顺序闭合。\",\"每个右括号都有一个对应的相同类型的左括号。\",\"示例 1：\",\"输入：s = \\\"()\\\" 输出：true \",\"示例 2：\",\"输入：s = \\\"()[]{}\\\" 输出：true \",\"示例 3：\",\"输入：s = \\\"(]\\\" 输出：false \",\"提示：\",\"1 <= s.length <= 104\",\"s 仅由括号 '()[]{}' 组成\"]},\"188\":{\"h\":\"前置知识\",\"t\":[\"栈\",\"字符串\"]},\"189\":{\"h\":\"思路\",\"t\":[\"当我们遇到一个左括号时，就放入一个对应的右括号。\",\"当我们遇到一个右括号时，\",\"如果栈为空或者栈顶元素与「当前的右括号」不一样时，那么字符串就是无效的。\",\"如果与栈顶元素一样，就说明括号右效。将栈顶元素出栈\",\"最后再判断栈是不是为空，解决 [({}) 这种情况\"]},\"190\":{\"h\":\"关键点\",\"t\":[\"入栈是右括号，并将当前元素与栈顶元素判断是否相同\"]},\"191\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public boolean isValid(String s) { if (s.isEmpty()) { return true; } // 长度为奇数时 if(s.length() % 2 == 1){ return false; } Deque<Character> queue = new ArrayDeque<>(); for (char c : s.toCharArray()) { if(c == '('){ queue.offer(')'); }else if(c == '['){ queue.offer(']'); }else if(c == '{'){ queue.offer('}'); }else if(queue.isEmpty() || c != queue.pollLast()){ return false; } } return queue.isEmpty(); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n),创建一个双端队列存放右括号，最多是1/2 n个。\"]},\"192\":{\"c\":[\"LeetCode\"]},\"193\":{\"c\":[\"字符串\",\"栈\"]},\"194\":{\"h\":\"202-快乐数\"},\"195\":{\"h\":\"题目地址(202. 快乐数 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/happy-number/\"]},\"196\":{\"h\":\"题目描述\",\"t\":[\"编写一个算法来判断一个数 n 是不是快乐数。\",\"「快乐数」 定义为：\",\"对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\",\"然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\",\"如果这个过程 结果为 1，那么这个数就是快乐数。\",\"如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\",\"示例 1：\",\"输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 \",\"示例 2：\",\"输入：n = 2 输出：false \",\"提示：\",\"1 <= n <= 231 - 1\"]},\"197\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"198\":{\"h\":\"思路\",\"t\":[\"通过反复调用 getNext(n) 得到的链是一个隐式的链表。链中的所有其他数字都是节点。那问题就直接转换为「检测一个链表是否有环。」\",\"定义两个指针slow和fast，slow在链表中前进 1 个节点，fast在链表前进 2 个节点（对 getNext(n) 函数的嵌套调用）。\",\"如果 n 是快乐数，则就说明没有循环，fast 会先到 “1”\",\"如果 n 不是快乐数，fast 和 slow 一定会在循环中。\"]},\"199\":{\"h\":\"关键点\",\"t\":[\"将”快乐数“操作视为寻找下一个数，即看成一个链表\"]},\"200\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { // 对于一个三位数来说，最大的平方和为 9^2+9^2+9^2 = 243 // 对于一个四位数来说，最大的平方和为 81 + 81 + 81 + 81 = 324 // 在继续往下后，4位数只会降到3位数，而不会无穷大 public int getNext(int n) { int totalSum = 0; // 计算每一位的平方和 while (n > 0) { int d = n % 10; n = n / 10; totalSum += d * d; } return totalSum; } public boolean isHappy(int n) { int slowRunner = n; int fastRunner = getNext(n); if(fastRunner == 1){ return true; } // 快慢指针，不是快乐数，那么存在一个环使得算法无限循环 // 在环中它们由于步速不一致，会相遇 // 如果相遇，则说明不是快乐数 // 如果是快乐数，最后会返回1 while (slowRunner != fastRunner) { // slow 走一步, fast 走两步 slowRunner = getNext(slowRunner); fastRunner = getNext(fastRunner); fastRunner = getNext(fastRunner); } return fastRunner == 1; } }\",\"复杂度分析\",\"时间复杂度：O(n)\",\"如果没有循环，那么fast将先到达 1，slow将到达链表中的一半。成本是 O(2⋅logn)=O(logn)\",\"一旦两个指针都在循环中，假设循环中有 k 个数字。如果他们的起点是相隔 k−1 的位置（这是他们可以开始的最远的距离），那么快跑者需要 k−1 步才能到达慢跑者，主操作不变，所以也是 O(logn)。\",\"空间复杂度：O(n)\"]},\"201\":{\"c\":[\"LeetCode\"]},\"202\":{\"c\":[\"哈希表\"]},\"203\":{\"h\":\"203-移除链表元素\"},\"204\":{\"h\":\"题目地址(203. 移除链表元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-linked-list-elements/description/\"]},\"205\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\",\" 示例 1：\",\" 输入： head = [1,2,6,3,4,5,6], val = 6 输出： [1,2,3,4,5] \",\" 示例 2：\",\" 输入： head = [], val = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [7,7,7,7], val = 7 输出： [] \",\" 提示：\",\" 列表中的节点数目在范围 [0, 10 4 ] 内 \",\" 1 <= Node.val <= 50 \",\" 0 <= val <= 50 ## 前置知识 \",\"链表\",\"删除节点\",\"虚拟节点\"]},\"206\":{\"h\":\"思路1:直接删除\",\"t\":[\"先判断头结点的情况 head!=null&&head.val!=val\",\"从当前节点的后驱节点进行遍历\"]},\"207\":{\"h\":\"关键点\",\"t\":[\"头结点要特殊处理\",\"cur.next=cur.next.next\"]},\"208\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 删除值相同的头结点后，可能新的头结点也值相等，用循环解决 while (head != null && head.val == val) { head = head.next; } if (head == null) return head; ListNode prev = head; // 确保当前结点后还有结点 while (prev.next != null) { if (prev.next.val == val) { prev.next = prev.next.next; } else { prev = prev.next; } } return head; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"209\":{\"h\":\"思路2：虚拟头节点\"},\"210\":{\"h\":\"关键点\",\"t\":[\"在虚拟头节点下，要删除一个节点，删除方式一样。最后返回的时候是 dummyNode.next\"]},\"211\":{\"h\":\"代码\",\"t\":[\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { //创建一个虚拟头结点 ListNode dummyNode=new ListNode(val-1); dummyNode.next=head; ListNode prev=dummyNode; //确保当前结点后还有结点 while(prev.next!=null){ if(prev.next.val==val){ prev.next=prev.next.next; }else{ prev=prev.next; } } return dummyNode.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"212\":{\"c\":[\"LeetCode\"]},\"213\":{\"c\":[\"链表\"]},\"214\":{\"h\":\"206-反转链表\"},\"215\":{\"h\":\"题目地址(206. 反转链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-linked-list/\"]},\"216\":{\"h\":\"题目描述\",\"t\":[\"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\",\"示例 1：\",\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \",\"示例 2：\",\"输入：head = [1,2] 输出：[2,1] \",\"示例 3：\",\"输入：head = [] 输出：[] \",\"提示：\",\"链表中节点的数目范围是 [0, 5000]\",\"-5000 <= Node.val <= 5000\",\"进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\"]},\"217\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针/递归思想\"]},\"218\":{\"h\":\"思路1:双指针\",\"t\":[\"图片来自：代码随想录\",\"pre 指向虚拟节点，cur 指向头节点\",\"在每一次移动过程中，修改节点指向\"]},\"219\":{\"h\":\"关键点\",\"t\":[\"先存储 next 引用 next=cur.next\",\"cur.next=pre\",\"pre=cur\",\"cur=next\"]},\"220\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; // 前驱节点 null ListNode curr = head; // 当前节点 1 (1->2) while (curr != null) { ListNode next = curr.next; // 后驱节点 2 curr.next = prev; // 反向 1<-2 prev = curr; // prev = 1 curr = next; // curr = 2 } return prev; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"221\":{\"h\":\"思路2：递归\",\"t\":[\"递归函数的定义\",\"输出一个节点 head\",\"将 head 为起点的链表进行反转\",\"返回反转之后的头节点\"]},\"222\":{\"h\":\"关键点\",\"t\":[\"理解递归\",\"当第一次递归时，已经把链表分成后两部分\"]},\"223\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，空间复杂度主要取决于递归调用的栈空间，最多为 n 层。\"]},\"224\":{\"c\":[\"LeetCode\"]},\"225\":{\"c\":[\"链表\"]},\"226\":{\"h\":\"209-长度最小的子数组\"},\"227\":{\"h\":\"题目地址(209. 长度最小的子数组 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/minimum-size-subarray-sum/\"]},\"228\":{\"h\":\"题目描述\",\"t\":[\"给定一个含有 n个正整数的数组和一个正整数 target 。\",\"找出该数组中满足其总和大于等于target的长度最小的 \",\"子数组\",\"[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\",\"示例 1：\",\"输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 \",\"示例 2：\",\"输入：target = 4, nums = [1,4,4] 输出：1 \",\"示例 3：\",\"输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 \",\"提示：\",\"1 <= target <= 109\",\"1 <= nums.length <= 105\",\"1 <= nums[i] <= 105\",\"进阶：\",\"如果你已经实现O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\"]},\"229\":{\"h\":\"前置知识\",\"t\":[\"滑动窗口\",\"[前缀和+二分查找]\"]},\"230\":{\"h\":\"思路1：滑动窗口\",\"t\":[\"定义两个指针 start 和 end 分别指向滑动窗口的开始位置和结束位置\",\"计算滑动窗口的总和 sum\",\"当 sum 符合题目时，窗口的长度为子数组的最小长度 end−start+1\",\"将 start 继续往右移，找到更小的窗口长度\",\"继续更新子数组的最小长度\"]},\"231\":{\"h\":\"关键点\",\"t\":[\"当窗口符合条件时，要将 start 继续往右移，找到更小的窗口长度\"]},\"232\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int minSubArrayLen(int target, int[] nums) { // 第一次符合条件为窗口长度 right - left // int n = nums.length; if(n == 0) return 0; int ans = Integer.MAX_VALUE; int start = 0, end = 0; // 滑动串口的指针和右指针 int sum = 0; while (end < n) { sum += nums[end]; // 把当前元素添加进去,直到符合最小窗口的长度 while (sum >= target) { // 最小窗口长度右移，直到不满足 此时，ans = end - start + 1， end - start ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"233\":{\"c\":[\"LeetCode\"]},\"234\":{\"h\":\"225-用队列实现栈\"},\"235\":{\"h\":\"题目地址(225. 用队列实现栈 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/implement-stack-using-queues/description/\"]},\"236\":{\"h\":\"题目描述\",\"t\":[\" 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（ push 、 top 、 pop 和 empty ）。\",\" 实现 MyStack 类：\",\" void push(int x) 将元素 x 压入栈顶。\",\" int pop() 移除并返回栈顶元素。\",\" int top() 返回栈顶元素。\",\" boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\",\" 注意：\",\" 你只能使用队列的标准操作 —— 也就是 push to back 、 peek/pop from front 、 size 和 is empty 这些操作。\",\" 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\",\" 示例：\",\" 输入： [\\\"MyStack\\\", \\\"push\\\", \\\"push\\\", \\\"top\\\", \\\"pop\\\", \\\"empty\\\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False \",\" 提示：\",\" 1 <= x <= 9 \",\" 最多调用 100 次 push 、 pop 、 top 和 empty \",\" 每次调用 pop 和 top 都保证栈不为空 \",\" 进阶： 你能否仅用一个队列来实现栈。\"]},\"237\":{\"h\":\"前置知识\",\"t\":[\"栈\",\"队列\"]},\"238\":{\"h\":\"思路\",\"t\":[\"队列是先进先出\",\"栈是后进先出。\",\"使用两个队列，一个当成主要的，一个辅助备份。\"]},\"239\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyStack { //q1 作为主要的队列，其元素排列顺序和出栈顺序相同 Queue<Integer> q1 = new ArrayDeque<>(); //q2 仅作为临时放置 Queue<Integer> q2 = new ArrayDeque<>(); public MyStack() { } //在加入元素时先将 q1 中的元素依次出栈压入 q2，然后将新加入的元素压入 q1，再将 q2 中的元素依次出栈压入 q1 public void push(int x) { while (q1.size() > 0) { q2.offer(q1.poll()); } q1.offer(x); while (q2.size() > 0) { q1.offer(q2.poll()); } } public int pop() { return q1.poll(); } public int top() { return q1.peek(); } public boolean empty() { return q1.isEmpty(); } }\",\"复杂度分析\",\"令 n 为栈内元素个数。\",\"时间复杂度：O(n), push 操作为 2n+1 个，pop 操作为 O(1), top 操作为 O(1)，empty 操作为 O(1)\",\"空间复杂度：O(n), 其中 n 是栈内的元素个数。需要使用两个队列存储栈内的元素。\"]},\"240\":{\"c\":[\"LeetCode\"]},\"241\":{\"c\":[\"列队\",\"栈\"]},\"242\":{\"h\":\"226-翻转二叉树\"},\"243\":{\"h\":\"题目地址(226. 翻转二叉树 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/invert-binary-tree/description/\"]},\"244\":{\"h\":\"题目描述\",\"t\":[\" 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\",\" 示例 1：\",\" 输入： root = [4,2,7,1,3,6,9] 输出： [4,7,2,9,6,3,1] \",\" 示例 2：\",\" 输入： root = [2,1,3] 输出： [2,3,1] \",\" 示例 3：\",\" 输入： root = [] 输出： [] \",\" 提示：\",\" 树中节点数目范围在 [0, 100] 内 \",\"-100 <= Node.val <= 100 ## 思路 1：递归 \",\"所谓的翻转就是将二叉树上的每个节点的「左右子节点交换」\",\"递归函数定义：\",\"终止条件：当节点 root 为空时，直接返回 null;\",\"单层递归逻辑： \",\"暂存节点 root 的左子节点（因为左子节点在翻转后会发生变化）\",\"递归翻转 root 的右子节点，递归的结果就是 root 的新左子节点\",\"递归翻转 root 的左子节点（旧），递归的结果就是 root 的新右子节点\",\"返回值： root\"]},\"245\":{\"h\":\"关键点\",\"t\":[\"翻转二叉树是改变树，而不是单纯的输出树节点，所以不能通过「层序遍历」方法输出\",\"在翻转后子节点会发生变化。不要用\"]},\"246\":{\"h\":\"代码\",\"t\":[\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { // 1. 终止条件：当节点为空时，返回 null // 2. 参数及返回值：root，root // 3. 单层递归逻辑：交换左右子树 if(root ==null) return root; TreeNode temp = root.left; root.left = invertTree(root.right); // 处理右子树后，就是根节点的左子树（左子树已经发生变化） root.right = invertTree(temp); // 处理左子树，处理后变成根节点的右子树（不能使用 root.left） return root; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，需要遍历树的所有节点\",\"空间复杂度：O(n)，最差情况下，二叉树退化为链表，需要开辟 O(n) 的栈空间来递归\"]},\"247\":{\"h\":\"思路 2：层序遍历\",\"t\":[\"使用一个队列存储每一层的遍历结果，并交换节点的左右子节点\",\"提前将 root 节点入队\",\"循环遍历，当队列为空时，退出循环 \",\"出队节点 node\",\"将 node 的左右节点进行入队\",\"交换 node 的左右子节点\",\"第一次循环后的情况如下：\"]},\"248\":{\"h\":\"代码\",\"t\":[\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { // 层序遍历 if(root == null) return root; Deque<TreeNode> deque = new ArrayDeque<>(); deque.offerLast(root); while(!deque.isEmpty()){ TreeNode node = deque.pollFirst(); if(node.left != null){ deque.offerLast(node.left); } if(node.right != null){ deque.offerLast(node.right); } swapLeftRight(node); } return root; } public void swapLeftRight(TreeNode root){ TreeNode temp = root.left; root.left = root.right; root.right = temp; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，需要遍历树的所有节点\",\"空间复杂度：O(n)，最差情况下，队列最多同时存储 (N+1)/2 个节点，占用 O(N) 额外空间。\"]},\"249\":{\"c\":[\"Leetcode\"]},\"250\":{\"c\":[\"二叉树\"]},\"251\":{\"h\":\"232-用栈实现队列\"},\"252\":{\"h\":\"题目地址(232. 用栈实现队列 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/implement-queue-using-stacks/description/\"]},\"253\":{\"h\":\"题目描述\",\"t\":[\" 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（ push 、 pop 、 peek 、 empty ）：\",\" 实现 MyQueue 类：\",\" void push(int x) 将元素 x 推到队列的末尾 \",\" int pop() 从队列的开头移除并返回元素 \",\" int peek() 返回队列开头的元素 \",\" boolean empty() 如果队列为空，返回 true ；否则，返回 false \",\" 说明：\",\" 你 只能 使用标准的栈操作 —— 也就是只有 push to top , peek/pop from top , size , 和 is empty 操作是合法的。\",\" 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\",\" 示例 1：\",\" 输入： [\\\"MyQueue\\\", \\\"push\\\", \\\"push\\\", \\\"peek\\\", \\\"pop\\\", \\\"empty\\\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false \",\" 提示：\",\" 1 <= x <= 9 \",\" 最多调用 100 次 push 、 pop 、 peek 和 empty \",\" 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\",\" 进阶：\",\" 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\"]},\"254\":{\"h\":\"前置知识\",\"t\":[\"队列\"]},\"255\":{\"h\":\"思路\",\"t\":[\"用一个队列存放 push 元素，用一个队列存放 pop 元素。在 pop 或 peek 时，需要将元素从 in 放进 out 中进行。\"]},\"256\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyQueue { Deque<Integer> out, in; public MyQueue() { in = new ArrayDeque<Integer>(); out = new ArrayDeque<Integer>(); } public void push(int x) { in.push(x); } public int pop() { if (out.isEmpty()) { in2out(); } return out.pop(); } public int peek() { if (out.isEmpty()) { in2out(); } return out.peek(); } public boolean empty() { return in.isEmpty() && out.isEmpty(); } private void in2out() { while (!in.isEmpty()) { out.push(in.pop()); } } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */\",\"复杂度分析\",\"令 n 为操作数。\",\"时间复杂度：O(1), push 和 empty 操作都是 O(1), pop 和 peek 为均摊 O(1)。\",\"空间复杂度：O(n)，对于有 n 次 push 操作的情况，队列中会有 n 个元素，故空间复杂度为 O(n)。\"]},\"257\":{\"c\":[\"LeetCode\"]},\"258\":{\"c\":[\"栈\"]},\"259\":{\"h\":\"236-二叉树的最近公共祖先\"},\"260\":{\"h\":\"题目地址(236. 二叉树的最近公共祖先 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/\"]},\"261\":{\"h\":\"题目描述\",\"t\":[\" 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\",\" 百度百科 中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ 一个节点也可以是它自己的祖先 ）。”\",\" 示例 1：\",\" 输入： root = [3,5,1,6,2,0,8, null, null,7,4], p = 5, q = 1 输出： 3 解释： 节点 5 和节点 1 的最近公共祖先是节点 3 。 \",\" 示例 2：\",\" 输入： root = [3,5,1,6,2,0,8, null, null,7,4], p = 5, q = 4 输出： 5 解释： 节点 5 和节点 4 的最近公共祖先是节点 5 。 因为根据定义最近公共祖先节点可以为节点本身。 \",\" 示例 3：\",\" 输入： root = [1,2], p = 1, q = 2 输出： 1 \",\" 提示：\",\" 树中节点数目在范围 [2, 10 5 ] 内。\",\"-10 9 <= Node.val <= 10 9 \",\" 所有 Node.val 互不相同 。\",\" p != q \",\" p 和 q 均存在于给定的二叉树中。 ## 思路（来自题解区） \",\"祖先的定义： 若节点 p 在节点 root 的左（右）子树中，或 p=root ，则称 root 是 p 的祖先。\",\"最近公共祖先的定义： 设节点 root 为节点 p, q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p, q 的公共祖先，则称 root 是 “最近的公共祖先” 。\",\"如果 root 是 p，q 的最近公共祖先，则会发生以下情况：\",\"p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；\",\"p = root ，且 q 在 root 的左或右子树中；\",\"q = root ，且 p 在 root 的左或右子树中；\",\"考虑通过递归对二叉树进行先序遍历，当遇到节点 p 或 q 时返回。\",\"从底至顶回溯，当节点 p, q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。\",\"递归逻辑：\",\"终止条件： \",\"当树为空，直接返回 null\",\"当 root 等于 p 或者 q 时，直接返回 root\",\"递归左子树，结果为 left\",\"递归右子树，结果为 right\",\"判断 left 和 right 情况 \",\"left 和 right 同时为空，说明 root 左/右子树都不包含 p 和 q，返回 null\",\"left 和 right 都不为空，说明 p 和 q 在 root 的异侧，而 root 就是最近公共祖先，返回 root\",\"left 为空，right 不为空。p, q 都不在 root 的左子树中，直接返回 right \",\"p, q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）。最后也会一层一层的往上传结果\",\"p, q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点\"]},\"262\":{\"h\":\"关键点\",\"t\":[\"祖先定义\",\"最近公共祖先定义\",\"自底向上从叶子节点开始更新的，所有满足条件的公共祖先中一定是深度最大的祖先先被访问到。\"]},\"263\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; if(root == q || root ==p) return root; // 左 TreeNode left = lowestCommonAncestor(root.left,p,q); // 右 TreeNode right = lowestCommonAncestor(root.right,p,q); // 中处理 if(left != null && right != null){ return root; }else if(left != null && right == null){ return left; }else if(left == null && right != null){ return right; }else{ return null; } } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，二叉树的所有节点有且只会被访问一次，因此时间复杂度为 O(N)。\",\"空间复杂度：O(n)，递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)。\"]},\"264\":{\"h\":\"24-两两交换链表中的节点\"},\"265\":{\"h\":\"题目地址(24. 两两交换链表中的节点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/swap-nodes-in-pairs/description/\"]},\"266\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\",\"示例 1：\",\"输入：head = [1,2,3,4] 输出：[2,1,4,3] \",\"示例 2：\",\"输入：head = [] 输出：[] \",\"示例 3：\",\"输入：head = [1] 输出：[1] \",\"提示：\",\"链表中节点的数目在范围 [0, 100] 内\",\"0 <= Node.val <= 100\"]},\"267\":{\"h\":\"前置知识\",\"t\":[\"链表\"]},\"268\":{\"h\":\"思路1：虚拟头节点\",\"t\":[\"使用变量 cur 代表当前节点，初始化为 cur=dummy\",\"使用两个变量 first 和 second 待交换的节点，即 first=cur.next 和 second=cur.next.next\",\"当链表还剩下两个节点时，就可以进行更改链表节点的交换\",\"cur.next = secod\",\"first.next = second.next\",\"second.next = first\",\"cur = first\",\"进行下一轮的判断并且交换\"]},\"269\":{\"h\":\"关键点\",\"t\":[\"循环条件是当前链表还有2个以上的节点\",\"链表节点交换的指针变动\"]},\"270\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(0); // 设置一个虚拟头节点 dummy.next = head; // 将虚拟头结点指向head,这样方便后续做删除操作 ListNode cur = dummy; while (cur.next != null && cur.next.next != null) { ListNode first = cur.next; ListNode second = cur.next.next; cur.next = second; // 步骤一 first.next = second.next; // 步骤三 second.next = first; // 步骤二 cur = first; } return dummy.next; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"271\":{\"c\":[\"LeetCode\"]},\"272\":{\"h\":\"242-有效的字母异位词\"},\"273\":{\"h\":\"题目地址(242. 有效的字母异位词 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/valid-anagram/description/\"]},\"274\":{\"h\":\"题目描述\",\"t\":[\" 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\",\" 注意： 若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\",\" 示例 1: \",\" 输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true \",\" 示例 2: \",\" 输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false \",\" 提示: \",\" 1 <= s.length, t.length <= 5 * 10 4 \",\" s 和 t 仅包含小写字母 \",\" 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\"]},\"275\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"276\":{\"h\":\"思路：哈希表记录\",\"t\":[\"若 s、t 长度不相等，则「非字母异位词」\",\"若 s、t 某对应字母数量不同，则「非字母异位词」\",\"统计 s 各字符时执行 +1 ，统计 t 各字符时 −1 。若两字符串互为字母异位词，则最终哈希表中所有字符统计数值都应为 0 。\"]},\"277\":{\"h\":\"关键点\",\"t\":[\"使用哈希表进行记录不同字母出现的次数\",\"也可以使用长度固定的数组记录不同字母出现的次数\"]},\"278\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public boolean isAnagram(String s, String t) { // 先判断长度一致 if (s.length() != t.length()) { return false; } // 使用字母的特性：只有 26 个，以一个数组来记录 int[] table = new int[26]; for (int i = 0; i < s.length(); i++) { table[s.charAt(i) - 'a']++; table[t.charAt(i) - 'a']--; } for (int i = 0; i < 26; i++) { if (table[i] != 0) { return false; } } return true; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，数组长度为常数，因此空间复杂度为常数\"]},\"279\":{\"c\":[\"LeetCode\"]},\"280\":{\"c\":[\"哈希表\"]},\"281\":{\"h\":\"27-移除元素\"},\"282\":{\"h\":\"题目地址(27. 移除元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-element/\"]},\"283\":{\"h\":\"题目描述\",\"t\":[\" 给你一个数组 nums 和一个值 val ，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\",\" 假设 nums 中不等于 val 的元素数量为 k ，要通过此题，您需要执行以下操作：\",\" 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。 nums 的其余元素和 nums 的大小并不重要。\",\" 返回 k 。\",\" 用户评测：\",\" 评测机将使用以下代码测试您的解决方案：\",\"int [] nums = [...]; // 输入数组 int val = ...; // 要移除的值 int [] expectedNums = [...]; // 长度正确的预期答案。 // 它以不等于 val 的值排序。 int k = removeElement(nums, val); // 调用你的实现 assert k == expectedNums.length; sort(nums, 0, k); // 排序 nums 的前 k 个元素 for (int i = 0; i < actualLength; i++) { assert nums [i] == expectedNums [i]; }\",\" 如果所有的断言都通过，你的解决方案将会 通过 。\",\" 示例 1：\",\" 输入： nums = [3,2,2,3], val = 3 输出： 2, nums = [2,2, _,_] 解释： 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\",\" 示例 2：\",\" 输入： nums = [0,1,2,2,3,0,4,2], val = 2 输出： 5, nums = [0,1,4,0,3, _,_,_] 解释： 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。 注意这五个元素可以任意顺序返回。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。 \",\" 提示：\",\" 0 <= nums.length <= 100 \",\" 0 <= nums [i] <= 50 \",\" 0 <= val <= 100 \"]},\"284\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"285\":{\"h\":\"思路 1\",\"t\":[\"题意：\",\"原地-》空间复杂度为 O(1)\",\"前 K 个元素不等于 val\",\"遍历数组 nums，每次取出的数字变量为 num，同时设置一个下标 ans\",\"在遍历过程中如果出现数字与需要移除的值 不相同 时，则进行拷贝覆盖 nums[ans]=num，ans 自增 1\",\"如果相同的时候，则跳过该数字不进行拷贝覆盖，最后 ans 即为新的数组长度\"]},\"286\":{\"h\":\"关键点\",\"t\":[\"拷贝覆盖\"]},\"287\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int removeElement(int[] nums, int val) { int ans = 0; for (int num : nums) { if (num != val) { nums[ans] = num; ans++; } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"288\":{\"c\":[\"LeetCode\"]},\"289\":{\"c\":[\"数组\"]},\"290\":{\"h\":\"344-反转字符串\"},\"291\":{\"h\":\"题目地址(344. 反转字符串 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-string/\"]},\"292\":{\"h\":\"题目描述\",\"t\":[\" 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\" 不要给另外的数组分配额外的空间，你必须 原地 修改输入数组 、使用 O(1) 的额外空间解决这一问题。\",\" 示例 1：\",\" 输入： s = [\\\"h\\\", \\\"e\\\", \\\"l\\\", \\\"l\\\", \\\"o\\\"] 输出： [\\\"o\\\", \\\"l\\\", \\\"l\\\", \\\"e\\\", \\\"h\\\"] \",\" 示例 2：\",\" 输入： s = [\\\"H\\\", \\\"a\\\", \\\"n\\\", \\\"n\\\", \\\"a\\\", \\\"h\\\"] 输出： [\\\"h\\\", \\\"a\\\", \\\"n\\\", \\\"n\\\", \\\"a\\\", \\\"H\\\"] \",\" 提示：\",\" 1 <= s.length <= 10 5 \",\" s [i] 都是 ASCII 码表中的可打印字符 \"]},\"293\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"294\":{\"h\":\"思路\",\"t\":[\"使用两个指针 l, r 分别指向字符数组首元素，字符数组尾元素。\",\"当 l < r 时，交换 l 和 r 指向的元素。\",\"当 l == r 时，就表示反转结束。\"]},\"295\":{\"h\":\"关键点\",\"t\":[\"s[i] 与 s[n-1-i] 交换\"]},\"296\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public void reverseString(char[] s) { //O(1) int left = 0; int right = s.length - 1; while(left < right){ char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n), 一共执行了 n/2 次交换。\",\"空间复杂度：O(1)，两个指针，常数的空间。\"]},\"297\":{\"c\":[\"LeetCode\"]},\"298\":{\"c\":[\"字符串\"]},\"299\":{\"h\":\"349-两个数组的交集\"},\"300\":{\"h\":\"题目地址(349. 两个数组的交集 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-arrays/\"]},\"301\":{\"h\":\"题目描述\",\"t\":[\"给定两个数组 nums1 和 nums2 ，返回 它们的 \",\"交集\",\" 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\",\"示例 1：\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] \",\"示例 2：\",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 1000\"]},\"302\":{\"h\":\"前置知识\"},\"303\":{\"h\":\"公司\",\"t\":[\"暂无\"]},\"304\":{\"h\":\"思路\"},\"305\":{\"h\":\"关键点\"},\"306\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] intersection(int[] nums1, int[] nums2) { int[] hash1 = new int[1002]; int[] hash2 = new int[1002]; // 计数 for(int i : nums1) hash1[i]++; for(int i : nums2) hash2[i]++; List<Integer> resList = new ArrayList<>(); // 寻找交集元素 for(int i = 0; i < 1002; i++) if(hash1[i] > 0 && hash2[i] > 0) resList.add(i); // 转换成数组 int index = 0; int res[] = new int[resList.size()]; for(int i : resList) res[index++] = i; return res; } }\",\"复杂度分析\",\"令 n 为nums1数组长度,m为nums2数组长度。\",\"时间复杂度：O(m+n),使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间\",\"空间复杂度：O(m+n)，两个存储数组都是固定长度。\"]},\"307\":{\"c\":[\"LeetCode\"]},\"308\":{\"c\":[\"哈希表\",\"数组\"]},\"309\":{\"h\":\"383-赎金信\"},\"310\":{\"h\":\"题目地址(383. 赎金信 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/ransom-note/description/\"]},\"311\":{\"h\":\"题目描述\",\"t\":[\" 给你两个字符串： ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\",\" 如果可以，返回 true ；否则返回 false 。\",\" magazine 中的每个字符只能在 ransomNote 中使用一次。\",\" 示例 1：\",\" 输入： ransomNote = \\\"a\\\", magazine = \\\"b\\\" 输出： false \",\" 示例 2：\",\" 输入： ransomNote = \\\"aa\\\", magazine = \\\"ab\\\" 输出： false \",\" 示例 3：\",\" 输入： ransomNote = \\\"aa\\\", magazine = \\\"aab\\\" 输出： true \",\" 提示：\",\" 1 <= ransomNote.length, magazine.length <= 10 5 \",\" ransomNote 和 magazine 由小写英文字母组成 \"]},\"312\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"313\":{\"h\":\"思路\",\"t\":[\"如果两个字符串的长度不相等，则不是正确答案。\",\"如果 ransomNote 存在 magazine 没有的字母，则不是正确答案。\",\"定义一个长度为 26 的数组存放 magazine 不同字母的个数。 \",\"记录 ransomNote 每个字符的情况\",\"如果某个字符数量检查情况中，出现数量 < 0，说明 ransomNote 针对该字母的数量比 magazine 多，也不是正确答案\"]},\"314\":{\"h\":\"关键点\",\"t\":[\"字母总数为 26 个\",\"哈希表计数或者数组计数\",\"同样的题目还有 242-有效的字母异位词\"]},\"315\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public boolean canConstruct(String ransomNote, String magazine) { if (ransomNote.length() > magazine.length()) { return false; } int[] cnt = new int[26]; for (char c : magazine.toCharArray()) { cnt[c - 'a']++; } for (char c : ransomNote.toCharArray()) { cnt[c - 'a']--; if (cnt[c - 'a'] < 0) { return false; } } return true; } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，遍历字符串所需要的时间复杂度\",\"空间复杂度：O(S),定义存储的数组，固定长度，|S| <= 26;\"]},\"316\":{\"c\":[\"LeetCode\"]},\"317\":{\"c\":[\"哈希表\"]},\"318\":{\"h\":\"429-N 叉树的层序遍历\"},\"319\":{\"h\":\"题目地址(429. N 叉树的层序遍历 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/\"]},\"320\":{\"h\":\"题目描述\",\"t\":[\" 给定一个 N 叉树，返回其节点值的 层序遍历 。（即从左到右，逐层遍历）。\",\" 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\",\" 示例 1：\",\" 输入： root = [1, null,3,2,4, null,5,6] 输出： [[1], [3,2,4], [5,6]] \",\" 示例 2：\",\" 输入： root = [1, null,2,3,4,5, null, null,6,7, null,8, null,9,10, null, null,11, null,12, null,13, null, null,14] 输出： [[1], [2,3,4,5], [6,7,8,9,10], [11,12,13], [14]] \",\" 提示：\",\" 树的高度不会超过 1000 \",\" 树的节点总数在 [0, 10 4 ] 之间 \"]},\"321\":{\"h\":\"前置知识\",\"t\":[\"树\",\"BFS: 广度优先搜索\",\"DFS: 深度优先搜索\"]},\"322\":{\"h\":\"思路 1：BFS\",\"t\":[\"将二叉树的层序遍历扩展到 N 叉树，本质上是不变的。\",\"在二叉树的时候，我们是单独处理 root.left 和 root.right。而对于 N 叉树，我们应该使用一个循环进行处理。\"]},\"323\":{\"h\":\"关键点\",\"t\":[\"以「层」为单位构建答案，因此在单次 BFS 过程中也按「层」进行。\"]},\"324\":{\"h\":\"代码 1：\",\"t\":[\"class Solution { public List<List<Integer>> levelOrder(Node root) { List<List<Integer>> ans = new ArrayList<>(); Deque<Node> d = new ArrayDeque<>(); if (root != null) d.addLast(root); while (!d.isEmpty()) { int size = d.size(); List<Integer> list = new ArrayList<>(); while (size-- > 0) { Node t = d.pollFirst(); for (Node node : t.children) d.addLast(node); list.add(t.val); } ans.add(list); } return ans; } }\",\"复杂度分析\",\"令 n 为树的节点个数。\",\"时间复杂度：O(n)，每个节点最多出队一次，入队一次。\",\"空间复杂度：O(n)，队列所需要用到的空间是 O(n)，最坏情况下，树只有两层，根节点和 n-1 个节点组成的第二层。\"]},\"325\":{\"h\":\"思路 2：DFS\",\"t\":[\"在深度优先搜索过程中，同层的节点不会连续被处理，但在处理的时候依然遵循「从左到右」。\",\"因此对于某个节点来说，会获取对应该层的答案，然后处理该节点。\"]},\"326\":{\"h\":\"代码\",\"t\":[\" class Solution { List<List<Integer>> ans = new ArrayList<>(); public List<List<Integer>> levelOrder(Node root) { if (root == null) return ans; dfs(root, 0); return ans; } void dfs(Node u, int depth) { if (ans.size() == depth) ans.add(new ArrayList<>()); List<Integer> list = ans.get(depth); list.add(u.val); for (Node node : u.children) dfs(node, depth + 1); } }\",\"复杂度分析\",\"令 n 为树的节点个数。\",\"时间复杂度：O(n)，每个节点最多出队一次，入队一次。\",\"空间复杂度：O(h)，h为树的高度，最坏情况，树退化成链表，此时树的高度与节点个数一样。\"]},\"327\":{\"c\":[\"LeetCode\"]},\"328\":{\"c\":[\"树\",\"BFS\",\"DFS\"]},\"329\":{\"h\":\"454-四数相加 ii\"},\"330\":{\"h\":\"题目地址(454. 四数相加 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/4sum-ii/description/\"]},\"331\":{\"h\":\"题目描述\",\"t\":[\" 给你四个整数数组 nums1 、 nums2 、 nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\",\" 0 <= i, j, k, l < n \",\" nums1 [i] + nums2 [j] + nums3 [k] + nums4 [l] == 0 \",\" 示例 1：\",\" 输入： nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出： 2 解释： 两个元组如下： 1. (0, 0, 0, 1) -> nums1 [0] + nums2 [0] + nums3 [0] + nums4 [1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> nums1 [1] + nums2 [1] + nums3 [0] + nums4 [0] = 2 + (-1) + (-1) + 0 = 0 \",\" 示例 2：\",\" 输入： nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出： 1 \",\" 提示：\",\" n == nums1.length \",\" n == nums2.length \",\" n == nums3.length \",\" n == nums4.length \",\" 1 <= n <= 200 \",\"-2 28 <= nums1 [i], nums2 [i], nums3 [i], nums4 [i] <= 2 28 \"]},\"332\":{\"h\":\"前置知识\",\"t\":[\"两数之和思路\"]},\"333\":{\"h\":\"思路\",\"t\":[\"使用一个哈希表map存储 A 和 B 所有和sumAB的情况，其中 key 是和，value是和出现的次数\",\"使用同样的遍历方式，遍历 C + D，找到map是否存在 −(sumCD)。\",\"将 −(sumCD) 对应的值累加起来，就是答案。\"]},\"334\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { Map<Integer, Integer> countAB = new HashMap<Integer, Integer>(); for (int u : A) { for (int v : B) { countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1); } } int ans = 0; for (int u : C) { for (int v : D) { if (countAB.containsKey(-u - v)) { ans += countAB.get(-u - v); } } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)：使用双重循环进行遍历求和，其中哈希表操作都是 O(1)\",\"空间复杂度：O(n2)：哈希表所用的空间，最坏情况下，A 和 B 数组中每个元素之和都不相同。\"]},\"335\":{\"c\":[\"LeetCode\"]},\"336\":{\"c\":[\"哈希表\",\"数组\"]},\"337\":{\"h\":\"501-二叉搜索树中的众数\"},\"338\":{\"h\":\"题目地址(501. 二叉搜索树中的众数 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/\"]},\"339\":{\"h\":\"题目描述\",\"t\":[\" 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数 （即，出现频率最高的元素）。\",\" 如果树中有不止一个众数，可以按 任意顺序 返回。\",\" 假定 BST 满足如下定义：\",\" 结点左子树中所含节点的值 小于等于 当前节点的值 \",\" 结点右子树中所含节点的值 大于等于 当前节点的值 \",\" 左子树和右子树都是二叉搜索树 \",\" 示例 1：\",\" 输入： root = [1, null,2,2] 输出： [2] \",\" 示例 2：\",\" 输入： root = [0] 输出： [0] \",\" 提示：\",\" 树中节点的数目在范围 [1, 10 4 ] 内 \",\"-10 5 <= Node.val <= 10 5 \",\" 进阶： 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\"]},\"340\":{\"h\":\"思路\",\"t\":[\"一个二叉搜索树的中序遍历是一个非递减的有序序列。\",\" 1 / \\\\ 0 2 / \\\\ / -1 0 2\",\"中序遍历序列是 {−1,0,0,1,2,2}。会发现连续的数字是一小段一小段的出现。\",\"用 prev 来记录当前节点的上一个节点情况，curCount 来表示当前元素的重复次数，``mMaxCount来表示最大的重复次数,mode` 存储众数元素\",\"递归终止条件：当树为空时，直接返回\",\"递归逻辑：\",\"遍历左子树\",\"遍历第一个节点时，curCount = 1 , maxCount =1, 并将该元素放进 mode 中，即默认当前这个是众数\",\"遇到与 prev 相同的节点，更新重复次数，并判断是否是众数\",\"如果是众数，就添加进 mode\",\"如果不是众数，就说明存在一个元素比 mode 中的任何元素的重复次数还要大。要清空 mode ，并将元素添加进去\",\"遇到与 prev 不相同的节点，更新重复次数，并判断是否是众数\",\"更新 prev 为当前节点\",\"遍历右子树\"]},\"341\":{\"h\":\"关键点\",\"t\":[\"二叉树的特性\"]},\"342\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { List<Integer> mode = new ArrayList<>(); TreeNode prev = null; // 当前元素的重复次数 int curCount = 0; // 全局的最长相同序列长度 int maxCount = 0; public int[] findMode(TreeNode root) { // 执行中序遍历 traverse(root); int[] res = new int[mode.size()]; for (int i = 0; i < res.length; i++) { res[i] = mode.get(i); } return res; } public void traverse(TreeNode root) { if (root == null) return; traverse(root.left); if (prev == null) { curCount = 1; maxCount = 1; mode.add(root.val); } else { // root.val 重复的情况, 判断是否是众数 if (root.val == prev.val) { curCount++; if (curCount == maxCount) { // root.val 是众数 mode.add(root.val); } else if (curCount > maxCount) { mode.clear(); maxCount = curCount; mode.add(root.val); } } // root.val 不重复的情况, 重新记录 if (root.val != prev.val) { curCount = 1; if (curCount == maxCount) { mode.add(root.val); } } } // 别忘了更新 prev prev = root; traverse(root.right); } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，即遍历这棵树的复杂度。\",\"空间复杂度：O(n)，即递归的栈空间的空间代价。\"]},\"343\":{\"c\":[\"LeetCode\"]},\"344\":{\"c\":[\"二叉树\"]},\"345\":{\"h\":\"515-在每个树行中找最大值\"},\"346\":{\"h\":\"题目地址(515. 在每个树行中找最大值 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/\"]},\"347\":{\"h\":\"题目描述\",\"t\":[\" 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\",\" 示例 1：\",\" 输入: root = [1,3,2,5,3, null,9] 输出: [1,3,9] \",\" 示例 2：\",\" 输入: root = [1,2,3] 输出: [1,3] \",\" 提示：\",\" 二叉树的节点个数的范围是 [0,10 4 ] \",\"-2 31 <= Node.val <= 2 31 - 1 \"]},\"348\":{\"h\":\"前置知识\",\"t\":[\"二叉树\",\"BFS\",\"DFS\"]},\"349\":{\"h\":\"思路 1：DFS\",\"t\":[\"在进行 DFS 的过程中，如果当前节点是新的一层，默认该节点是该层的最大值。\",\"等到再 DFS 到同层节点时，就将同层节点与最大值进行比较。\"]},\"350\":{\"h\":\"关键点\",\"t\":[\"数组可以通过索引的方式进行重新设置值。\"]},\"351\":{\"h\":\"代码\",\"t\":[\"class Solution { List<Integer> res = new ArrayList<>(); public List<Integer> largestValues(TreeNode root) { if(root == null) return res; dfs(root, 0); return res; } public void dfs(TreeNode root, int depth){ if(root == null) return; if(res.size() == depth){ res.add(root.val); }else{ res.set(depth,Math.max(res.get(depth),root.val)); } if (root.left != null) { dfs(root.left, depth + 1); } if (root.right != null) { dfs(root.right, depth + 1); } } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n), 其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\",\"空间复杂度：O(h), 其中 h 表示树的高度。递归函数需要栈空间，递归深度等价于二叉树的高度。最坏情况下，树退化成一个链表，此时 h=n。\"]},\"352\":{\"h\":\"思路 2：BFS\",\"t\":[\"使用 BFS 进行层序遍历，每次的 BFS 都会将该层所有节点入队，在出队的时候，维护该层的最大值，并将其加入答案中。\"]},\"353\":{\"h\":\"代码\",\"t\":[\"class Solution { public List<Integer> largestValues(TreeNode root) { List<Integer> res = new ArrayList<>(); if(root == null) return res; Deque<TreeNode> queue = new ArrayDeque<>(); queue.addLast(root); while(!queue.isEmpty()){ int levelSize = queue.size(); int max = Integer.MIN_VALUE; for(int i = 0;i<levelSize;i++){ TreeNode node = queue.pollFirst(); if(node.left != null){ queue.addLast(node.left); } if(node.right != null){ queue.addLast(node.right); } max = Math.max(max,node.val); } res.add(max); } return res; } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n), 其中 n 为二叉树节点个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\",\"空间复杂度：O(n), 队列所需要的空间最多不超过 n 个节点的存放。\"]},\"354\":{\"c\":[\"LeetCode\"]},\"355\":{\"c\":[\"二叉树\",\"BFS\",\"DFS\"]},\"356\":{\"h\":\"530-二叉搜索树的最小绝对差\"},\"357\":{\"h\":\"题目地址(530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/\"]},\"358\":{\"h\":\"题目描述\",\"t\":[\"给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\",\"差值是一个正数，其数值等于两值之差的绝对值。\",\"示例 1：\",\"输入：root = [4,2,6,1,3] 输出：1 \",\"示例 2：\",\"输入：root = [1,0,48,null,null,12,49] 输出：1 \",\"提示：\",\"树中节点的数目范围是 [2, 104]\",\"0 <= Node.val <= 105\",\"注意：本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同\"]},\"359\":{\"h\":\"思路：中序遍历\",\"t\":[\"根据中序遍历结果，二叉搜索树的最小绝对差肯定是相邻的两个节点。因此，定义一个 prev 来存储当前节点的上一个节点情况，并假设初始绝对差为Integer.Max_VALUE 。\",\"递归函数定义：\",\"返回值为void，参数为 root\",\"public void traverse(TreeNode root)\",\"递归终止条件为：如果树为空，直接返回\",\"递归逻辑：\",\"递归左子树\",\"如果 prev 不为空，就要进行比较绝对差，然后进行更新结果\",\"更新 prev 为 root\",\"递归右子树\"]},\"360\":{\"h\":\"关键点\",\"t\":[\"二叉搜索树的中序遍历是一个单调递增的数组\"]},\"361\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { // 二叉搜索树中，左中右的遍历顺序是一个单调递增数组 public int getMinimumDifference(TreeNode root) { traverse(root); return res; } TreeNode prev = null; int res = Integer.MAX_VALUE; public void traverse(TreeNode root) { if (root == null) return; // 左 traverse(root.left); // 中 if (prev != null) { res = Math.min(res, root.val - prev.val); } prev = root; traverse(root.right); } }\",\"复杂度分析\",\"令 n 为二叉树节点个数。\",\"时间复杂度：O(n)，每个节点最多遍历一次\",\"空间复杂度：O(n)，空间复杂度与树的高度有关，最坏情况下为一条链条。\"]},\"362\":{\"h\":\"迭代写法\",\"t\":[\"class Solution { TreeNode pre; Deque<TreeNode> queue; public int getMinimumDifference(TreeNode root) { if(root == null) return 0; queue = new ArrayDeque<>(); TreeNode cur = root; int result = Integer.MAX_VALUE; while (cur != null || !queue.isEmpty()) { if (cur != null) { queue.offerFirst(cur); // 将访问的节点放进栈 cur = cur.left; // 左 }else { cur = queue.pollFirst(); if (pre != null) { // 中 result = Math.min(result, cur.val - pre.val); } pre = cur; cur = cur.right; // 右 } } return result; } }\"]},\"363\":{\"c\":[\"LeetCode\"]},\"364\":{\"c\":[\"二叉树\"]},\"365\":{\"h\":\"541-反转字符串 ii\"},\"366\":{\"h\":\"题目地址(541. 反转字符串 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-string-ii/description/\"]},\"367\":{\"h\":\"题目描述\",\"t\":[\" 给定一个字符串 s 和一个整数 k ，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\",\" 如果剩余字符少于 k 个，则将剩余字符全部反转。\",\" 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\",\" 示例 1：\",\" 输入： s = \\\"abcdefg\\\", k = 2 输出： \\\"bacdfeg\\\" \",\" 示例 2：\",\" 输入： s = \\\"abcd\\\", k = 2 输出： \\\"bacd\\\" \",\" 提示：\",\" 1 <= s.length <= 10 4 \",\" s 仅由小写英文组成 \",\" 1 <= k <= 10 4 \"]},\"368\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"369\":{\"h\":\"思路\",\"t\":[\"使用 left 和 right 两个指针分别指向待反转的范围。\",\"每次翻转完，要更新 left 和 right 的范围。\",\"l = l + 2 * k\",\"r = l + k - 1\",\"指向下一个 2k 范围，然后再进行反转。\"]},\"370\":{\"h\":\"关键点\",\"t\":[\"双指针移动的更新\",\"最后一次翻转，r 有可能越界，因为要取 Math.min(r,n-1)\"]},\"371\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public String reverseStr(String s, int k) { char[] cs = s.toCharArray(); int n = s.length(); // l 和 r 分别指向待反转的范围 // 更新 l 和 r 要注意 不足 k 的情况。 // r 可能会 > n-1，此时应该是最后一次，而 l 还是会在索引范围内， // 极端的情况是 l = n-1，此时不需要翻转。 for (int l = 0; l < n; l = l + 2 * k) { int r = l + k - 1; reverse(cs, l, Math.min(r, n - 1)); } return String.valueOf(cs); } void reverse(char[] cs, int l, int r) { while (l < r) { char c = cs[l]; cs[l] = cs[r]; cs[r] = c; l++; r--; } } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)。遍历的长度为字符串长度n。\",\"空间复杂度：O(n),因为Java语言不需要申请长度为n的数组来存储字符。\"]},\"372\":{\"c\":[\"LeetCode\"]},\"373\":{\"c\":[\"字符串\",\"双指针\"]},\"374\":{\"h\":\"59-螺旋矩阵 II\"},\"375\":{\"h\":\"题目地址(59. 螺旋矩阵 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/spiral-matrix-ii/\"]},\"376\":{\"h\":\"题目描述\",\"t\":[\" 给你一个正整数 n ，生成一个包含 1 到 n 2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\",\" 示例 1：\",\" 输入： n = 3 输出： [[1,2,3], [8,9,4], [7,6,5]] \",\" 示例 2：\",\" 输入： n = 1 输出： [[1]] \",\" 提示：\",\" 1 <= n <= 20 \"]},\"377\":{\"h\":\"前置知识\",\"t\":[\"数组\",\"模拟\"]},\"378\":{\"h\":\"思路\",\"t\":[\"定义好上下左右四个边界 top, bottom, left, right\",\"按照题目进行模拟，从左到右（上边界缩减），从上到下（右边界缩减），从右到左（下边界缩减），从下到上（下边界缩减）\",\"使用 num<=tar 而不是 l<r∣∣t<b 作为迭代条件，是为了解决当 n 为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。 \",\"当 n = 3 时，填充到8时，此时 top==bottom ，就会导致退出循环，中心数字无法在迭代过程中被填充。\"]},\"379\":{\"h\":\"关键点\",\"t\":[\"边界变化条件\",\"循环终止条件\"]},\"380\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[][] generateMatrix(int n) { int left = 0, right = n-1, top = 0, bottom = n-1; int count = 1, target = n * n; int[][] res = new int[n][n]; //for循环中变量定义成i或j的细节：按照通常的思维，i代表行，j代表列 //这样，就可以很容易区分出来变化的量应该放在[][]的第一个还是第二个 //对于变量的边界怎么定义： //从左向右填充：填充的列肯定在[left,right]区间 //从上向下填充：填充的行肯定在[top,bottom]区间 //从右向左填充：填充的列肯定在[right,left]区间 //从下向上填充：填充的行肯定在[bootom,top]区间 //通过上面的总结会发现边界的起始和结束与方向是对应的 while(count <= target){ //从左到右填充，相当于缩小上边界 for(int j = left; j <= right; j++) res[top][j] = count++; //缩小上边界 top++; //从上向下填充，相当于缩小右边界 for(int i = top; i <=bottom; i++) res[i][right] = count++; //缩小右边界 right--; //从右向左填充，相当于缩小下边界 for(int j = right; j >= left; j--) res[bottom][j] = count++; //缩小下边界 bottom--; //从下向上填充，相当于缩小左边界 for(int i = bottom; i >= top; i--) res[i][left] = count++; //缩小左边界 left++; } return res; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)\",\"空间复杂度：O(1)\"]},\"381\":{\"c\":[\"LeetCode\"]},\"382\":{\"h\":\"617-合并二叉树\"},\"383\":{\"h\":\"题目地址(617. 合并二叉树 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/merge-two-binary-trees/description/\"]},\"384\":{\"h\":\"题目描述\",\"t\":[\" 给你两棵二叉树： root1 和 root2 。\",\" 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则， 不为 null 的节点将直接作为新二叉树的节点。\",\" 返回合并后的二叉树。\",\" 注意: 合并过程必须从两个树的根节点开始。\",\" 示例 1：\",\" 输入： root1 = [1,3,2,5], root2 = [2,1,3, null,4, null,7] 输出： [3,4,5,5,4, null,7] \",\" 示例 2：\",\" 输入： root1 = [1], root2 = [1,2] 输出： [2,2] \",\" 提示：\",\" 两棵树中的节点数目在范围 [0, 2000] 内 \",\"-10 4 <= Node.val <= 10 4 \"]},\"385\":{\"h\":\"思路：前序遍历\",\"t\":[\"这道题理解起来很简单，但跟之前不同的是要操作两棵树。\",\"对于相同节点位置，进行值合并。\",\"如果一棵树为空，一个棵不为空，则进行移动即可。\",\"使用「前序遍历」进行递归\",\"递归函数定义：返回值是根点，参数是两棵待合并的树\",\"public TreeNode mergeTrees(TreeNode root1, TreeNode root2)\",\"递归终止条件：树 1 的节点为 null 或者树 2 的节点为 null\",\"单层递归： \",\"将两个树的节点相加后，再赋给树 1 的节点。\",\"再递归的执行两个树的左节点\",\"递归执行两个树的右节点\"]},\"386\":{\"h\":\"代码\",\"t\":[\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if(root1 == null) return root2; if(root2 == null) return root1; // 创建一个新树 TreeNode root = new TreeNode(root1.val+root2.val); root.left = mergeTrees(root1.left,root2.left); root.right = mergeTrees(root1.right,root2.right); return root; } }\",\"复杂度分析\",\"令 n1 为树 1 的节点个数，n2 为树 2 的节点个数。\",\"时间复杂度：O(min(n1,n2)), 两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作。\",\"空间复杂度：O(min(n1,n2))，空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度\"]},\"387\":{\"h\":\"思路：迭代\",\"t\":[\"只要两颗树的左节点都不为 null，就把将他们放入队列中；同理只要两棵树的右节点都不为 null 了，也将他们放入队列中。\",\"不断的从队列中取出节点，把他们相加。\",\"如果树 2 的 left 节点不为 null，而树 1 的 left 节点为 null，则直接将树 2 的 left 赋给树 1\",\"如果树 2 的 right 节点不为 null，而树 1 的 right 节点为 null，则直接将树 2 的 right 赋给树 1\"]},\"388\":{\"h\":\"代码\",\"t\":[\"class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { //如果 t1 和 t2 中，只要有一个是 null，函数就直接返回 if(t1==null || t2==null) { return t1==null? t2 : t1; } java.util.LinkedList<TreeNode> queue = new java.util.LinkedList<TreeNode>(); queue.add(t1); queue.add(t2); while(queue.size()>0) { TreeNode r1 = queue.remove(); TreeNode r2 = queue.remove(); r1.val += r2.val; //如果 r1 和 r2 的左子树都不为空，就放到队列中 //如果 r1 的左子树为空，就把 r2 的左子树挂到 r1 的左子树上 if(r1.left!=null && r2.left!=null){ queue.add(r1.left); queue.add(r2.left); } else if(r1.left==null) { r1.left = r2.left; } //对于右子树也是一样的 if(r1.right!=null && r2.right!=null) { queue.add(r1.right); queue.add(r2.right); } else if(r1.right==null) { r1.right = r2.right; } } return t1; } }\"]},\"389\":{\"c\":[\"LeetCode\"]},\"390\":{\"c\":[\"二叉树\"]},\"391\":{\"h\":\"700-二叉搜索树中的搜索\"},\"392\":{\"h\":\"题目地址(700. 二叉搜索树中的搜索 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/search-in-a-binary-search-tree/submissions/550317560/\"]},\"393\":{\"h\":\"题目描述\",\"t\":[\" 给定二叉搜索树（BST）的根节点 root 和一个整数值 val 。\",\" 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\",\" 示例 1: \",\" 输入： root = [4,2,7,1,3], val = 2 输出： [2,1,3] \",\" 示例 2: \",\" 输入： root = [4,2,7,1,3], val = 5 输出： [] \",\" 提示：\",\" 树中节点数在 [1, 5000] 范围内 \",\" 1 <= Node.val <= 10 7 \",\" root 是二叉搜索树 \",\" 1 <= val <= 10 7 \"]},\"394\":{\"h\":\"思路：中序遍历\",\"t\":[\"对于一棵二叉搜索树来说，中序遍历的结果是一个单调递增的数组。\",\"递归函数定义：\",\"返回值是树的节点，参数是树 root 和目标值 target\",\"public TreeNode searchBST(TreeNode root, int val);\",\"递归终止条件：如果树为空，直接返回 null，如果搜索到叶子节点还没找到，也返回 null\",\"递归函数逻辑 \",\"如果当前节点比 val 小 root.val < val，说明要往 root 的右子树搜索\",\"如果当前节点比 val 大 root.val > val，说明要往 root 的左子树搜索\",\"否则就是当前节点\"]},\"395\":{\"h\":\"关键点\",\"t\":[\"抓住二叉搜索树的特性\",\"左子树的节点都比根节点小\",\"右子树的节点都比根节点大\",\"并且左右子树都是二叉搜索树\"]},\"396\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode searchBST(TreeNode root, int val) { while (root != null) if (val < root.val) root = root.left; else if (val > root.val) root = root.right; else return root; return null; } }\",\"复杂度分析\",\"令 n 为节点个数。\",\"时间复杂度：O(n)，遍历的节点个数\",\"空间复杂度：O(n)，最坏情况下递归需要 O(n) 的栈空间。\"]},\"397\":{\"c\":[\"LeetCode\"]},\"398\":{\"c\":[\"二叉树\"]},\"399\":{\"h\":\"704-二分查找\"},\"400\":{\"h\":\"题目地址(704. 二分查找 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/binary-search/\"]},\"401\":{\"h\":\"题目描述\",\"t\":[\" 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target ，如果目标值存在返回下标，否则返回 -1 。\",\" 示例 1: \",\" 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 \",\" 示例 2: \",\" 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 \",\" 提示：\",\" 你可以假设 nums 中的所有元素是不重复的。\",\" n 将在 [1, 10000] 之间。\",\" nums 的每个元素都将在 [-9999, 9999] 之间。\"]},\"402\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"403\":{\"h\":\"思路\",\"t\":[\"区间定义\",\"当我们选择「左闭右开」的时候，我们可以 0 来定义左边界(left)，而以数组的长度来定义右边界(right)，因此右边界我们是判断不到的。\",\"循环终止条件\",\"在左闭右开的情况，区间不为空，也就意味着 right 至少大于等于 left 。如果超过了这个条件，循环就终止。\",\"判断条件\",\"nums[mid]==target ，mid 就是我们要得到的结果，直接返回\",\"nums[mid]<target，我们应往右边的区间继续寻找，注意 mid 的位置我们是可以取到的，因此我们更新左边界的时候，应该为 left=mid+1\",\"nums[mid]>target，我们应往左边的区间找，而 mid 的位置明显不是答案，但是我们选择的是左闭右开区间，而右开所指向的位置本身就不在我们的候选区间里，所以 right=mid，而不是 right=mid−1.\",\"如果 mid−1 的位置正好是答案，在左闭右开的情况是找不到这个位置的\"]},\"404\":{\"h\":\"关键点\",\"t\":[\"左右区间的闭合\",\"左右区间的比较\"]},\"405\":{\"h\":\"代码\",\"t\":[\"Java Code:\",\" class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left) / 2; if(nums[mid] > target){ right = mid; }else if(nums[mid] < target) { left = mid +1 ; }else{ return mid; } } return -1; }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(logn)\",\"空间复杂度：O(1)\"]},\"406\":{\"h\":\"思路改进\",\"t\":[\"在 nums[mid]<target 和 nums[mid]==target 是可以合并起来的。当区间长度为 1 时，剩下的就是答案，由于 nums [mid] 可能等于答案，因此我们不能跳过这个 mid 的位置\",\"public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left)/2; if(nums[mid] > target){ right = mid; }else{ left = mid; } } if(nums[l] == target){ return l; } return -1; }\"]},\"407\":{\"h\":\"左闭右必区间\",\"t\":[\"public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left <= right){ // #1 int mid = (right + left) / 2; if(nums[mid] == target){ return mid; }else if(nums[mid] < target){ left = mid + 1; // #2 }else{ right = mid - 1; // #3 } } return -1; }\"]},\"408\":{\"c\":[\"LeetCode\"]},\"409\":{\"c\":[\"数组\",\"二分查找\"]},\"410\":{\"h\":\"707-设计链表\"},\"411\":{\"h\":\"题目地址(707. 设计链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/design-linked-list/description/\"]},\"412\":{\"h\":\"题目描述\",\"t\":[\" 你可以选择使用单链表或者双链表，设计并实现自己的链表。\",\" 单链表中的节点应该具备两个属性： val 和 next 。 val 是当前节点的值， next 是指向下一个节点的指针/引用。\",\" 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\",\" 实现 MyLinkedList 类：\",\" MyLinkedList() 初始化 MyLinkedList 对象。\",\" int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\",\" void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\",\" void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\",\" void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\",\" void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\",\" 示例：\",\" 输入 [\\\"MyLinkedList\\\", \\\"addAtHead\\\", \\\"addAtTail\\\", \\\"addAtIndex\\\", \\\"get\\\", \\\"deleteAtIndex\\\", \\\"get\\\"] [[], [1], [3], [1, 2], [1], [1], [1]] 输出 [null, null, null, null, 2, null, 3] 解释 MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // 链表变为 1-> 2-> 3 myLinkedList.get(1); // 返回 2 myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-> 3 myLinkedList.get(1); // 返回 3 \",\" 提示：\",\" 0 <= index, val <= 1000 \",\" 请不要使用内置的 LinkedList 库。\",\" 调用 get 、 addAtHead 、 addAtTail 、 addAtIndex 和 deleteAtIndex 的次数不超过 2000 。\"]},\"413\":{\"h\":\"前置知识\",\"t\":[\"链表结果\",\"链表基本操作\"]},\"414\":{\"h\":\"思路: 单链表实现\",\"t\":[\"内部定义一个 Node 对象当成链表中的节点\",\"由于需要根据索引来查找节点，因此提供查询节点的方法 getNode()\"]},\"415\":{\"h\":\"关键点\",\"t\":[\"插入/删除节点，需要同时更新 size\"]},\"416\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyLinkedList { // 单向链表 class Node { int val; Node next; public Node(int val) { this.val = val; } } Node _head = new Node(-1); int size = 0; public MyLinkedList() { _head.next = null; } public int get(int index) { Node ret = getNode(index); return ret == null ? -1 : ret.val; } public void addAtHead(int val) { Node newNode = new Node(val); newNode.next = _head.next; _head.next = newNode; size++; } public void addAtTail(int val) { Node newNode = new Node(val); newNode.next = null; if (size == 0) { _head.next = newNode; } else { // 头节点 Node head = _head.next; // 遍历找到最后一个节点 while (head.next != null) { head = head.next; } // 最后一个节点的后驱节点是新节点 head.next = newNode; } size++; } public void addAtIndex(int index, int val) { if (index > size) { return; } if (index == size) { addAtTail(val); return; } Node newNode = new Node(val); Node indexNode = getNode(index - 1); newNode.next = indexNode.next; indexNode.next = newNode; size++; } public void deleteAtIndex(int index) { if (index >= size) { return; } if (index == 0) { _head.next = _head.next.next; } else { Node indexPreNode = getNode(index - 1); indexPreNode.next = indexPreNode.next.next; } size--; } Node getNode(int index) { if (index >= size) { return null; } Node head = _head; for (int i = 0; i <= index; i++) { head = head.next; } return head; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index, val); * obj.deleteAtIndex(index); */\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(n)\",\"空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"417\":{\"h\":\"思路：双链表实现\",\"t\":[\"实现双向链表，即每个节点要存储本身的值，「后继节点」和「前驱节点」。除此之外，需要一个「哨兵节点」作为头节点 head 和一个「哨兵节点」作为尾节点 tail。\"]},\"418\":{\"h\":\"关键点\",\"t\":[\"在遍历过程过程，从前往后遍历（当索引小于链表长度的一半时）还是从后往前遍历来优化查找效率。\",\"遍历时，每移动一次就减小 index 的值，当 index 为 0 时，说明找到了目标节点并返回。如果遍历结束没有找到，则返回 null。\"]},\"419\":{\"h\":\"代码\",\"t\":[\"class MyLinkedList { class Node { Node prev, next; int val; Node (int _val) { val = _val; } } Node head = new Node(-1), tail = new Node(-1); int size = 0; public MyLinkedList() { head.next = tail; tail.prev = head; } public int get(int index) { Node node = getNode(index); return node == null ? -1 : node.val; } public void addAtHead(int val) { Node node = new Node(val); node.next = head.next; node.prev = head; head.next.prev = node; head.next = node; size++; } public void addAtTail(int val) { Node node = new Node(val); node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; size++; } public void addAtIndex(int index, int val) { if (index > sz) return ; if (index <= 0) { addAtHead(val); } else if (index == sz) { addAtTail(val); } else { Node node = new Node(val), cur = getNode(index); node.next = cur; node.prev = cur.prev; cur.prev.next = node; cur.prev = node; size++; } } public void deleteAtIndex(int index) { Node cur = getNode(index); if (cur == null) return ; cur.next.prev = cur.prev; cur.prev.next = cur.next; size--; } Node getNode(int index) { boolean isLeft = index < size / 2; if (!isLeft) index = size - index - 1; Node cur = isLeft ? head.next : tail.prev; for (; cur != tail && cur != head; cur = isLeft ? cur.next : cur.prev) { if (index-- == 0) return cur; } return null; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。\",\"空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"420\":{\"c\":[\"LeetCode\"]},\"421\":{\"c\":[\"链表\"]},\"422\":{\"h\":\"977-有序数组的平方\"},\"423\":{\"h\":\"题目地址(977. 有序数组的平方 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/squares-of-a-sorted-array/description/\"]},\"424\":{\"h\":\"题目描述\",\"t\":[\" 给你一个按 非递减顺序 排序的整数数组 nums ，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\",\" 示例 1：\",\" 输入： nums = [-4,-1,0,3,10] 输出： [0,1,9,16,100] 解释： 平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] \",\" 示例 2：\",\" 输入： nums = [-7,-3,2,3,11] 输出： [4,9,9,49,121] \",\" 提示：\",\" 1 <= nums.length <= 10 4 \",\"-10 4 <= nums [i] <= 10 4 \",\" nums 已按 非递减顺序 排序 \",\" 进阶：\",\" 请你 设计时间复杂度为 O(n) 的算法解决本问题 \"]},\"425\":{\"h\":\"前置知识\",\"t\":[\"双指针\"]},\"426\":{\"h\":\"思路\",\"t\":[\"使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。\"]},\"427\":{\"h\":\"关键点\",\"t\":[\"平方大小的比较 = 绝对值大小的比较\",\"双指针指向相等时，任意放一个进入结果数组即可。\"]},\"428\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] sortedSquares(int[] nums) { // 非递减 // 在正数，越大，平方也就越大 // 在负数，越小，平方越大 // 采用双指针，头尾比较 int left = 0; int right = nums.length - 1; int[] ret = new int[nums.length]; int index = right; while (left < right) { // 当left == right时，退出循环 if (Math.abs(nums[left]) < Math.abs(nums[right])) { ret[index--] = nums[right] * nums[right]; right--; } else if (Math.abs(nums[left]) > Math.abs(nums[right])) { ret[index--] = nums[left]*nums[left]; left++; }else if(Math.abs(nums[left]) == Math.abs(nums[right])){ ret[index--] = nums[right]*nums[right]; right--; } } ret[index] = nums[left]*nums[left]; return ret; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，除了存储答案的数组以外，我们只需要维护常量空间。\"]},\"429\":{\"c\":[\"LeetCode\"]},\"430\":{\"c\":[\"数组\",\"二分查找\"]},\"431\":{\"h\":\"98-验证二叉搜索树\"},\"432\":{\"h\":\"题目地址(98. 验证二叉搜索树 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/validate-binary-search-tree/description/\"]},\"433\":{\"h\":\"题目描述\",\"t\":[\" 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\",\" 有效 二叉搜索树定义如下：\",\" 节点的左 \",\" 子树 \",\" 只包含 小于 当前节点的数。\",\" 节点的右子树只包含 大于 当前节点的数。\",\" 所有左子树和右子树自身必须也是二叉搜索树。\",\" 示例 1：\",\" 输入： root = [2,1,3] 输出： true \",\" 示例 2：\",\" 输入： root = [5,1,4, null, null,3,6] 输出： false 解释： 根节点的值是 5 ，但是右子节点的值是 4 。 \",\" 提示：\",\" 树中节点数目范围在 [1, 10 4 ] 内 \",\"-2 31 <= Node.val <= 2 31 - 1 \"]},\"434\":{\"h\":\"思路：中序遍历+双指针\",\"t\":[\"遇到二叉搜索树，使用中序遍历，即「左中右」的遍历顺序\",\"定义一个最小值 prev 当成是当前节点遍历的上一个节点值，目的是用来判断是否符合二叉搜索树的定义\",\"递归终止条件：\",\"如果树为空，直接返回 true。（空树符合二叉搜索树的定义）\",\"如果当前节点的 val <= prev 即 root.val <= prev, 说明左子树是不符合二叉搜索树，直接返回 false\",\"如果提前发现左子树不符合二叉搜索树的定义，也提前返回 false\",\"在「中节点」处理的时候，将 prev 更新为当前节点的值。如果是第一次比较的情况，比较的节点也是符合保证 > prev的\",\"然后再遍历右子树。\"]},\"435\":{\"h\":\"关键点\",\"t\":[\"定义一个前节点来做判断，并且要做好更新的\"]},\"436\":{\"h\":\"代码1\",\"t\":[\" /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ // 简洁实现·中序遍历 class Solution { private long prev = Long.MIN_VALUE; public boolean isValidBST(TreeNode root) { if (root == null) { return true; } if (!isValidBST(root.left)) { return false; } if (root.val <= prev) { // 不满足二叉搜索树条件 return false; } prev = root.val; return isValidBST(root.right); } }\",\"复杂度分析\",\"令 n 为二叉树的节点个数。\",\"时间复杂度：O(n)， 在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。\",\"空间复杂度：O(n)，递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。\"]},\"437\":{\"h\":\"代码2\",\"t\":[\"class Solution { private boolean isValidBSTUtil(TreeNode node, long min, long max) { if (node == null) return true; // 正确的递归终止条件 // 检查当前节点的值是否在允许的范围内 if (node.val <= min || node.val >= max) return false; // 递归地检查左子树和右子树，同时更新限制条件 return isValidBSTUtil(node.left, min, node.val) && isValidBSTUtil(node.right, node.val, max); } public boolean isValidBST(TreeNode root) { // 从最小值Long.MIN_VALUE到最大值Long.MAX_VALUE开始递归 return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE); } }\"]},\"438\":{\"c\":[\"LeetCode\"]},\"439\":{\"c\":[\"二叉树\"]},\"440\":{\"h\":\"LeetCode\"},\"441\":{\"h\":\"我们的目标是刷穿LeetCode\"},\"442\":{\"h\":\"各种排序算法\"},\"443\":{\"h\":\"总览\",\"t\":[\"稳定排序： 若两个元素相等：a = b，排序前 a 排在 b 前面，排序后 a 仍然在 b 后面，称为稳定排序。\",\"不稳定排序： 若两个元素相等：a = b，排序前 a 排在 b 前面，排序后 a 有可能出现在 b 后面，称为不稳定排序。\",\"名称\",\"时间复杂度\",\"空间复杂度\",\"排序方式\",\"稳定性\",\"冒泡排序\",\"O(n^2)\",\"O(1)\",\"内部排序\",\"稳定\",\"选择排序\",\"O(n^2)\",\"O(1)\",\"内部排序\",\"不稳定\",\"插入排序\",\"O(n^2)\",\"O(1)\",\"内部排序\",\"稳定\",\"希尔排序\",\"O(nlogn)\",\"O(n)\",\"内部排序\",\"不稳定\",\"归并排序\",\"O(nlogn)\",\"O(nlogn)\",\"外部排序\",\"稳定\",\"快速排序\",\"O(nlogn)\",\"O(nlogn)\",\"内部排序\",\"不稳定\",\"堆排序\",\"O(nlogn)\",\"O(1)\",\"内部排序\",\"不稳定\",\"计数排序\",\"O(n+m)\",\"O(m)\",\"外部排序\",\"稳定\",\"桶排序\",\"O(n+m)\",\"O(n+m)\",\"外部排序\",\"稳定\",\"基数排序\",\"O(n+m)\",\"O(n+m)\",\"外部排序\",\"稳定\"]},\"444\":{\"h\":\"冒泡排序\"},\"445\":{\"h\":\"概念及演示\",\"t\":[\"步骤解析：\",\"将相邻的两个元素 a, b 进行比较，如果 a 比 b 大，那么就交换 a 和 b 的位置。当第一轮遍历结束后，最后一个元素就是最大的元素。\",\"重复上一个过程，找出第 n 大的元素，直到剩下一个数字。\"]},\"446\":{\"h\":\"代码模板\",\"t\":[\"public void bubbleSort(int[] array) { if (array == null || array.length == 0) { return; } int n = array.length; boolean swapped; for (int i = 0; i < n - 1; i++) { swapped = false; for (int j = 0; j < n - i - 1; j++) { if (array[j] > array[j + 1]) { // 交换 array [j] 和 array [j + 1] int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; swapped = true; } } // 如果在这一轮排序中没有交换过，说明数组已经有序，可以提前结束 if (!swapped) { break; } } }\",\"在数据内部进行排序，无需额外的存储空间\",\"当数组正序时，执行效率最高。当数组倒序时，执行效率最低，每次都要进行交换。\"]},\"447\":{\"h\":\"选择排序\"},\"448\":{\"h\":\"概念及演示\",\"t\":[\"每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。\",\"把第一个没有排序过的元素设置为最小值\",\"遍历后续的元素 \",\"如果元素 < 「现在的最小值」，则将元素设置为「新的最小值」\",\"将最小值和第一个没有排序的元素进行交换\"]},\"449\":{\"h\":\"代码模板\",\"t\":[\"public void selectionSort(int[] array) { if (array == null || array.length == 0) { return; } int n = array.length; for (int i = 0; i < n - 1; i++) { // 找到从 i 到 n-1 中最小的元素的索引 int minIndex = i; for (int j = i + 1; j < n; j++) { if (array[j] < array[minIndex]) { minIndex = j; } } // 将找到的最小元素交换到当前位置 i int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } }\"]},\"450\":{\"h\":\"插入排序\",\"t\":[\"通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。\",\"算法步骤：\",\"将第一个元素标记为已排序\",\"对于每一个未排序的元素 X，位置设为 i\",\"从 j = i - 1 的位置开始「从后向前」扫描，如果不满足条件 j >= 0 && array[j] > current\",\"就将未排序元素插入到 j+1 位置中。\"]},\"451\":{\"h\":\"代码模板\",\"t\":[\"public static void insertionSort(int[] array) { if (array == null || array.length <= 1) { return; } // 从第二个元素开始遍历，因为第一个元素可以认为是已排序的 for (int i = 1; i < array.length; i++) { int current = array[i]; int j = i - 1; // 将当前元素与已排序部分的元素比较，找到合适的位置插入 while (j >= 0 && array[j] > current) { array[j + 1] = array[j]; j--; } // 插入当前元素到找到的位置 array[j + 1] = current; } }\"]},\"452\":{\"h\":\"✨希尔排序\",\"t\":[\"希尔排序是插入排序的一种优化版本\",\"希尔排序的基本思想是将原始数据分成多个子序列，这些子序列的元素间隔相同，然后对每个子序列进行插入排序。随着增量逐渐减小，子序列的长度逐渐增加，直到增量为1，此时整个数组成为一个子序列，算法退化为普通的插入排序。\",\"public static void shellSort(int[] array){ int len = array.length; int temp, gap = len / 2; // 初始增量 while (gap > 0) { for (int i = gap; i < len; i++) { temp = array[i]; int preIndex = i - gap; // 在子序列进行插入排序 while (preIndex >= 0 && array[preIndex] > temp) { array[preIndex + gap] = array[preIndex]; preIndex -= gap; } array[preIndex + gap] = temp; } gap /= 2; } }\"]},\"453\":{\"h\":\"✨归并排序\",\"t\":[\"采用分而治之的思想，将数组分成两半，分别对这两半进行排序，然后将排序好的两半合并在一起。\",\"// 归并排序的主函数 public void mergeSort(int[] array, int left, int right) { if (left < right) { // 找到中间索引 int middle = left + (right - left) / 2; // 分别对左右两半进行排序 mergeSort(array, left, middle); mergeSort(array, middle + 1, right); // 合并排序好的两半 merge(array, left, middle, right); } } private static void merge(int[] array, int left, int middle, int right) { // 临时数组，用于存放合并后的有序元素 int[] temp = new int[right - left + 1]; int i = left; // 左半部分的起始索引 int j = middle + 1; // 右半部分的起始索引 int k = 0; // 临时数组的索引 // 合并过程 while (i <= middle && j <= right) { if (array[i] <= array[j]) { temp[k++] = array[i++]; } else { temp[k++] = array[j++]; } } // 复制左半部分剩余的元素 while (i <= middle) { temp[k++] = array[i++]; } // 复制右半部分剩余的元素 while (j <= right) { temp[k++] = array[j++]; } // 将临时数组中的元素复制回原数组 for (i = left, k = 0; i <= right; i++, k++) { array[i] = temp[k]; } }\"]},\"454\":{\"h\":\"✨快速排序\",\"t\":[\"快速排序，和二分查找的思想很像，都是先将数据一份为二然后再逐个处理。\",\"// 主函数，对数组array从index left到index right的部分进行快速排序 public void quickSort(int[] array, int left, int right) { if (left < right) { // 找到分区的索引 int partitionIndex = partition(array, left, right); // 对左边的子数组进行快速排序 quickSort(array, left, partitionIndex - 1); // 对右边的子数组进行快速排序 quickSort(array, partitionIndex + 1, right); } } // 进行分区操作的函数 private int partition(int[] array, int left, int right) { // 选择最右侧的元素作为基准值（pivot） int pivot = array[right]; int i = (left - 1); // i用来记录比基准值小的区域的最后一个元素的索引 for (int j = left; j < right; j++) { // 如果当前元素小于或等于pivot if (array[j] <= pivot) { i++; // 交换array[i]和array[j] int temp = array[i]; array[i] = array[j]; array[j] = temp; } } // 交换pivot到它最终的位置 int temp = array[i + 1]; array[i + 1] = array[right]; array[right] = temp; return i + 1; }\"]},\"455\":{\"h\":\"✨堆排序\",\"t\":[\"而根据排序的方向又分为大顶堆和小顶堆：\",\"大顶堆：每个节点值都大于或等于子节点的值，在堆排序中用做升序排序。\",\"小顶堆：每个节点值都小于或等于子节点的值，在堆排序中用做降序排序。\",\"/** * 堆排序 * @param array */ public static int[] heapSort(int[] array){ int size = array.length; // 先将数据放入堆中 for (int i = (int) Math.floor(size / 2); i >= 0; i--) { heapTopMove(array, i, size); } // 堆顶位置调整 for(int i = size - 1; i > 0; i--) { swapNum(array, 0, i); size--; heapTopMove(array, 0,size); } return array; } /** * 堆顶位置维护 * @param array * @param i * @param size */ public static void heapTopMove(int[] array,int i,int size){ int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left < size && array[left] > array[largest]) { largest = left; } if (right < size && array[right] > array[largest]) { largest = right; } if (largest != i) { swapNum(array, i, largest); heapTopMove(array, largest, size); } } /** * 比较交换 * @param array * @param left * @param right */ public static void swapNum(int[] array,int left,int right){ int temp = array[left]; array[left] = array[right]; array[right] = temp; }\"]},\"456\":{\"h\":\"计数排序\",\"t\":[\"将数据转化为键存储在额外的数组空间里。\",\"找出待排序数组中最大和最小的元素\",\"统计数组中每个值为i的元素出现的次数，存入数组C的第i项\",\"然后反向输出\",\"/** * 计数排序 * @param array */ public static void countSort(int[] array){ int bucketLen = getMaxValue(array) + 1; int[] bucket = new int[bucketLen]; // 统计每个值出现的次数 for (int value : array) { bucket[value]++; } // 反向填充数组 int sortedIndex = 0; for (int j = 0; j < bucketLen; j++) { while (bucket[j] > 0) { array[sortedIndex++] = j; bucket[j]--; } } } /** * 获取最大值 * @param arr * @return */ private static int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue < value) { maxValue = value; } } return maxValue; }\"]},\"457\":{\"h\":\"桶排序\",\"t\":[\"桶排序算是计数排序的一个加强版，它利用特定函数的映射关系，将属于一定范围内的数据，放到一个桶里，然后对每个桶中的数据进行排序，最后再将排序好的数据拼接起来。\",\"设置一个合适长度的数组作为空桶\",\"遍历数据，将数据都放到指定的桶中，分布的越均匀越好；\",\"对每个非空的桶里的数据进行排序；\",\"将每个桶中排序好的数据拼接在一起。\",\" /** * 桶排序 * @param arr * @param bucketSize * @return */ private static int[] bucketSort(int[] arr, int bucketSize){ if (arr.length == 0) { return arr; } int minValue = arr[0]; int maxValue = arr[0]; // 计算出最大值和最小值 for (int value : arr) { if (value < minValue) { minValue = value; } else if (value > maxValue) { maxValue = value; } } // 根据桶的长度以及数据的最大值和最小值，计算出桶的数量 int bucketCount = (int) Math.floor((maxValue - minValue) / bucketSize) + 1; int[][] buckets = new int[bucketCount][0]; // 利用映射函数将数据分配到各个桶中 for (int i = 0; i < arr.length; i++) { int index = (int) Math.floor((arr[i] - minValue) / bucketSize); // 将数据填充到指定的桶中 buckets[index] = appendBucket(buckets[index], arr[i]); } int arrIndex = 0; for (int[] bucket : buckets) { if (bucket.length <= 0) { continue; } // 对每个桶进行排序，这里使用了插入排序 InsertSort.insertSort(bucket); for (int value : bucket) { arr[arrIndex++] = value; } } return arr; } /** * 扩容，并追加数据 * * @param array * @param value */ private static int[] appendBucket(int[] array, int value) { array = Arrays.copyOf(array, array.length + 1); array[array.length - 1] = value; return array; }\"]},\"458\":{\"h\":\"基数排序\",\"t\":[\"将整数按位拆分成不同的数字，然后再按照位数排序，先按低位排序，进行收集，再按高位排序，再进行收集，直到最高位。\",\"/** * 基数排序 * @param array */ public static void radixSort(int[] array){ // 获取最高位 int maxDigit = getMaxDigit(array); int mod = 10; int dev = 1; for (int i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) { // 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10) int[][] counter = new int[mod * 2][0]; // 计数排序 for (int j = 0; j < array.length; j++) { int bucket = ((array[j] % mod) / dev) + mod; counter[bucket] = appendBucket(counter[bucket], array[j]); } // 反向填充数组 int pos = 0; for (int[] bucket : counter) { for (int value : bucket) { array[pos++] = value; } } } } /** * 获取最高位数 */ private static int getMaxDigit(int[] arr) { int maxValue = getMaxValue(arr); return getNumLength(maxValue); } /** * 获取最大值 * @param arr * @return */ private static int getMaxValue(int[] arr) { int maxValue = arr[0]; for (int value : arr) { if (maxValue < value) { maxValue = value; } } return maxValue; } /** * 获取整数的位数 * @param num * @return */ protected static int getNumLength(long num) { if (num == 0) { return 1; } int lenght = 0; for (long temp = num; temp != 0; temp /= 10) { lenght++; } return lenght; } /** * 扩容，并追加数据 * * @param array * @param value */ private static int[] appendBucket(int[] array, int value) { array = Arrays.copyOf(array, array.length + 1); array[array.length - 1] = value; return array; }\"]},\"459\":{\"c\":[\"排序算法\"]},\"460\":{\"h\":\"哈希表基础理论\"},\"461\":{\"h\":\"哈希表是什么\",\"t\":[\"通过建立键 key 与值 value 之间的映射，实现高效的元素查询。就像每一个人的身份证对应一个人一样。\",\"数组\",\"链表\",\"哈希表\",\"查找元素\",\"O(1)\",\"O(n)\",\"O(1)\",\"添加元素\",\"O(n)\",\"O(1)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(1)\",\"O(1)\"]},\"462\":{\"h\":\"哈希函数\",\"t\":[\"通过某种算法将 value 映射到 key上。\",\"比如\",\"当我们使用数组实现哈希表时，会将所有的key能映射到数组上对应的索引，数组元素则是对应的value\",\"index = hash(key) % cap\",\"图片来自：hello-algo\"]},\"463\":{\"h\":\"哈希冲突\",\"t\":[\"理论上一定存在“多个输入对应相同输出”的情况，将这种情况视为“哈希冲突”。\"]},\"464\":{\"h\":\"拉链法\",\"t\":[\"冲突的位置存储在链表中。\"]},\"465\":{\"h\":\"线性探测法\",\"t\":[\"在冲突的地方继续往前查询，直到查询到不冲突，就放入对应的索引中。\"]},\"466\":{\"c\":[\"LeetCode\"]},\"467\":{\"c\":[\"哈希表\"]},\"468\":{\"h\":\"回溯算法理论基础\"},\"469\":{\"h\":\"是什么\",\"t\":[\"回溯算法（BackTracing）是一种搜索方法，简单理解是一种简单粗暴的试错搜索。\",\"回溯问题可以抽象为「树形」问题，递归向下处理和获取结果，递归向上撤销结果。\",\"回溯函数也就是递归函数，指的都是一个函数。\"]},\"470\":{\"h\":\"解决什么问题\",\"t\":[\"回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案。在一些问题上通过for循环暴力枚举是不可行的，但回溯却可以解决问题。\",\"回溯法，一般可以解决如下几种问题：\",\"组合问题：N个数里面按一定规则找出k个数的集合\",\"切割问题：一个字符串按一定规则有几种切割方式\",\"子集问题：一个N个数的集合里有多少符合条件的子集\",\"排列问题：N个数按一定规则全排列，有几种排列方式\",\"棋盘问题：N皇后，解数独等等\"]},\"471\":{\"h\":\"如何理解以及模板\",\"t\":[\"回溯法解决的问题都可以抽象为「树形结构」\",\"集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\",\"回溯三要素\",\"函数返回值一般为void，参数根据情况而定\",\"终止条件\",\"搜索过程\",\"void backtracking(参数) { if (终止条件) { 存放结果; return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } }\"]},\"472\":{\"c\":[\"leetcode\"]},\"473\":{\"c\":[\"回溯\"]},\"474\":{\"h\":\"常见集合-ArrayList\"},\"475\":{\"h\":\"数组\",\"t\":[\"连续的内存空间\",\"存储相同的数据类型数据\",\"线性\",\"通过寻址公式，达到快速访问的目的 a[i]=baseAddr+i∗dataTypeSize\",\"baseAddr: 数组首地址\",\"dataTypeSize: 数据类型的大小\",\"为什么数组索引从 0 开始？为什么不是从 1 开始？\",\"这是一种计算的便利，只不是把上面的 i 变成 i−1\"]},\"476\":{\"h\":\"操作时间复杂度\",\"t\":[\"n 为数组的元素个数\",\"查找：O(1)\",\"插入、删除：最好情况下是 O(1), 最坏情况下是 O(n)，平均下来时间复杂度为 O(n)\"]},\"477\":{\"h\":\"源码分析\"},\"478\":{\"h\":\"成员变量\",\"t\":[\" /** * 默认初始容量 */ private static final int DEFAULT_CAPACITY = 10; /** * 用于空实例的共享空数组实例 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 用于默认大小的空实例的共享空数组实例。我们将其与 EMPTY_ELEMENTDATA 区分开来，以便知道添加第一个元素时要膨胀多少。 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * 存储 ArrayList 元素的数组缓冲区。 * ArrayList 的容量就是这个数组缓冲区的长度。任何带有 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的空数组列表将在添加第一个元素时扩展为 DEFAULT_CAPACITY。 */ transient Object[] elementData; // non-private to simplify nested class access /** * 数组列表的大小(包含的元素数量)。 * */ private int size;\"]},\"479\":{\"h\":\"构造函数\",\"t\":[\"构造函数有三种：根据初始容量，默认方式，根据集合\",\"public ArrayList(int initialCapacity) {} public ArrayList() {} public ArrayList(Collection<? extends E> c) {}\"]},\"480\":{\"h\":\"根据初始容量来创建\",\"t\":[\"public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\\\"Illegal Capacity: \\\"+ initialCapacity); } }\",\"根据容量给 elementData 赋值。如果 initialCapacity = 0 ，则 EMPTY_ELEMENTDATA 和 elementData 一样\"]},\"481\":{\"h\":\"无参构造函数\",\"t\":[\"public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; }\",\"由于不需要传初始容量，所以 elementData 实际就是一个默认初始容量的空数组实例 DEFAULTCAPACITY_EMPTY_ELEMENTDATA。\",\"当往数组添加第一个元素时，elementData 就会直接扩容到默认初始容量 DEFAULT_CAPACITY\"]},\"482\":{\"h\":\"根据集合的构造函数\",\"t\":[\"public ArrayList(Collection<? extends E> c) { Object[] a = c.toArray(); if ((size = a.length) != 0) { if (c.getClass() == ArrayList.class) { elementData = a; } else { elementData = Arrays.copyOf(a, size, Object[].class); } } else { // replace with empty array. elementData = EMPTY_ELEMENTDATA; } }\",\"如果传进来的集合为空，即与 ArrayList<>(0) 的方式一致。\",\"如果集合的类型是 ArrayList 类型，则直接进行 赋值。否则就将集合中元素复制到 elementData 中\"]},\"483\":{\"h\":\"总结\",\"t\":[\"本质上就是赋值给 elementData，或者将元素复制添加到 elementData 中。\"]},\"484\":{\"h\":\"添加操作（第一次扩容）\",\"t\":[\"当执行下面两行代码时\",\"List<Integer> list = new ArrayList<>(); list.add(1);\",\"根据上面的构造函数可知，此时有\",\"this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\",\"public boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; }\",\"ensureCapacityInternal() 函数的作用是确保内部容量大小问题，如果容量不足则需要扩容。\",\"private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); }\",\"其实是相当于调用 calculateCapacity(this.elementData,1)，因此最终会返回 DEFAULT_CAPACITY。\",\"private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; }\",\"经过上一步，实际上是调用 ensureExplicitCapacity(10)，所以最终会进入 grow() 函数进行国荣\",\"private void ensureExplicitCapacity(int minCapacity) { modCount++; if (minCapacity - elementData.length > 0) grow(minCapacity); }\",\"private void grow(int minCapacity) { int oldCapacity = elementData.length; // 0 int newCapacity = oldCapacity + (oldCapacity >> 1); // 0 if (newCapacity - minCapacity < 0) newCapacity = minCapacity; // 10 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); }\",\"综上所述，在调用 ensureCapacityInternal(size+1) 后 相当于调用 ensureCapacityInternal(1)。最终是使 elementData 数组容量缓冲区的容量扩容为 DEFAULT_CAPACITY ，也就是 10。\",\"最后在将元素放进数组中。\"]},\"485\":{\"h\":\"添加操作（第二次扩容）\",\"t\":[\"当调用 add(E e) 时，会调用 ensureCapacityInternal(size + 1), 最终会去调用 ensureExplicitCapacity(size+1) 而触发 grow() 操作\",\"private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length > 0) grow(minCapacity); }\",\"当 minCapacity = 11 , elementData.length = 10 时，会发生第二次 grow()\",\"private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity >> 1); // 原来的 1.5 倍 if (newCapacity - minCapacity < 0) newCapacity = minCapacity; // 第一次扩容的数组长度 if (newCapacity - MAX_ARRAY_SIZE > 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); }\",\"此时根据代码，会发现 newCapacity 是 oldCapacity 的 1.5 倍，即 elementData 的容量变成原来的 1.5 倍\"]},\"486\":{\"h\":\"总结\",\"t\":[\"ArrayList 的实现原理是什么\",\"ArrayList 底层是用动态数组实现\",\"初始容量为 0，当第一次添加容量时，才会初始化容量为 10\",\"在进行扩容的时候，容量为原来的 1.5 倍，每次扩容都需要拷贝数组\",\"在添加数据的时候\",\"确保数组长度已使用长度(size)+1 之后足够存放下一个数据\",\"计算数组的容量，如果当前数组已使用长度+1 > 当前数组长度，就会发生扩容\",\"新增的数据位置是 size\",\"添加成功返回 true\",\"数组转换为 List，以及 List 转换为数组\",\"String[] array = {\\\"a\\\", \\\"b\\\", \\\"c\\\"}; List<String> list = Arrays.asList(array);\",\"String[] array = {\\\"a\\\", \\\"b\\\", \\\"c\\\"}; List<String> list = new ArrayList<>(); Collections.addAll(list, array);\",\"String[] array = {\\\"a\\\", \\\"b\\\", \\\"c\\\"}; List<String> list = Arrays.stream(array).collect(Collectors.toList());\",\"List<String> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"b\\\"); list.add(\\\"c\\\"); Object[] array = list.toArray();\",\"List<String> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"b\\\"); list.add(\\\"c\\\"); String[] array = Arrays.copyOf(list.toArray(), list.size(), String[].class);\",\"List<String> list = new ArrayList<>(); list.add(\\\"a\\\"); list.add(\\\"b\\\"); list.add(\\\"c\\\"); String[] array = list.stream().toArray(String[]::new);\",\"使用 Arrays.asList 转换为 List 后，如果修改了数组内容，list 受影响嘛？\",\"String[] array = {\\\"a\\\", \\\"b\\\", \\\"c\\\"}; List<String> list = Arrays.asList(array);\",\"array 数组被包装成 java.util.Arrays.ArrayList 内部类，当数组内容发生改变时，list会受到影响。\",\"List 用 toArray 转数组后，如果修改了 List 内容，数组会受影响嘛？\",\"在底层里，进行了数组的拷贝，影响的只是内部的数组，跟外面的数组没有关系。\"]},\"487\":{\"c\":[\"Collection\"]},\"488\":{\"c\":[\"Java\",\"ArrayList\"]},\"489\":{\"h\":\"常见集合-HashMap\"},\"490\":{\"h\":\"了解 HashMap\",\"t\":[\"哈希表的存在是为了解决能通过 O(1)时间复杂度直接索引到指定元素。\",\"一个哈希表（hash table、hash map）是一种实现关联数组的抽象数据结构，该结构将键通过哈希计算映射到值。\",\"键 -> 哈希计算 -> 位置\",\"位置 -> 值\",\"HashMap 的实现原理\",\"HashMap 的 jdk1.7 和 jdk1.8 有什么区别\"]},\"491\":{\"h\":\"HashCode 为什么使用 31 作为乘数？\",\"t\":[\"public int hashCode() { int h = hash; if (h == 0 && value.length > 0) { char val[] = value; for (int i = 0; i < value.length; i++) { h = 31 * h + val[i]; } hash = h; } return h; }\",\"循环公式为：s[0]∗31(n−1)+s[1]∗31(n−2)+...+s[n−1]\",\"31 是一个奇质数(不能被2整除的最小素数），如果选择偶数会导致乘积运算时数据溢出。\",\"在二进制中，25是32，那么 31∗i==(i<<5)−i，乘积运算可以使用位移提升性能。\",\"可以通过实践。\",\"准备一个单词表，定义一个不同参数的 hashcode 函数\",\"public static Integer hashCode(String str, Integer multiplier) { int hash = 0; for (int i = 0; i < str.length(); i++) { hash = multiplier * hash + str.charAt(i); } return hash; }\",\"定义一个函数，计算所有不同参数下的所有hashcode情况\",\"public static List<RateInfo> collisionRateList(Set<String> strList, Integer... multipliers) { // 结果存放 List<RateInfo> rateInfoList = new ArrayList<>(); for (Integer multiplier : multipliers) { // 每个循环存在不同的参数 List<Integer> hashCodeList = new ArrayList<>(); for (String str : strList) { Integer hashCode = hashCode(str, multiplier); hashCodeList.add(hashCode); } // 计算当前参数下的hash碰撞概率 rateInfoList.add(hashCollisionRate(multiplier, hashCodeList)); } return rateInfoList; }\",\"定义一个函数计算hash碰撞概率\",\"/** * 计算Hash碰撞概率 */ private static RateInfo hashCollisionRate(Integer multiplier, List<Integer> hashCodeList) { int maxHash = hashCodeList.stream().max(Integer::compareTo).get(); int minHash = hashCodeList.stream().min(Integer::compareTo).get(); int collisionCount = (int) (hashCodeList.size() - hashCodeList.stream().distinct().count()); double collisionRate = (collisionCount * 1.0) / hashCodeList.size(); return new RateInfo(maxHash, minHash, multiplier, collisionCount, collisionRate); }\",\"计算不同区域的碰撞情况\",\" public static Map<Integer, Integer> hashArea(List<Integer> hashCodeList) { Map<Integer, Integer> statistics = new LinkedHashMap<>(); int start = 0; for (long i = 0x80000000; i <= 0x7fffffff; i += 67108864) { long min = i; long max = min + 67108864; // 筛选出每个格子里的哈希值数量 int num = (int) hashCodeList.parallelStream().filter(x -> x >= min && x < max).count(); statistics.put(start++, num); } return statistics; } public static Map<Integer, Integer> hashArea(Set<String> strList, Integer multiplier){ List<Integer> hashCodeList = new ArrayList<>(); for (String str : strList) { Integer hashCode = hashCode(str, multiplier); hashCodeList.add(hashCode); } return hashArea(hashCodeList); }\"]},\"492\":{\"h\":\"HashMap\",\"t\":[\"扰动函数\",\"初始化容量\",\"负载因子\",\"扩容方法\",\"链表和红黑树\"]},\"493\":{\"h\":\"扰动函数\",\"t\":[\"使用扰动函数的目的是：让数据分配更加均匀\",\"static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); }\",\"异或运算:\",\"当两个比较的位相同的时候，结果为 0。\",\"当两个比较的位不相同的时候，结果为 1。\",\"0 XOR 0 = 0 0 XOR 1 = 1 1 XOR 0 = 1 1 XOR 1 = 0\",\"所以上面的代码是\",\"计算哈希值 key.hashCode() 第一个值\",\"右移16位，在左边进行填充0 第二个值\",\"第一个值和第二个值进行异或运算——混合了原哈希值中的高位和低位，加大随机性\"]},\"494\":{\"h\":\"初始化容量\",\"t\":[\"public HashMap(int initialCapacity, float loadFactor) { //.. 省略 this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); }\",\"threshold 通过 tableSizeFor() 函数进行调整。目的就是找出比初始值大，最小的2进制数值。\",\"static final int tableSizeFor(int cap) { int n = cap - 1; n |= n >>> 1; n |= n >>> 2; n |= n >>> 4; n |= n >>> 8; n |= n >>> 16; // MAXIMUM_CAPACITY = 1 << 30 return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }\"]},\"495\":{\"h\":\"负载因子\",\"t\":[\"负载因子决定了数据量多少了以后进行扩容。\",\"static final float DEFAULT_LOAD_FACTOR = 0.75f;\",\"默认值 0.75 就是说当阀值容量占了3/4 时赶紧扩容，减少 Hash 碰撞。\"]},\"496\":{\"h\":\"扩容\"},\"497\":{\"c\":[\"Collection\"]},\"498\":{\"c\":[\"Java\",\"HashMap\"]},\"499\":{\"h\":\"数组总结篇\"},\"500\":{\"h\":\"什么是数组？\",\"t\":[\"数组是存放在「连续内存空间」上的「相同类型数据」的集合。\"]},\"501\":{\"h\":\"数组的特点\",\"t\":[\"索引从 0 开始\",\"内存地址是连续\",\"访问元素：O(1)\",\"插入和删除元素: O(n)\"]},\"502\":{\"h\":\"二分法\"},\"503\":{\"h\":\"二分查找模板 1\",\"t\":[\"public int binarySearch(int[] nums, int target){ int left = 0; int right = nums.length - 1; // 注意 1 while(left <= right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target){ return mid; } else if(nums[mid] < target) { left = mid + 1; // 注意 }else if(nums[mid] > target){ right = mid - 1; // 注意 } } // End Condition: left > right return -1; }\",\"初始化条件：left = 0, right = nums.length - 1 ，相当于闭区间 [left,right]，而这个区间就是我们的「搜索区间」\",\"循环停止条件：\",\"nums[mid] == target\",\"如果没有找到的情况下，「搜索区间」不存在。即 left > right => [right+1,right] ，区间不存在\",\" 如果非要用 while(left < right)，我该怎么办？\",\" //... while(left < right) { // ... } return nums [left] == target ? left : -1; \",\" 分析如下：\",\" 当退出循环时，存在 left == right ，不管是因为什么原因导致的， 左元素还是右元素最终有一个没做判断 \",\" left = mid + 1 ，所以才有 left == right 退出循环 \",\" right = mid - 1 ，所以才有 left == right 退出循环 \",\"向左查找，向右查找：在上面的「搜索区间」情况下，当 nums[mid] 查找不到时，此时 mid 已经被判断了。因此下次「搜索区间」应该是 [left,mid−1] 或者 [mid+1,right]\"]},\"504\":{\"h\":\"二分查找模版 2：找满足条件的最左侧的值\",\"t\":[\"int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left < right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; // 注意 } } return left; }\",\"初始化条件：left = 0, right = nums.length ，每次循环的「搜索区间」是 [left, right) 左闭右开\",\"循环停止条件：left == right，[left,left) 区间为空，搜索停止。\",\"向左查找：nums[mid] > target，nums[mid] == target 都会改变 right 的值。其实相当于告诉我们 nums[mid]的值都在target的右侧。只有这样做，我们才能不断地 缩小「搜索区间」的上界right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\",\"如果 target 在数组中，最后返回的结果 left 表示，数组中小于 target 的元素有 left 个，也可以表示 target 最左的下标为 left\",\"如果 target 不在数组中，假设一种极端情况\",\"[2,5,7,8] target = 1\",\"在循环过程中，left 一直保持不变，而 right 一直向左边靠近，最终 left == right 最后循环，最后返回 left = 0。\",\"含义是：数组中小于 1 的元素有 0 个。\",\"综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间[0,nums.length]\",\"while (left < right) { //... } // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1; //if(left != nums.length && nums [left] == target){ //return left; //} //return -1;\"]},\"505\":{\"h\":\"二分查找模版 3：找满足条件的最右侧的值\",\"t\":[\"public int search(int[] nums,int target){ int left = 0; int right = nums.length; while(left < right){ int mid = left + (right - left) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; } } if(left != 0 && nums[left-1] == target){ return left - 1; } return -1; }\",\"当 nums[mid] == target 时，不要立即返回，而是 增大「搜索区间」的下界**left**，使得区间不断向右收缩，达到锁定右侧边界的目的。\",\"由于我们更新 left 是 left = mid + 1，那就出现一种情况，left = mid + 1 = right 越界退出循环。\",\"nums[left] 一定不等于 target，否则也不会导致 left = mid+ 1 的操作发生\",\"nums[left-1] 有可能是 target，所以要进行 后处理检查\"]},\"506\":{\"h\":\"双指针法\",\"t\":[\"双指针法（快慢指针法）：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\"]},\"507\":{\"h\":\"滑动窗口\",\"t\":[\"根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O(n2) 的暴力解法降为 O(n)。\",\"最小/最大子数组问题\",\"字符串模式匹配问题\",\"固定长度的子数组/子字符串问题\",\"固定长度的子数组/子字符串问题\"]},\"508\":{\"h\":\"模拟行为\",\"t\":[\"模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟。\",\"循环不变量原则，其实这也是写程序中的重要原则。\"]},\"509\":{\"c\":[\"LeetCode\"]},\"510\":{\"h\":\"栈理论基础篇\"},\"511\":{\"h\":\"理论\",\"t\":[\"堆栈是一种抽象数据类型，用作元素的集合，具有两个主要的操作；\",\"PUSH：将元素添加到集合\",\"POP：删除最近添加但尚未删除的元素\",\"栈是一种 LIFO（后进先出）的线性的数据结构，push 和 pop 操作只发生在结构的一端，称为栈顶。\",\"在 Java 中，Stack 类是很粗糙的，源码中推荐使用 ArrayDeque 去替代。\"]},\"512\":{\"h\":\"ArrayDeque\",\"t\":[\"基于数组实现的双端队列\",\"ArrayDeque 允许在其头部和尾部进行高效地添加和移除元素，它可以用作栈（LIFO，后进先出）\",\"当空间不足时，它会自动进行扩容操作，通常扩容后的容量是原容量的两倍\"]},\"513\":{\"h\":\"问题\",\"t\":[\"堆栈的使用场景？\",\"为什么不是用 Stack 类？\",\"ArrayDeque 是基于什么实现的？\",\"ArrayDeque 数据结构使用过程叙述。\",\"ArrayDeque 为什么要初始化2的n次幂个长度？\"]},\"514\":{\"c\":[\"LeetCode\"]},\"515\":{\"c\":[\"栈\"]},\"516\":{\"h\":\"树专题\"},\"517\":{\"h\":\"概念\",\"t\":[\"树结构的基本单位是节点。\",\"节点之间的链接，称为分支（branch）, 也可以称为边(edge)\",\"树结构的开端，称为根（root），或根结点。\",\"根节点之外的节点，称为子节点（child）。\",\"没有链接到其他子节点的节点，称为叶节点（leaf）。\",\"/* 二叉树节点类 */ class TreeNode { int val; // 节点值 TreeNode left; // 左子节点引用 TreeNode right; // 右子节点引用 TreeNode(int x) { val = x; } }\",\"节点所在的层（level）：从顶至底递增，根节点所在层为 1 。\",\"节点的度（degree）：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。\",\"二叉树的高度（height）：从根节点到最远叶节点所经过的「边的数量」。\",\"节点的深度（depth）：从根节点到该节点所经过的「边的数量」。\",\"节点的高度（height）：从距离该节点最远的叶节点到该节点所经过的「边的数量」。\",\"注\",\"“深度”和”高度“说法，如果把边的数量换成节点数量，那就是都+1。\",\"在LeetCode中，有两道题 111.二叉树的最小深度 和 104.二叉树的最大深度 ，其中 二叉树的最大深度其实跟二叉的高度的定义是一致，不过一个是算节点的数量，一个算边的数量。\"]},\"518\":{\"h\":\"类型\"},\"519\":{\"h\":\"满二叉树\",\"t\":[\" 图片来自：https://www.hello-algo.com/chapter_tree/binary_tree/#2 \",\"叶节点的度为 0，其余节点度为 2\",\"设树的高度为 h，则节点数量为 2h+1−1\"]},\"520\":{\"h\":\"完全二叉树\",\"t\":[\" 图片来自：https://www.hello-algo.com/chapter_tree/binary_tree/#1_1 \"]},\"521\":{\"h\":\"平衡二叉树\",\"t\":[\" 图片来自：https://www.hello-algo.com/chapter_tree/binary_tree/#3 \"]},\"522\":{\"h\":\"二叉搜索树\",\"t\":[\"图片来自：https://www.hello-algo.com/chapter_tree/binary_search_tree/\",\"左子树的所有节点的值 < 根节点\",\"右子树的所有节点的值 > 根节点\",\"左子树和右子树都要满足以上两点\",\"没有键值相等的节点\"]},\"523\":{\"h\":\"遍历\",\"t\":[\"二叉数的遍历主要有前中后遍历和层次遍历。 前中后属于 DFS，层次遍历则可以使用 BFS 或者 DFS 来实现。\",\"DFS 都可以使用「栈」来简化操作，并且其实树本身是一种递归的数据结构，因此「递归」和「栈」对于 DFS 来说是两个关键点。\",\"BFS 的关键点在于如何记录每一层次是否遍历完成， 我们可以用一个标识位来表式当前层的结束。\"]},\"524\":{\"h\":\"层序遍历\",\"t\":[\"层序遍历（level-order traversal）从顶部到底部逐层遍历二叉树，并在每一层按照从左到右的顺序访问节点。\",\"广度优先遍历通常借助“队列”来实现。队列遵循“先进先出”的规则，而广度优先遍历则遵循“逐层推进”的规则，两者背后的思想是一致的。\"]},\"525\":{\"h\":\"BFS遍历\",\"t\":[\"/* 层序遍历 */ List<Integer> levelOrder(TreeNode root) { // 初始化队列，加入根节点 Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); // 初始化一个列表，用于保存遍历序列 List<Integer> list = new ArrayList<>(); while (!queue.isEmpty()) { TreeNode node = queue.poll(); // 队列出队 list.add(node.val); // 保存节点值 if (node.left != null) queue.offer(node.left); // 左子节点入队 if (node.right != null) queue.offer(node.right); // 右子节点入队 } return list; }\"]},\"526\":{\"h\":\"BFS遍历的副产物-层序遍历-迭代写法\",\"t\":[\"乍一看来，这个遍历顺序和 BFS 是一样的，我们可以直接用 BFS 得出层序遍历结果。\",\"然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。\",\"注意点：在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点，BFS 遍历改造成了层序遍历\",\"public class Solution { public List<List<Integer>> levelOrderTraversal(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) { return result; } Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { List<Integer> level = new ArrayList<>(); int levelSize = queue.size(); for (int i = 0; i < levelSize; i++) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } result.add(level); } return result; } }\",\"复杂度分析\",\"时间复杂度为 O(n) ：所有节点被访问一次，使用 O(n) 时间，其中 n 为节点数量。\",\"空间复杂度为 O(n) ：在最差情况下，即满二叉树时，遍历到最底层之前，队列中最多同时存在 (n+1)/2 个节点，占用 O(n) 空间。\"]},\"527\":{\"h\":\"BFS遍历的副产物-层序遍历-递归写法\",\"t\":[\"public List<List<Integer>> resList = new ArrayList<List<Integer>>(); public List<List<Integer>> levelOrderTraversal(TreeNode root) { levelOrderTraversalHelper(root, 0); return result; } private void levelOrderTraversalHelper(TreeNode node, int level) { if (node == null) return; if (result.size() <= level) { result.add(new ArrayList<>()); } result.get(level).add(node.val); levelOrderTraversalHelper(node.left, level + 1, result); levelOrderTraversalHelper(node.right, level + 1, result); }\",\"复杂度分析\",\"时间复杂度为 O(n) ：对书中的每个节点都进行递归调用函数，每一层递归的操作都是O(1)。\",\"空间复杂度为 O(n) ：需要将层次顺序遍历结果存储在一个2D 列表中，该列表可以包含多达 n 个元素。\"]},\"528\":{\"h\":\"前、中、后序遍历\",\"t\":[\"沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。一直进行到已发现从源节点可达的所有节点为止。\",\"前、中、后都属于深度优先遍历（depth-first traversal），也称深度优先搜索（depth-first search, DFS）。\"]},\"529\":{\"h\":\"前序遍历\",\"t\":[\"/* 前序遍历 */ void preOrder(TreeNode root) { if (root == null) return; // 访问优先级：根节点 -> 左子树 -> 右子树 list.add(root.val); preOrder(root.left); preOrder(root.right); }\",\"处理根节点\",\"访问左子树\",\"访问右子树\",\"1、2、5、3、6、7\"]},\"530\":{\"h\":\"中序遍历\",\"t\":[\"/* 中序遍历 */ void inOrder(TreeNode root) { if (root == null) return; // 访问优先级：左子树 -> 根节点 -> 右子树 inOrder(root.left); list.add(root.val); inOrder(root.right); }\",\"2、5、1、6、3、7\"]},\"531\":{\"h\":\"后序遍历\",\"t\":[\"/* 后序遍历 */ void postOrder(TreeNode root) { if (root == null) return; // 访问优先级：左子树 -> 右子树 -> 根节点 postOrder(root.left); postOrder(root.right); list.add(root.val); }\",\"5、2、6、7、3、1\",\"“递”表示开启新方法，程序在此过程中访问下一个节点。\",\"“归”表示函数返回，代表当前节点已经访问完毕。\",\"复杂度分析：\",\"时间复杂度为 O(n) ：所有节点被访问一次，使用 O(n) 时间。\",\"空间复杂度为 O(n) ：在最差情况下，即树退化为链表时，递归深度达到 n ，系统占用 O(n) 栈帧空间。\"]},\"532\":{\"h\":\"迭代遍历\",\"t\":[\"参考垃圾回收算法中标记法：\",\"使用颜色标记节点的状态，新节点为白色(WHITE)，已访问的节点为灰色(GRAY)。\",\"如果遇到的节点为白色，则将其标记为灰色 \",\"将其右子节点、自身、左子节点依次入栈。\",\"如果遇到的节点为灰色，则将节点的值输出。\"]},\"533\":{\"h\":\"前序遍历\",\"t\":[\"前序遍历的顺序是 根-左-右\",\"思路是：\",\"先将根结点入栈\",\"出栈一个元素，将右节点和左节点依次入栈（这样出栈的时候才是中左右的顺序）\",\"重复 2 的步骤\",\"从宏观上表现为：自顶向下依次访问左侧链，然后自底向上依次访问右侧链\",\"从上向下我们可以直接递归访问即可，从下向上我们只需要借助栈也可以轻易做到。\",\"class Solution { public List<Integer> preorderTraversal(TreeNode root) { List<Integer> result = new ArrayList<>(); if (root == null){ return result; } Stack<TreeNode> stack = new Stack<>(); stack.push(root); while (!stack.isEmpty()){ TreeNode node = stack.pop(); result.add(node.val); if (node.right != null){ stack.push(node.right); } if (node.left != null){ stack.push(node.left); } } return result; } }\"]},\"534\":{\"h\":\"中序遍历\",\"t\":[\"class Solution { public List<Integer> inorderTraversal(TreeNode root) { List<Integer> result = new ArrayList<>(); if (root == null){ return result; } Stack<TreeNode> stack = new Stack<>(); TreeNode cur = root; while (cur != null || !stack.isEmpty()){ if (cur != null){ stack.push(cur); cur = cur.left; }else{ cur = stack.pop(); result.add(cur.val); cur = cur.right; } } return result; } }\"]},\"535\":{\"h\":\"后序遍历\",\"t\":[\"// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果 class Solution { public List<Integer> postorderTraversal(TreeNode root) { List<Integer> result = new ArrayList<>(); if (root == null){ return result; } Stack<TreeNode> stack = new Stack<>(); stack.push(root); while (!stack.isEmpty()){ TreeNode node = stack.pop(); result.add(node.val); if (node.left != null){ stack.push(node.left); } if (node.right != null){ stack.push(node.right); } } Collections.reverse(result); return result; } }\"]},\"536\":{\"h\":\"迭代遍历统一法\",\"t\":[\"参考垃圾回收算法中的三色标记\",\"那么迭代遍历，其核心思想如下：\",\"使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。\",\"如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。\",\"如果遇到的节点为灰色，则将节点的值输出。\"]},\"537\":{\"h\":\"前序遍历\",\"t\":[\"class Solution { public List<Integer> preorderTraversal(TreeNode root) { List<Integer> result = new LinkedList<>(); Stack<TreeNode> st = new Stack<>(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } }\",\"中序遍历\",\"class Solution { public List<Integer> inorderTraversal(TreeNode root) { List<Integer> result = new LinkedList<>(); Stack<TreeNode> st = new Stack<>(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } }\",\"class Solution { public List<Integer> postorderTraversal(TreeNode root) { List<Integer> result = new LinkedList<>(); Stack<TreeNode> st = new Stack<>(); if (root != null) st.push(root); while (!st.empty()) { TreeNode node = st.peek(); if (node != null) { st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中 st.push(node); // 添加中节点 st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。 if (node.right!=null) st.push(node.right); // 添加右节点（空节点不入栈） if (node.left!=null) st.push(node.left); // 添加左节点（空节点不入栈） } else { // 只有遇到空节点的时候，才将下一个节点放进结果集 st.pop(); // 将空节点弹出 node = st.peek(); // 重新取出栈中元素 st.pop(); result.add(node.val); // 加入到结果集 } } return result; } }\"]},\"538\":{\"h\":\"表示\"},\"539\":{\"h\":\"完美二叉树\",\"t\":[\"图片来自：https://www.hello-algo.com/chapter_tree/array_representation_of_tree/\"]},\"540\":{\"h\":\"任意二叉树\",\"t\":[\"图片来自：https://www.hello-algo.com/chapter_tree/array_representation_of_tree/#732\",\"完全二叉树中，None 只出现在最底层且靠右的位置，因此所有 None 一定出现在层序遍历序列的末尾。\",\"图片来自：https://www.hello-algo.com/chapter_tree/array_representation_of_tree/#732\"]},\"541\":{\"h\":\"AVL树\",\"t\":[\"AVL 树是「平衡」二叉「搜索树」。\",\"在需要频繁进行「增删查改」操作的场景中，AVL 树能始终保持高效的数据操作性能，时间复杂度保持在 O(longn) 中\"]},\"542\":{\"h\":\"递归三要素\",\"t\":[\"确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\",\"确定终止条件： 如果递归没有终止，操作系统的内存栈必然就会溢出。\",\"确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\"]},\"543\":{\"h\":\"递归可视化\",\"t\":[\"https://labuladong.online/algo-visualize/\",\" let preorderResult = []; let inorderResult = []; let postorderResult = []; function traverse(root) { if (root === null) { return; } // 前序遍历 preorderResult.push(root.val); // 递归遍历左子树 traverse(root.left); // 中序遍历 inorderResult.push(root.val); // 递归遍历右子树 traverse(root.right); // 后序遍历 postorderResult.push(root.val); } let preorderIteratorResult = []; let inorderIteratorResult = []; let postorderIteratorResult = []; function preorderTraversal(root) { if (root === null) { return preorderIteratorResult; } const stack = [root]; while (stack.length > 0) { const node = stack.pop(); preorderIteratorResult.push(node.val); if (node.right !== null) { stack.push(node.right); } if (node.left !== null) { stack.push(node.left); } } return preorderIteratorResult; } function inorderTraversal(root) { if (root === null) { return inorderIteratorResult; } const stack = []; let cur = root; while (cur !== null || stack.length > 0) { if (cur !== null) { stack.push(cur); cur = cur.left; } else { cur = stack.pop(); inorderIteratorResult.push(cur.val); cur = cur.right; } } return inorderIteratorResult; } function postorderTraversal(root) { if (!root) { return postorderIteratorResult; } const stack = [root]; while (stack.length > 0) { const node = stack.pop(); postorderIteratorResult.push(node.val); if (node.left) { stack.push(node.left); } if (node.right) { stack.push(node.right); } } return postorderIteratorResult.reverse(); } let allRoot = TreeNode.create([1, 2, 3, null, 5, 6, 7]); traverse(allRoot); preorderTraversal(allRoot); inorderTraversal(allRoot); postorderTraversal(allRoot);\"]},\"544\":{\"h\":\"题目\",\"t\":[\"层序遍历题目：\",\"102.二叉树的层序遍历(opens new window)\",\"107.二叉树的层次遍历II(opens new window)\",\"199.二叉树的右视图(opens new window)\",\"637.二叉树的层平均值(opens new window)\",\"429.N叉树的层序遍历(opens new window)\",\"515.在每个树行中找最大值(opens new window)\",\"116.填充每个节点的下一个右侧节点指针(opens new window)\",\"117.填充每个节点的下一个右侧节点指针II(opens new window)\",\"104.二叉树的最大深度(opens new window)\",\"111.二叉树的最小深度\"]},\"545\":{\"c\":[\"LeetCode\"]},\"546\":{\"c\":[\"二叉树\"]},\"547\":{\"h\":\"链表总结篇\"},\"548\":{\"h\":\"虚拟头节点\",\"t\":[\"203-移除链表元素\",\"通过添加虚拟头节点的方式，可以很方便进行删除操作。\"]},\"549\":{\"h\":\"快慢指针\",\"t\":[\"206-翻转链表\"]},\"550\":{\"h\":\"删除倒数第 N 个节点\",\"t\":[\"19-删除倒数第 N 个节点 结合虚拟头结点 和 双指针法来移除链表倒数第 N 个节点\",\"交换链表中的节点\",\"删除链表 M 个节点之后的 N 个节点\",\"删除链表的中间节点\"]},\"551\":{\"h\":\"链表的基本操作\",\"t\":[\"707-设计链表\",\"获取链表第 index 个节点的数值\",\"在链表的最前面插入一个节点\",\"在链表的最后面插入一个节点\",\"在链表第 index 个节点前面插入一个节点\",\"删除链表的第 index 个节点的数值\"]},\"552\":{\"h\":\"链表相交\",\"t\":[\"面试题 02.07-链表相交\"]},\"553\":{\"h\":\"环形链表\",\"t\":[\"这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。\",\"142-环形链表-ii\"]},\"554\":{\"c\":[\"LeetCode\"]},\"555\":{\"c\":[\"链表\"]},\"556\":{\"h\":\"链表理论基础\"},\"557\":{\"h\":\"链表是什么？\",\"t\":[\"链表是一种通过指针串联在一起的线性结构\",\"每一个节点由两部分组成，一部分是「数据域」，一部分是「指针域」，最后一个节点的指针域指向 null\"]},\"558\":{\"h\":\"链表类型\"},\"559\":{\"h\":\"单链表\",\"t\":[\"​ \"]},\"560\":{\"h\":\"双链表\",\"t\":[\"每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\"]},\"561\":{\"h\":\"循环链表\",\"t\":[\"循环链表，顾名思义，就是链表首尾相连。\"]},\"562\":{\"h\":\"链表存储方式\",\"t\":[\"链表在内存中可不是连续分布的。\",\"链表是通过「指针域的指针」链接在内存中各个节点，每个节点存放着下一个节点的内存地址。\",\"链表的组成单位是 Node 对象\",\"/* 链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向下一节点的引用 ListNode(int x) { val = x; } // 构造函数 }\"]},\"563\":{\"h\":\"链表操作\"},\"564\":{\"h\":\"头插节点\",\"t\":[\"记录头节点\",\"创建新节点，新节点的头节点为null\",\"新节点的 next 为 「步骤1」的头节点\",\"「步骤1」的前驱节点为 新节点\",\"void linkFirst(E e) { final Node<E> f = first; // 头节点 final Node<E> newNode = new Node<>(null, e, f); // 新节点，后驱节点是f first = newNode; // 现在头节点是新节点 if (f == null) // 如果之前的头节点为null last = newNode; // 那么现在头节点和尾节点都是 新节点 else f.prev = newNode; // 之间的头节点的前驱节点是新节点 size++; }\",\"图片来自：bugstack.cn\"]},\"565\":{\"h\":\"尾插节点\",\"t\":[\"void linkLast(E e) { final Node<E> l = last; final Node<E> newNode = new Node<>(l, e, null); last = newNode; if (l == null) { first = newNode; } else { l.next = newNode; } size++; }\",\"图片来自：bugstack.cn\"]},\"566\":{\"h\":\"拆链操作\",\"t\":[\"E unlink(Node<E> x) { final E element = x.item; final Node<E> next = x.next; final Node<E> prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; return element; }\",\"图片来自：bugstack.cn\"]},\"567\":{\"h\":\"删除节点\",\"t\":[\"public boolean remove(Object o) { if (o == null) { for (Node<E> x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node<E> x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; }\",\"图片来自：bugstack.cn\"]},\"568\":{\"h\":\"链表性能分析\",\"t\":[\"插入/删除为 O(1)\",\"查询为O(n)\"]},\"569\":{\"h\":\"问题\",\"t\":[\"描述一下链表的数据结构？\",\"Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？\",\"链表中数据的插入、删除、获取元素，时间复杂度是多少？\",\"什么场景下使用链表更合适？\"]},\"570\":{\"c\":[\"LeetCode\"]},\"571\":{\"c\":[\"链表\"]},\"572\":{\"h\":\"队列理论基础篇\"},\"573\":{\"h\":\"理论\",\"t\":[\"一个 队列(queue) 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。\",\"队列既可以是数组实现也可以是链表实现。\",\"在 Java 中 Queue 是单端队列接口\",\"在 Java 中 Deque 是双端队列接口\"]},\"574\":{\"h\":\"题目\",\"t\":[\"单端队列和双端队列，分别对应的实现类是哪个？\",\"单端队列遵循先进先出（FIFO）原则，主要通过实现 java.util.Queue 接口来定义，通常使用 java.util.LinkedList 来作为 Queue 的实现模拟单端队列行为。\",\"双端队列（Deque，全称为 Double Ended Queue）是一种允许在其两端进行插入和删除的线性数据结构。\",\"它可以被用作栈，也可以用作队列。双端队列的直接实现类是 java.util.Deque 接口，而常用的实现类是 java.util.ArrayDeque 和 java.util.LinkedList。\",\"简述延迟队列/优先队列的实现方式\",\"优先队列（PriorityQueue）的底层实现是一个二叉堆，通常是最大堆。\",\"最大堆的特点是父节点的优先级总是 >= 其子节点的优先级。为了支持优先级的比较，会实现一个 Comparable 接口或者提供一个 Comparator。\",\"延迟队列（Delay Queue）是一种特殊类型的优先队列，它根据元素的延迟时间来决定元素的优先级。它基于优先队列（PriorityQueue）实现的，用于处理具有过期时间（delay）的任务。\",\"队列里面的元素实现了 java.util.concurrent.Delayed 接口\",\"内部使用一个 PriorityQueue 来存储元素\",\"二叉堆插入/弹出元素的过程\",\"二叉堆(基于数组）插入元素的过程\",\"public void insert(int element) { heap.add(element); // 添加一个元素在数组末尾 int currentIndex = heapArray.size() - 1; // 当前节点位置 int parentIndex = (currentIndex - 1) / 2; // 当前节点的父节点位置 // Compare and swap with parent until the heap property is restored // 当子节点小于父节点，交换他们的元素（最大堆） // 继续比较其节点和其父节点 while (currentIndex > 0 && heap.get(currentIndex) < heap.get(parentIndex)) { swap(currentIndex, parentIndex); currentIndex = parentIndex; parentIndex = (currentIndex - 1) / 2; } }\",\"二叉堆(基于数组）弹出元素的过程\",\"public int pop() { if (heap.isEmpty()) { throw new IllegalStateException(\\\"堆为空！\\\"); } int poppedElement = heap.get(0); // 弹出的元素 heap.set(0, heap.get(heapArray.size() - 1)); // 将数组尾元素替换根元素，并删除旧的数组尾元素 heap.remove(heap.size() - 1); int currentIndex = 0; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; // 比较并交换与较大子节点，直到满足最大堆的性质 while (leftChildIndex < heapArray.size()) { int largerChildIndex = leftChildIndex; if (rightChildIndex < heapArray.size() && heapArray.get(rightChildIndex) > heapArray.get(leftChildIndex)) { largerChildIndex = rightChildIndex; } // 已经满足最大堆的性质 if (heapArray.get(currentIndex) > heapArray.get(largerChildIndex)) { break; } swap(currentIndex, largerChildIndex); currentIndex = largerChildIndex; leftChildIndex = 2 * currentIndex + 1; rightChildIndex = 2 * currentIndex + 2; } return poppedElement; }\",\"延迟队列的使用场景\",\"订单超时处理：在线购物平台中，当用户下单后，系统可能会设置一个延迟队列，如果订单在 30 分钟或 1 小时内未完成支付，则自动取消订单并释放锁定的库存。\",\"定时任务触发：如定期发送报告、数据同步、缓存刷新等操作可以在特定时间点通过延迟队列自动触发执行。\",\"短信或邮件通知：在用户注册、下单等操作后，系统不立即发送确认短信或邮件，而是在用户操作后的几分钟或更长时间后再发送，以避免即时发送失败或对用户体验造成干扰。\",\"延迟队列为什么要添加信号量\",\"信号量用于控制对共享资源的访问，尤其是当涉及到 多个线程访问有限资源 时。它通过维护一个 计数器 来实现这一功能，允许一定数量的并发访问，并且其他请求访问的线程必须等待直到计数器非零。\",\"流量控制：通过信号量限制生产者向延迟队列中添加消息的速度，可以实现流量控制，确保队列不会被过快填满，从而维持系统的稳定运行。\",\"资源访问同步：如果队列某些操作（如调整队列参数、查询队列状态）需要独占访问，信号量可以用来同步这些操作，确保同一时间只有一个线程能执行此类操作，防止数据不一致性或竞态条件。\"]},\"575\":{\"c\":[\"LeetCode\"]},\"576\":{\"c\":[\"队列\"]},\"577\":{\"h\":\"面试题02.07-链表相交\"},\"578\":{\"h\":\"题目地址(面试题 02.07. 链表相交 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\"]},\"579\":{\"h\":\"题目描述\",\"t\":[\" 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\",\" 图示两个链表在节点 c1 开始相交 ：\",\" 题目数据 保证 整个链式结构中不存在环。\",\" 注意 ，函数返回结果后，链表必须 保持其原始结构 。\",\" 示例 1：\",\" 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出： Intersected at '8' 解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 \",\" 示例 2：\",\" 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出： Intersected at '2' 解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 \",\" 示例 3：\",\" 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出： null 解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 \",\" 提示：\",\" listA 中节点数目为 m \",\" listB 中节点数目为 n \",\" 0 <= m, n <= 3 * 10 4 \",\" 1 <= Node.val <= 10 5 \",\" 0 <= skipA <= m \",\" 0 <= skipB <= n \",\" 如果 listA 和 listB 没有交点， intersectVal 为 0 \",\" 如果 listA 和 listB 有交点， intersectVal == listA [skipA + 1] == listB [skipB + 1] \",\" 进阶： 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\"]},\"580\":{\"h\":\"前置知识\",\"t\":[\"双指针\",\"链表\",\"哈希表\"]},\"581\":{\"h\":\"思路\",\"t\":[\"相交部分长度为 c，listA 长度为 a，listb 长度为 b。\",\"有两个变量 headA、headB 分别从 listA、listB 分别出发。\",\"当 headA 走完 listA 时，从 headB 继续走。\",\"当 headB 走完 listB 时，从 headA 继续走。\",\"headA == headB 时就是相交节点\",\"headA 共走了 a+（b-c）\",\"headB 共走了 b+（a-c）\",\"若两链表 有 公共尾部 (即 c > 0 ) ：指针 A, B 同时指向第一个相交节点。\",\"若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。\"]},\"582\":{\"h\":\"关键点\",\"t\":[\"双指针遍历各自所在链表后，在遍历对方的链表，第一次「相等」就是相交点\",\"「相等」有可能两个指针都指向 null\"]},\"583\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } // A 链长度为 a // B 链长度为 b // A 和 B 重叠的链长度为 c // A 相交的位置在 a+b-c // B 相交的位置在 b+a-c ListNode first = headA; ListNode second = headB; while(first != second){ // 循环终止条件 first = first == null? headB:first.next; second = second == null? headA:second.next; } return first; } }\",\"复杂度分析\",\"令 a 为 listA 长度，b 为 listB 长度\",\"时间复杂度：O(a+b)，最差情况下（即 ∣a−b∣=1 , c=0 ），此时需遍历 a+b 个节点。\",\"空间复杂度：O(1)\"]},\"584\":{\"c\":[\"LeetCode\"]},\"585\":{\"c\":[\"链表\"]},\"586\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"587\":{\"h\":\"About\"}},\"dirtCount\":0,\"index\":[[\"∣a−b∣=1\",{\"1\":{\"583\":1}}],[\"共走了\",{\"1\":{\"581\":2}}],[\"共有\",{\"1\":{\"70\":1}}],[\"必须为\",{\"1\":{\"579\":1}}],[\"必须实现\",{\"1\":{\"31\":1}}],[\"图示两个链表在节点\",{\"1\":{\"579\":1}}],[\"图片来自\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"14\":1,\"36\":1,\"41\":1,\"46\":1,\"218\":1,\"462\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2,\"564\":1,\"565\":1,\"566\":1,\"567\":1}}],[\"防止数据不一致性或竞态条件\",{\"1\":{\"574\":1}}],[\"资源访问同步\",{\"1\":{\"574\":1}}],[\"流量控制\",{\"1\":{\"574\":1}}],[\"尤其是当涉及到\",{\"1\":{\"574\":1}}],[\"信号量可以用来同步这些操作\",{\"1\":{\"574\":1}}],[\"信号量用于控制对共享资源的访问\",{\"1\":{\"574\":1}}],[\"信用卡是银行账户的代理\",{\"1\":{\"15\":1}}],[\"短信或邮件通知\",{\"1\":{\"574\":1}}],[\"缓存刷新等操作可以在特定时间点通过延迟队列自动触发执行\",{\"1\":{\"574\":1}}],[\"定时任务触发\",{\"1\":{\"574\":1}}],[\"定义好上下左右四个边界\",{\"1\":{\"378\":1}}],[\"定义存储的数组\",{\"1\":{\"315\":1}}],[\"定义一个函数计算hash碰撞概率\",{\"1\":{\"491\":1}}],[\"定义一个函数\",{\"1\":{\"491\":1}}],[\"定义一个不同参数的\",{\"1\":{\"491\":1}}],[\"定义一个前节点来做判断\",{\"1\":{\"435\":1}}],[\"定义一个最小值\",{\"1\":{\"434\":1}}],[\"定义一个\",{\"1\":{\"359\":1}}],[\"定义一个长度为\",{\"1\":{\"313\":1}}],[\"定义一个原型接口\",{\"1\":{\"33\":1}}],[\"定义两个指针\",{\"1\":{\"230\":1}}],[\"定义两个指针slow和fast\",{\"1\":{\"198\":1}}],[\"定义为\",{\"1\":{\"196\":1}}],[\"定义三个指针\",{\"1\":{\"139\":1}}],[\"定义递归函数\",{\"1\":{\"68\":1}}],[\"定义调用构造步骤的顺序\",{\"1\":{\"47\":1}}],[\"定义了\",{\"1\":{\"16\":1}}],[\"系统不立即发送确认短信或邮件\",{\"1\":{\"574\":1}}],[\"系统可能会设置一个延迟队列\",{\"1\":{\"574\":1}}],[\"系统占用\",{\"1\":{\"531\":1}}],[\"订单超时处理\",{\"1\":{\"574\":1}}],[\"弹出的元素\",{\"1\":{\"574\":1}}],[\"弹出元素的过程\",{\"1\":{\"574\":2}}],[\"延迟队列为什么要添加信号量\",{\"1\":{\"574\":1}}],[\"延迟队列的使用场景\",{\"1\":{\"574\":1}}],[\"延迟队列\",{\"1\":{\"574\":1}}],[\"延迟初始化\",{\"1\":{\"17\":1}}],[\"优先队列\",{\"1\":{\"574\":1}}],[\"优先队列的实现方式\",{\"1\":{\"574\":1}}],[\"优化\",{\"1\":{\"3\":1}}],[\"全称为\",{\"1\":{\"574\":1}}],[\"全局的最长相同序列长度\",{\"1\":{\"342\":1}}],[\"接口或者提供一个\",{\"1\":{\"574\":1}}],[\"接口\",{\"1\":{\"574\":2}}],[\"接口来定义\",{\"1\":{\"574\":1}}],[\"接触就收到了礼物\",{\"1\":{\"15\":1}}],[\"集合中的实体按顺序保存\",{\"1\":{\"573\":1}}],[\"集合的大小就构成了树的宽度\",{\"1\":{\"471\":1}}],[\"什么场景下使用链表更合适\",{\"1\":{\"569\":1}}],[\"什么是数组\",{\"0\":{\"500\":1}}],[\"描述一下链表的数据结构\",{\"1\":{\"569\":1}}],[\"查询队列状态\",{\"1\":{\"574\":1}}],[\"查询为o\",{\"1\":{\"568\":1}}],[\"查找不到时\",{\"1\":{\"503\":1}}],[\"查找\",{\"1\":{\"476\":1}}],[\"查找元素\",{\"1\":{\"461\":1}}],[\"拆链操作\",{\"0\":{\"566\":1}}],[\"尾插节点\",{\"0\":{\"565\":1}}],[\"尾随空格或者单词间的多个空格\",{\"1\":{\"146\":1}}],[\"顾名思义\",{\"1\":{\"561\":1}}],[\"​\",{\"1\":{\"559\":1}}],[\"寻找公共尾部入口等\",{\"1\":{\"553\":1}}],[\"寻找环入口\",{\"1\":{\"553\":1}}],[\"寻找交集元素\",{\"1\":{\"306\":1}}],[\"面试题02\",{\"0\":{\"577\":1}}],[\"面试题\",{\"0\":{\"578\":1},\"1\":{\"552\":1}}],[\"确定每一层递归需要处理的信息\",{\"1\":{\"542\":1}}],[\"确定单层递归的逻辑\",{\"1\":{\"542\":1}}],[\"确定终止条件\",{\"1\":{\"542\":1}}],[\"确定哪些参数是递归的过程中需要处理的\",{\"1\":{\"542\":1}}],[\"确定递归函数的参数和返回值\",{\"1\":{\"542\":1}}],[\"确保同一时间只有一个线程能执行此类操作\",{\"1\":{\"574\":1}}],[\"确保队列不会被过快填满\",{\"1\":{\"574\":1}}],[\"确保数组长度已使用长度\",{\"1\":{\"486\":1}}],[\"确保当前结点后还有结点\",{\"1\":{\"208\":1,\"211\":1}}],[\"增删查改\",{\"1\":{\"541\":1}}],[\"增大\",{\"1\":{\"505\":1}}],[\"增大总和\",{\"1\":{\"141\":1}}],[\"才将下一个节点放进结果集\",{\"1\":{\"537\":3}}],[\"才会初始化容量为\",{\"1\":{\"486\":1}}],[\"下单等操作后\",{\"1\":{\"574\":1}}],[\"下面再将右中左节点添加到栈中\",{\"1\":{\"537\":3}}],[\"下边界缩减\",{\"1\":{\"378\":2}}],[\"避免重复操作\",{\"1\":{\"537\":3}}],[\"归\",{\"1\":{\"531\":1}}],[\"归并排序的主函数\",{\"1\":{\"453\":1}}],[\"归并排序\",{\"1\":{\"443\":1}}],[\"程序在此过程中访问下一个节点\",{\"1\":{\"531\":1}}],[\"递\",{\"1\":{\"531\":1}}],[\"递归遍历右子树\",{\"1\":{\"543\":1}}],[\"递归遍历左子树\",{\"1\":{\"543\":1}}],[\"递归可视化\",{\"0\":{\"543\":1}}],[\"递归写法\",{\"0\":{\"527\":1}}],[\"递归的深度就构成了树的深度\",{\"1\":{\"471\":1}}],[\"递归的结果就是\",{\"1\":{\"244\":2}}],[\"递归向上撤销结果\",{\"1\":{\"469\":1}}],[\"递归向下处理和获取结果\",{\"1\":{\"469\":1}}],[\"递归地检查左子树和右子树\",{\"1\":{\"437\":1}}],[\"递归调用的层数不会超过较小的二叉树的最大高度\",{\"1\":{\"386\":1}}],[\"递归调用的栈深度取决于二叉树的高度\",{\"1\":{\"263\":1}}],[\"递归执行两个树的右节点\",{\"1\":{\"385\":1}}],[\"递归深度达到\",{\"1\":{\"531\":1}}],[\"递归深度等价于二叉树的高度\",{\"1\":{\"351\":1}}],[\"递归深度可达到\",{\"1\":{\"81\":1}}],[\"递归终止条件为\",{\"1\":{\"359\":1}}],[\"递归终止条件\",{\"1\":{\"340\":1,\"385\":1,\"394\":1,\"434\":1}}],[\"递归右子树\",{\"1\":{\"261\":1,\"359\":1}}],[\"递归左子树\",{\"1\":{\"261\":1,\"359\":1}}],[\"递归逻辑\",{\"1\":{\"261\":1,\"340\":1,\"359\":1}}],[\"递归翻转\",{\"1\":{\"244\":2}}],[\"递归函数在递归过程中需要为每一层递归函数分配栈空间\",{\"1\":{\"436\":1}}],[\"递归函数逻辑\",{\"1\":{\"394\":1}}],[\"递归函数需要栈空间\",{\"1\":{\"351\":1}}],[\"递归函数定义\",{\"1\":{\"244\":1,\"359\":1,\"385\":1,\"394\":1}}],[\"递归函数的定义\",{\"1\":{\"221\":1}}],[\"递归思想\",{\"1\":{\"217\":1}}],[\"递归需要\",{\"1\":{\"182\":2}}],[\"递归方式\",{\"0\":{\"181\":1}}],[\"递归三要素\",{\"0\":{\"542\":1},\"1\":{\"79\":1}}],[\"递归\",{\"0\":{\"68\":1,\"221\":1},\"1\":{\"244\":1,\"471\":1,\"523\":1}}],[\"访问右子树\",{\"1\":{\"529\":1}}],[\"访问左子树\",{\"1\":{\"529\":1}}],[\"访问优先级\",{\"1\":{\"529\":1,\"530\":1,\"531\":1}}],[\"访问元素\",{\"1\":{\"501\":1}}],[\"尽可能深的搜索树的分支\",{\"1\":{\"528\":1}}],[\"沿着树的深度遍历树的节点\",{\"1\":{\"528\":1}}],[\"然而\",{\"1\":{\"526\":1}}],[\"然后自底向上依次访问右侧链\",{\"1\":{\"533\":1}}],[\"然后一口气处理完这一层的\",{\"1\":{\"526\":1}}],[\"然后选出我们想要的答案\",{\"1\":{\"470\":1}}],[\"然后对每个桶中的数据进行排序\",{\"1\":{\"457\":1}}],[\"然后对每个子序列进行插入排序\",{\"1\":{\"452\":1}}],[\"然后反向输出\",{\"1\":{\"456\":1}}],[\"然后将其右子节点\",{\"1\":{\"536\":1}}],[\"然后将排序好的两半合并在一起\",{\"1\":{\"453\":1}}],[\"然后将新加入的元素压入\",{\"1\":{\"239\":1}}],[\"然后进行更新结果\",{\"1\":{\"359\":1}}],[\"然后处理该节点\",{\"1\":{\"325\":1}}],[\"然后返回\",{\"1\":{\"283\":1}}],[\"然后重复这个过程直到这个数变为\",{\"1\":{\"196\":1}}],[\"然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数\",{\"1\":{\"160\":1,\"161\":1}}],[\"然后再按照位数排序\",{\"1\":{\"458\":1}}],[\"然后再遍历右子树\",{\"1\":{\"434\":1}}],[\"然后再进行反转\",{\"1\":{\"369\":1}}],[\"然后再更新下一层的指针\",{\"1\":{\"123\":1}}],[\"然后再让当前节点成为前一个节点\",{\"1\":{\"121\":1}}],[\"然后利用demo去修改\",{\"1\":{\"3\":1}}],[\"得出层序遍历结果\",{\"1\":{\"526\":1}}],[\"得到的链是一个隐式的链表\",{\"1\":{\"198\":1}}],[\"乍一看来\",{\"1\":{\"526\":1}}],[\"逐层推进\",{\"1\":{\"524\":1}}],[\"逐层遍历\",{\"1\":{\"320\":1}}],[\"广度优先遍历通常借助\",{\"1\":{\"524\":1}}],[\"广度优先搜索\",{\"1\":{\"321\":1}}],[\"广度优先搜索往往利用\",{\"1\":{\"82\":1}}],[\"叶节点的度为\",{\"1\":{\"519\":1}}],[\"叶子节点的定义是左孩子和右孩子都为\",{\"1\":{\"102\":1}}],[\"叶子节点\",{\"1\":{\"101\":1}}],[\"叶子节点是指没有子节点的节点\",{\"1\":{\"100\":1}}],[\"满二叉树\",{\"0\":{\"519\":1}}],[\"满足如下定义\",{\"1\":{\"339\":1}}],[\"满足\",{\"1\":{\"137\":1,\"261\":1}}],[\"高度\",{\"1\":{\"517\":1}}],[\"高精尖儿\",{\"1\":{\"2\":1}}],[\"注\",{\"1\":{\"517\":1}}],[\"注意点\",{\"1\":{\"526\":1}}],[\"注意这五个元素可以任意顺序返回\",{\"1\":{\"283\":1}}],[\"注意\",{\"1\":{\"0\":1,\"128\":1,\"137\":2,\"146\":1,\"236\":1,\"274\":1,\"358\":1,\"384\":1,\"403\":1,\"503\":3,\"504\":3,\"505\":1,\"579\":3}}],[\"边的数量\",{\"1\":{\"517\":3}}],[\"边界变化条件\",{\"1\":{\"379\":1}}],[\"度的取值范围是\",{\"1\":{\"517\":1}}],[\"通常是最大堆\",{\"1\":{\"574\":1}}],[\"通常使用\",{\"1\":{\"574\":1}}],[\"通常扩容后的容量是原容量的两倍\",{\"1\":{\"512\":1}}],[\"通过信号量限制生产者向延迟队列中添加消息的速度\",{\"1\":{\"574\":1}}],[\"通过添加虚拟头节点的方式\",{\"1\":{\"548\":1}}],[\"通过一个快指针和慢指针在一个\",{\"1\":{\"506\":1}}],[\"通过寻址公式\",{\"1\":{\"475\":1}}],[\"通过某种算法将\",{\"1\":{\"462\":1}}],[\"通过建立键\",{\"1\":{\"461\":1}}],[\"通过构建有序序列\",{\"1\":{\"450\":1}}],[\"通过上面的总结会发现边界的起始和结束与方向是对应的\",{\"1\":{\"380\":1}}],[\"通过\",{\"1\":{\"283\":1,\"494\":1}}],[\"通过反复调用\",{\"1\":{\"198\":1}}],[\"通过反馈你才能时刻修正自己\",{\"1\":{\"5\":1}}],[\"通过排序容易找到相同的三元组答案\",{\"1\":{\"140\":1}}],[\"通过查询\",{\"1\":{\"60\":1}}],[\"通过复制一个已存在的实例\",{\"1\":{\"31\":1}}],[\"通过代理给被追求者\",{\"1\":{\"15\":1}}],[\"允许一定数量的并发访问\",{\"1\":{\"574\":1}}],[\"允许在其头部和尾部进行高效地添加和移除元素\",{\"1\":{\"512\":1}}],[\"允许子类决定实例化对象的类型\",{\"1\":{\"36\":1}}],[\"基于数组\",{\"1\":{\"574\":2}}],[\"基于数组实现的双端队列\",{\"1\":{\"512\":1}}],[\"基数排序\",{\"0\":{\"458\":1},\"1\":{\"443\":1,\"458\":1}}],[\"源码中推荐使用\",{\"1\":{\"511\":1}}],[\"源码分析\",{\"0\":{\"477\":1}}],[\"具有两个主要的操作\",{\"1\":{\"511\":1}}],[\"具体生成器\",{\"1\":{\"47\":1}}],[\"具体创建者\",{\"1\":{\"36\":1}}],[\"具体产品\",{\"1\":{\"36\":1}}],[\"具体原型\",{\"1\":{\"32\":1}}],[\"取值区间是闭区间\",{\"1\":{\"504\":1}}],[\"取消注释下一行\",{\"1\":{\"0\":1}}],[\"综上可以看出\",{\"1\":{\"504\":1}}],[\"综上所述\",{\"1\":{\"484\":1}}],[\"含义是\",{\"1\":{\"504\":1}}],[\"达到锁定右侧边界的目的\",{\"1\":{\"505\":1}}],[\"达到锁定左侧边界的目的\",{\"1\":{\"504\":1}}],[\"达到快速访问的目的\",{\"1\":{\"475\":1}}],[\"应该是\",{\"1\":{\"503\":1}}],[\"应该为\",{\"1\":{\"403\":1}}],[\"向右查找\",{\"1\":{\"503\":1}}],[\"向左查找\",{\"1\":{\"503\":1,\"504\":1}}],[\"连续内存空间\",{\"1\":{\"500\":1}}],[\"连续的内存空间\",{\"1\":{\"475\":1}}],[\"碰撞\",{\"1\":{\"495\":1}}],[\"减少\",{\"1\":{\"495\":1}}],[\"减小总和\",{\"1\":{\"141\":1}}],[\"省略\",{\"1\":{\"494\":1}}],[\"混合了原哈希值中的高位和低位\",{\"1\":{\"493\":1}}],[\"异或运算\",{\"1\":{\"493\":1}}],[\"异侧\",{\"1\":{\"261\":1}}],[\"^\",{\"1\":{\"493\":1}}],[\"负载因子决定了数据量多少了以后进行扩容\",{\"1\":{\"495\":1}}],[\"负载因子\",{\"0\":{\"495\":1},\"1\":{\"492\":1}}],[\"扰动函数\",{\"0\":{\"493\":1},\"1\":{\"492\":1}}],[\"筛选出每个格子里的哈希值数量\",{\"1\":{\"491\":1}}],[\"准备一个单词表\",{\"1\":{\"491\":1}}],[\"准确来说\",{\"1\":{\"4\":1}}],[\"乘积运算可以使用位移提升性能\",{\"1\":{\"491\":1}}],[\"∗31\",{\"1\":{\"491\":2}}],[\"值\",{\"1\":{\"490\":1}}],[\"值分隔\",{\"1\":{\"320\":1}}],[\"键\",{\"1\":{\"490\":1}}],[\"跟外面的数组没有关系\",{\"1\":{\"486\":1}}],[\"跟简单工厂不同的是抽象工厂是创建一系列相关的对象\",{\"1\":{\"41\":1}}],[\"影响的只是内部的数组\",{\"1\":{\"486\":1}}],[\"受影响嘛\",{\"1\":{\"486\":1}}],[\"容量为原来的\",{\"1\":{\"486\":1}}],[\"容易出现实例化多个对象的情况\",{\"1\":{\"24\":1}}],[\"底层是用动态数组实现\",{\"1\":{\"486\":1}}],[\"底层逻辑与蝴蝶效应\",{\"0\":{\"1\":1}}],[\"倍\",{\"1\":{\"485\":3,\"486\":1}}],[\"经过上一步\",{\"1\":{\"484\":1}}],[\"赋值\",{\"1\":{\"480\":1,\"482\":1}}],[\"赋给树\",{\"1\":{\"387\":2}}],[\"构造函数有三种\",{\"1\":{\"479\":1}}],[\"构造函数\",{\"0\":{\"479\":1},\"1\":{\"562\":1}}],[\"构建文档\",{\"1\":{\"0\":1}}],[\"包含的元素数量\",{\"1\":{\"478\":1}}],[\"包含英文大小写字母\",{\"1\":{\"146\":1}}],[\"区分开来\",{\"1\":{\"478\":1}}],[\"区间为空\",{\"1\":{\"504\":1}}],[\"区间不存在\",{\"1\":{\"503\":1}}],[\"区间不为空\",{\"1\":{\"403\":1}}],[\"区间定义\",{\"1\":{\"403\":1}}],[\"区间\",{\"1\":{\"380\":4}}],[\"区间内\",{\"1\":{\"77\":1}}],[\"默认值\",{\"1\":{\"495\":1}}],[\"默认方式\",{\"1\":{\"479\":1}}],[\"默认初始容量\",{\"1\":{\"478\":1}}],[\"默认该节点是该层的最大值\",{\"1\":{\"349\":1}}],[\"成员变量\",{\"0\":{\"478\":1}}],[\"成本是\",{\"1\":{\"200\":1}}],[\"平衡\",{\"1\":{\"541\":1}}],[\"平衡二叉树\",{\"0\":{\"521\":1}}],[\"平均下来时间复杂度为\",{\"1\":{\"476\":1}}],[\"平方越大\",{\"1\":{\"428\":1}}],[\"平方也就越大\",{\"1\":{\"428\":1}}],[\"平方大小的比较\",{\"1\":{\"427\":1}}],[\"平方后\",{\"1\":{\"424\":1}}],[\"变量的值\",{\"1\":{\"504\":1}}],[\"变成\",{\"1\":{\"475\":1}}],[\"变动情况\",{\"1\":{\"139\":1}}],[\"常见集合\",{\"0\":{\"474\":1,\"489\":1}}],[\"常数的空间\",{\"1\":{\"296\":1}}],[\"撤销处理结果\",{\"1\":{\"471\":1}}],[\"路径\",{\"1\":{\"471\":1}}],[\"搜索树\",{\"1\":{\"541\":1}}],[\"搜索将回溯到发现节点\",{\"1\":{\"528\":1}}],[\"搜索停止\",{\"1\":{\"504\":1}}],[\"搜索区间\",{\"1\":{\"503\":4,\"504\":2,\"505\":1}}],[\"搜索过程\",{\"1\":{\"471\":1}}],[\"搜索首个空格\",{\"1\":{\"151\":1}}],[\"棋盘问题\",{\"1\":{\"470\":1}}],[\"切割问题\",{\"1\":{\"470\":1}}],[\"穷举所有可能\",{\"1\":{\"470\":1}}],[\"问题\",{\"0\":{\"513\":1,\"569\":1},\"1\":{\"469\":1}}],[\"回溯\",{\"1\":{\"471\":1},\"2\":{\"473\":1}}],[\"回溯三要素\",{\"1\":{\"471\":1}}],[\"回溯法解决的问题都可以抽象为\",{\"1\":{\"471\":1}}],[\"回溯法\",{\"1\":{\"470\":1}}],[\"回溯的本质是穷举\",{\"1\":{\"470\":1}}],[\"回溯函数也就是递归函数\",{\"1\":{\"469\":1}}],[\"回溯问题可以抽象为\",{\"1\":{\"469\":1}}],[\"回溯算法\",{\"1\":{\"469\":1}}],[\"回溯算法理论基础\",{\"0\":{\"468\":1}}],[\"回想了一下自己大学的学习过程\",{\"1\":{\"2\":1}}],[\"冲突的位置存储在链表中\",{\"1\":{\"464\":1}}],[\"拉链法\",{\"0\":{\"464\":1}}],[\"理论\",{\"0\":{\"511\":1,\"573\":1}}],[\"理论上一定存在\",{\"1\":{\"463\":1}}],[\"理解递归\",{\"1\":{\"222\":1}}],[\"映射到\",{\"1\":{\"462\":1}}],[\"哈希计算\",{\"1\":{\"490\":1}}],[\"哈希冲突\",{\"0\":{\"463\":1},\"1\":{\"463\":1}}],[\"哈希函数\",{\"0\":{\"462\":1}}],[\"哈希表的存在是为了解决能通过\",{\"1\":{\"490\":1}}],[\"哈希表是什么\",{\"0\":{\"461\":1}}],[\"哈希表基础理论\",{\"0\":{\"460\":1}}],[\"哈希表所用的空间\",{\"1\":{\"334\":1}}],[\"哈希表计数或者数组计数\",{\"1\":{\"314\":1}}],[\"哈希表记录\",{\"0\":{\"276\":1}}],[\"哈希表存储元素的开销\",{\"1\":{\"62\":1}}],[\"哈希表存储的\",{\"1\":{\"61\":1}}],[\"哈希表\",{\"1\":{\"59\":1,\"159\":1,\"197\":1,\"275\":1,\"312\":1,\"461\":1,\"580\":1},\"2\":{\"64\":1,\"202\":1,\"280\":1,\"308\":1,\"317\":1,\"336\":1,\"467\":1}}],[\"考虑负数的情况\",{\"1\":{\"458\":1}}],[\"考虑通过递归对二叉树进行先序遍历\",{\"1\":{\"261\":1}}],[\"扩容方法\",{\"1\":{\"492\":1}}],[\"扩容\",{\"0\":{\"496\":1},\"1\":{\"457\":1,\"458\":1}}],[\"利用映射函数将数据分配到各个桶中\",{\"1\":{\"457\":1}}],[\"利用栈的思想来判断匹配情况\",{\"1\":{\"91\":1}}],[\"放到一个桶里\",{\"1\":{\"457\":1}}],[\"放进\",{\"1\":{\"255\":1}}],[\"放进队列中\",{\"1\":{\"90\":1}}],[\"获取元素\",{\"1\":{\"569\":1}}],[\"获取链表第\",{\"1\":{\"551\":1}}],[\"获取链表中下标为\",{\"1\":{\"412\":1}}],[\"获取整数的位数\",{\"1\":{\"458\":1}}],[\"获取最高位数\",{\"1\":{\"458\":1}}],[\"获取最高位\",{\"1\":{\"458\":1}}],[\"获取最大值\",{\"1\":{\"456\":1,\"458\":1}}],[\"堆为空\",{\"1\":{\"574\":1}}],[\"堆栈的使用场景\",{\"1\":{\"513\":1}}],[\"堆栈是一种抽象数据类型\",{\"1\":{\"511\":1}}],[\"堆顶位置维护\",{\"1\":{\"455\":1}}],[\"堆顶位置调整\",{\"1\":{\"455\":1}}],[\"堆排序\",{\"1\":{\"443\":1,\"455\":1}}],[\"临时数组的索引\",{\"1\":{\"453\":1}}],[\"临时数组\",{\"1\":{\"453\":1}}],[\"采用分而治之的思想\",{\"1\":{\"453\":1}}],[\"采用双指针\",{\"1\":{\"428\":1}}],[\"采用双指针的方式\",{\"1\":{\"132\":1}}],[\"算法退化为普通的插入排序\",{\"1\":{\"452\":1}}],[\"算法步骤\",{\"1\":{\"450\":1}}],[\"随着增量逐渐减小\",{\"1\":{\"452\":1}}],[\"随后继续交替移动\",{\"1\":{\"141\":1}}],[\"位置\",{\"1\":{\"490\":2}}],[\"位置中\",{\"1\":{\"450\":1}}],[\"位置设为\",{\"1\":{\"450\":1}}],[\"扫描\",{\"1\":{\"450\":1}}],[\"无\",{\"1\":{\"581\":1}}],[\"无法区分每一层\",{\"1\":{\"526\":1}}],[\"无参构造函数\",{\"0\":{\"481\":1}}],[\"无需额外的存储空间\",{\"1\":{\"446\":1}}],[\"无限循环\",{\"1\":{\"196\":1}}],[\"桶排序算是计数排序的一个加强版\",{\"1\":{\"457\":1}}],[\"桶排序\",{\"0\":{\"457\":1},\"1\":{\"443\":1,\"457\":1}}],[\"外部排序\",{\"1\":{\"443\":4}}],[\"希尔排序的基本思想是将原始数据分成多个子序列\",{\"1\":{\"452\":1}}],[\"希尔排序是插入排序的一种优化版本\",{\"1\":{\"452\":1}}],[\"希尔排序\",{\"1\":{\"443\":1}}],[\"选择列表\",{\"1\":{\"471\":1}}],[\"选择\",{\"1\":{\"471\":1}}],[\"选择最右侧的元素作为基准值\",{\"1\":{\"454\":1}}],[\"选择排序\",{\"0\":{\"447\":1},\"1\":{\"443\":1}}],[\"选择较大的那个逆序放入答案并移动指针\",{\"1\":{\"426\":1}}],[\"冒泡排序\",{\"0\":{\"444\":1},\"1\":{\"443\":1}}],[\"稳定\",{\"1\":{\"443\":6}}],[\"稳定性\",{\"1\":{\"443\":1}}],[\"稳定排序\",{\"1\":{\"443\":1}}],[\"名称\",{\"1\":{\"443\":1}}],[\"称为叶节点\",{\"1\":{\"517\":1}}],[\"称为子节点\",{\"1\":{\"517\":1}}],[\"称为根\",{\"1\":{\"517\":1}}],[\"称为分支\",{\"1\":{\"517\":1}}],[\"称为栈顶\",{\"1\":{\"511\":1}}],[\"称为不稳定排序\",{\"1\":{\"443\":1}}],[\"称为稳定排序\",{\"1\":{\"443\":1}}],[\"仍然在\",{\"1\":{\"443\":1}}],[\"各种排序算法\",{\"0\":{\"442\":1}}],[\"各字符时\",{\"1\":{\"276\":1}}],[\"各字符时执行\",{\"1\":{\"276\":1}}],[\"简述延迟队列\",{\"1\":{\"574\":1}}],[\"简洁实现\",{\"1\":{\"436\":1}}],[\"简单理解是一种简单粗暴的试错搜索\",{\"1\":{\"469\":1}}],[\"简单理解就是将\",{\"1\":{\"36\":1}}],[\"简单工厂类\",{\"1\":{\"52\":1}}],[\"简单工厂\",{\"0\":{\"51\":1},\"1\":{\"9\":1}}],[\"比所有数都大\",{\"1\":{\"504\":1}}],[\"比如\",{\"1\":{\"462\":1}}],[\"比较并交换与较大子节点\",{\"1\":{\"574\":1}}],[\"比较交换\",{\"1\":{\"455\":1}}],[\"比较的节点也是符合保证\",{\"1\":{\"434\":1}}],[\"比\",{\"1\":{\"445\":1}}],[\"比长度更大\",{\"1\":{\"412\":1}}],[\"空节点不入栈\",{\"1\":{\"537\":6}}],[\"空树符合二叉搜索树的定义\",{\"1\":{\"434\":1}}],[\"空间\",{\"1\":{\"526\":1}}],[\"空间解决此题\",{\"1\":{\"128\":1}}],[\"空间复杂度取决于递归调用的层数\",{\"1\":{\"386\":1}}],[\"空间复杂度与树的高度有关\",{\"1\":{\"361\":1}}],[\"空间复杂度主要取决于递归调用的栈空间\",{\"1\":{\"223\":1}}],[\"空间复杂度主要取决于递归时栈空间的开销\",{\"1\":{\"104\":1}}],[\"空间复杂度主要取决于排序额外使用的空间\",{\"1\":{\"162\":1}}],[\"空间复杂度为\",{\"1\":{\"104\":1,\"162\":1,\"285\":1,\"526\":1,\"527\":1,\"531\":1}}],[\"空间复杂度\",{\"1\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"239\":1,\"246\":1,\"248\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"371\":1,\"380\":1,\"386\":1,\"396\":1,\"405\":1,\"416\":1,\"419\":1,\"428\":1,\"436\":1,\"443\":1,\"583\":1}}],[\"目的就是找出比初始值大\",{\"1\":{\"494\":1}}],[\"目的是用来判断是否符合二叉搜索树的定义\",{\"1\":{\"434\":1}}],[\"目标对象实现\",{\"1\":{\"17\":1}}],[\"目标对象接口\",{\"1\":{\"17\":1}}],[\"验证二叉搜索树\",{\"0\":{\"431\":1,\"432\":1}}],[\"越界退出循环\",{\"1\":{\"505\":1}}],[\"越小\",{\"1\":{\"428\":1}}],[\"越大\",{\"1\":{\"428\":1}}],[\"绝对值大小的比较\",{\"1\":{\"427\":1}}],[\"已访问的节点为灰色\",{\"1\":{\"532\":1,\"536\":1}}],[\"已经满足最大堆的性质\",{\"1\":{\"574\":1}}],[\"已经被判断了\",{\"1\":{\"503\":1}}],[\"已经把链表分成后两部分\",{\"1\":{\"222\":1}}],[\"已按\",{\"1\":{\"424\":1}}],[\"非递减\",{\"1\":{\"428\":1}}],[\"非递减顺序\",{\"1\":{\"424\":3}}],[\"非字母异位词\",{\"1\":{\"276\":2}}],[\"哨兵节点\",{\"1\":{\"417\":2}}],[\"除了存储答案的数组以外\",{\"1\":{\"428\":1}}],[\"除此之外\",{\"1\":{\"417\":1}}],[\"除去开头和末尾的空白字符\",{\"1\":{\"149\":1}}],[\"消耗\",{\"1\":{\"416\":3,\"419\":4}}],[\"头插节点\",{\"0\":{\"564\":1}}],[\"头尾比较\",{\"1\":{\"428\":1}}],[\"头节点\",{\"1\":{\"416\":1,\"564\":1}}],[\"头结点要特殊处理\",{\"1\":{\"207\":1}}],[\"插入元素的过程\",{\"1\":{\"574\":1}}],[\"插入和删除元素\",{\"1\":{\"501\":1}}],[\"插入当前元素到找到的位置\",{\"1\":{\"451\":1}}],[\"插入排序\",{\"0\":{\"450\":1},\"1\":{\"443\":1}}],[\"插入\",{\"1\":{\"415\":1,\"476\":1,\"568\":1}}],[\"插入哈希表\",{\"1\":{\"60\":1}}],[\"调用次数之和\",{\"1\":{\"416\":1,\"419\":1}}],[\"调用\",{\"1\":{\"412\":1}}],[\"调用你的实现\",{\"1\":{\"283\":1}}],[\"库\",{\"1\":{\"412\":1}}],[\"现在头节点是新节点\",{\"1\":{\"564\":1}}],[\"现在的最小值\",{\"1\":{\"448\":1}}],[\"现在\",{\"1\":{\"412\":1}}],[\"剩下的就是答案\",{\"1\":{\"406\":1}}],[\"至少大于等于\",{\"1\":{\"403\":1}}],[\"至少存在一个\",{\"1\":{\"146\":1}}],[\"写一个函数搜索\",{\"1\":{\"401\":1}}],[\"整个链式结构中不存在环\",{\"1\":{\"579\":1}}],[\"整型数组\",{\"1\":{\"401\":1}}],[\"整数\",{\"1\":{\"58\":1}}],[\"升序\",{\"1\":{\"401\":1}}],[\"二分法\",{\"0\":{\"502\":1}}],[\"二分查找模版\",{\"0\":{\"504\":1,\"505\":1}}],[\"二分查找模板\",{\"0\":{\"503\":1}}],[\"二分查找\",{\"0\":{\"399\":1,\"400\":1},\"2\":{\"409\":1,\"430\":1}}],[\"二叉堆\",{\"1\":{\"574\":2}}],[\"二叉堆插入\",{\"1\":{\"574\":1}}],[\"二叉\",{\"1\":{\"541\":1}}],[\"二叉数的遍历主要有前中后遍历和层次遍历\",{\"1\":{\"523\":1}}],[\"二叉搜索树\",{\"0\":{\"522\":1}}],[\"二叉搜索树定义如下\",{\"1\":{\"433\":1}}],[\"二叉搜索树中的搜索\",{\"0\":{\"391\":1,\"392\":1}}],[\"二叉搜索树中的众数\",{\"0\":{\"337\":1,\"338\":1}}],[\"二叉搜索树中\",{\"1\":{\"361\":1}}],[\"二叉搜索树的中序遍历是一个单调递增的数组\",{\"1\":{\"360\":1}}],[\"二叉搜索树的最小绝对差肯定是相邻的两个节点\",{\"1\":{\"359\":1}}],[\"二叉搜索树的最小绝对差\",{\"0\":{\"356\":1,\"357\":1}}],[\"二叉树节点类\",{\"1\":{\"517\":1}}],[\"二叉树最坏情况下为一条链\",{\"1\":{\"263\":1}}],[\"二叉树退化成一条链\",{\"1\":{\"182\":1}}],[\"二叉树退化为链表\",{\"1\":{\"70\":1,\"246\":1}}],[\"二叉树定义如下\",{\"1\":{\"109\":1}}],[\"二叉树的层平均值\",{\"1\":{\"544\":1}}],[\"二叉树的层次遍历ii\",{\"1\":{\"544\":1}}],[\"二叉树的层序遍历\",{\"1\":{\"544\":1}}],[\"二叉树的高度\",{\"1\":{\"517\":1}}],[\"二叉树的遍历中每个节点会被访问一次且只会被访问一次\",{\"1\":{\"351\":1,\"353\":1}}],[\"二叉树的特性\",{\"1\":{\"341\":1}}],[\"二叉树的所有节点有且只会被访问一次\",{\"1\":{\"263\":1}}],[\"二叉树的节点个数的范围是\",{\"1\":{\"176\":1,\"347\":1}}],[\"二叉树的右视图\",{\"0\":{\"174\":1,\"175\":1},\"1\":{\"544\":1}}],[\"二叉树的最近公共祖先\",{\"0\":{\"259\":1,\"260\":1}}],[\"二叉树的最小深度\",{\"0\":{\"98\":1,\"99\":1},\"1\":{\"517\":1,\"544\":1}}],[\"二叉树的最大深度其实跟二叉的高度的定义是一致\",{\"1\":{\"517\":1}}],[\"二叉树的最大深度\",{\"0\":{\"75\":1,\"76\":1},\"1\":{\"79\":1,\"80\":1,\"517\":1,\"544\":1}}],[\"二叉树的\",{\"1\":{\"77\":1}}],[\"二叉树\",{\"1\":{\"78\":1,\"101\":1,\"110\":1,\"118\":1,\"177\":1,\"348\":1},\"2\":{\"74\":1,\"85\":1,\"106\":1,\"115\":1,\"125\":1,\"184\":1,\"250\":1,\"344\":1,\"355\":1,\"364\":1,\"390\":1,\"398\":1,\"439\":1,\"546\":1}}],[\"抓住二叉搜索树的特性\",{\"1\":{\"395\":1}}],[\"小时内未完成支付\",{\"1\":{\"574\":1}}],[\"小顶堆\",{\"1\":{\"455\":1}}],[\"小于\",{\"1\":{\"433\":1}}],[\"小于等于\",{\"1\":{\"339\":1}}],[\"小\",{\"1\":{\"394\":1}}],[\"函数返回结果后\",{\"1\":{\"579\":1}}],[\"函数返回值一般为void\",{\"1\":{\"471\":1}}],[\"函数进行调整\",{\"1\":{\"494\":1}}],[\"函数进行国荣\",{\"1\":{\"484\":1}}],[\"函数\",{\"1\":{\"491\":1}}],[\"函数的返回值\",{\"1\":{\"504\":1}}],[\"函数的作用是确保内部容量大小问题\",{\"1\":{\"484\":1}}],[\"函数的嵌套调用\",{\"1\":{\"198\":1}}],[\"函数就直接返回\",{\"1\":{\"388\":1}}],[\"了解\",{\"0\":{\"490\":1}}],[\"了\",{\"1\":{\"387\":1}}],[\"合并过程\",{\"1\":{\"453\":1}}],[\"合并过程必须从两个树的根节点开始\",{\"1\":{\"384\":1}}],[\"合并排序好的两半\",{\"1\":{\"453\":1}}],[\"合并的规则是\",{\"1\":{\"384\":1}}],[\"合并二叉树\",{\"0\":{\"382\":1,\"383\":1}}],[\"想象一下\",{\"1\":{\"384\":1}}],[\"想象自己站在它的右侧\",{\"1\":{\"176\":1}}],[\"缩小\",{\"1\":{\"504\":1}}],[\"缩小左边界\",{\"1\":{\"380\":1}}],[\"缩小下边界\",{\"1\":{\"380\":1}}],[\"缩小右边界\",{\"1\":{\"380\":1}}],[\"缩小上边界\",{\"1\":{\"380\":1}}],[\"矩阵中心数字无法在迭代过程中被填充的问题\",{\"1\":{\"378\":1}}],[\"作为乘数\",{\"0\":{\"491\":1}}],[\"作为尾节点\",{\"1\":{\"417\":1}}],[\"作为头节点\",{\"1\":{\"417\":1}}],[\"作为迭代条件\",{\"1\":{\"378\":1}}],[\"作为主要的队列\",{\"1\":{\"239\":1}}],[\"上的\",{\"1\":{\"500\":1}}],[\"上边界缩减\",{\"1\":{\"378\":1}}],[\"上反复执行重复项删除操作\",{\"1\":{\"88\":1}}],[\"生成一个包含\",{\"1\":{\"376\":1}}],[\"生成器模式是让你能够逐步创建该复杂对象\",{\"1\":{\"46\":1}}],[\"生成器\",{\"0\":{\"45\":1},\"1\":{\"9\":1,\"47\":1}}],[\"螺旋矩阵\",{\"0\":{\"374\":1,\"375\":1}}],[\"极端的情况是\",{\"1\":{\"371\":1}}],[\"范围\",{\"1\":{\"369\":1}}],[\"范围内\",{\"1\":{\"109\":1,\"393\":1}}],[\"差值是一个正数\",{\"1\":{\"358\":1}}],[\"维护该层的最大值\",{\"1\":{\"352\":1}}],[\"到链表中\",{\"1\":{\"412\":1}}],[\"到\",{\"1\":{\"376\":1,\"449\":1}}],[\"到同层节点时\",{\"1\":{\"349\":1}}],[\"到达尾节点\",{\"1\":{\"171\":1}}],[\"等到再\",{\"1\":{\"349\":1}}],[\"等于链表的长度\",{\"1\":{\"412\":1}}],[\"等于\",{\"1\":{\"261\":1}}],[\"遇到二叉搜索树\",{\"1\":{\"434\":1}}],[\"遇到与\",{\"1\":{\"340\":2}}],[\"遇到问题\",{\"1\":{\"2\":1}}],[\"``mmaxcount来表示最大的重复次数\",{\"1\":{\"340\":1}}],[\"众数\",{\"1\":{\"339\":1}}],[\"−i\",{\"1\":{\"491\":1}}],[\"−\",{\"1\":{\"333\":2}}],[\"−1\",{\"1\":{\"276\":1,\"340\":1}}],[\"四数相加\",{\"0\":{\"329\":1,\"330\":1}}],[\"四数之和\",{\"0\":{\"156\":1,\"157\":1}}],[\"过程中也按\",{\"1\":{\"323\":1}}],[\"过去又发生了什么\",{\"1\":{\"5\":1}}],[\"参考垃圾回收算法中的三色标记\",{\"1\":{\"536\":1}}],[\"参考垃圾回收算法中标记法\",{\"1\":{\"532\":1}}],[\"参见示例\",{\"1\":{\"320\":1}}],[\"参数\",{\"1\":{\"471\":1}}],[\"参数根据情况而定\",{\"1\":{\"471\":1}}],[\"参数是树\",{\"1\":{\"394\":1}}],[\"参数是两棵待合并的树\",{\"1\":{\"385\":1}}],[\"参数为\",{\"1\":{\"359\":1}}],[\"参数及返回值\",{\"1\":{\"246\":1}}],[\"参数与返回值\",{\"1\":{\"68\":1}}],[\"叉树\",{\"1\":{\"320\":1,\"322\":2}}],[\"叉树的层序遍历\",{\"0\":{\"318\":1,\"319\":1}}],[\"固定长度的子数组\",{\"1\":{\"507\":2}}],[\"固定长度\",{\"1\":{\"315\":1}}],[\"字母总数为\",{\"1\":{\"314\":1}}],[\"字符中的前\",{\"1\":{\"367\":1}}],[\"字符数组尾元素\",{\"1\":{\"294\":1}}],[\"字符怎么办\",{\"1\":{\"274\":1}}],[\"字符串模式匹配问题\",{\"1\":{\"507\":1}}],[\"字符串不为空\",{\"1\":{\"93\":1}}],[\"字符串\",{\"0\":{\"148\":1},\"1\":{\"89\":1,\"147\":1,\"188\":1,\"293\":1,\"368\":1},\"2\":{\"97\":1,\"155\":1,\"193\":1,\"298\":1,\"373\":1}}],[\"多个线程访问有限资源\",{\"1\":{\"574\":1}}],[\"多个线程同时处于\",{\"1\":{\"24\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"463\":1}}],[\"多\",{\"1\":{\"313\":1}}],[\"针对该字母的数量比\",{\"1\":{\"313\":1}}],[\"出栈顺序\",{\"1\":{\"535\":1}}],[\"出栈一个元素\",{\"1\":{\"533\":1}}],[\"出现在\",{\"1\":{\"401\":1}}],[\"出现频率最高的元素\",{\"1\":{\"339\":1}}],[\"出现数量\",{\"1\":{\"313\":1}}],[\"出队节点\",{\"1\":{\"247\":1}}],[\"出队列一次\",{\"1\":{\"180\":1,\"182\":1}}],[\"出队\",{\"1\":{\"120\":1,\"121\":1}}],[\"出队串联\",{\"0\":{\"119\":1}}],[\"里面的字符构成\",{\"1\":{\"311\":1}}],[\"能满足\",{\"1\":{\"331\":1}}],[\"能不能由\",{\"1\":{\"311\":1}}],[\"能写一写自己的所思所想\",{\"1\":{\"4\":1}}],[\"赎金信\",{\"0\":{\"309\":1,\"310\":1}}],[\"转数组后\",{\"1\":{\"486\":1}}],[\"转换为\",{\"1\":{\"486\":1}}],[\"转换为数组\",{\"1\":{\"486\":1}}],[\"转换成数组\",{\"1\":{\"306\":1}}],[\"转化为字符串并返回\",{\"1\":{\"151\":1}}],[\"计数器\",{\"1\":{\"574\":1}}],[\"计数排序\",{\"0\":{\"456\":1},\"1\":{\"443\":1,\"456\":1,\"458\":1}}],[\"计数\",{\"1\":{\"306\":1}}],[\"计算哈希值\",{\"1\":{\"493\":1}}],[\"计算不同区域的碰撞情况\",{\"1\":{\"491\":1}}],[\"计算hash碰撞概率\",{\"1\":{\"491\":1}}],[\"计算当前参数下的hash碰撞概率\",{\"1\":{\"491\":1}}],[\"计算所有不同参数下的所有hashcode情况\",{\"1\":{\"491\":1}}],[\"计算数组的容量\",{\"1\":{\"486\":1}}],[\"计算出桶的数量\",{\"1\":{\"457\":1}}],[\"计算出最大值和最小值\",{\"1\":{\"457\":1}}],[\"计算滑动窗口的总和\",{\"1\":{\"230\":1}}],[\"计算每一位的平方和\",{\"1\":{\"200\":1}}],[\"计算树的深度需要遍历所有节点\",{\"1\":{\"81\":1,\"83\":1}}],[\"计算节点\",{\"1\":{\"79\":2}}],[\"暂无\",{\"1\":{\"303\":1}}],[\"暂存节点\",{\"1\":{\"244\":1}}],[\"公共尾部\",{\"1\":{\"581\":2}}],[\"公共静态方法\",{\"1\":{\"20\":1}}],[\"公司\",{\"0\":{\"303\":1}}],[\"唯一\",{\"1\":{\"301\":1}}],[\"唯一可能的三元组和为\",{\"1\":{\"137\":1}}],[\"唯一可能的三元组和不为\",{\"1\":{\"137\":1}}],[\"码表中的可打印字符\",{\"1\":{\"292\":1}}],[\"拷贝覆盖\",{\"1\":{\"286\":1}}],[\"题意\",{\"1\":{\"285\":1}}],[\"题目数据\",{\"1\":{\"579\":1}}],[\"题目\",{\"0\":{\"544\":1,\"574\":1}}],[\"题目要求不重复\",{\"1\":{\"141\":1}}],[\"题目描述\",{\"0\":{\"58\":1,\"67\":1,\"77\":1,\"88\":1,\"100\":1,\"109\":1,\"118\":1,\"128\":1,\"137\":1,\"146\":1,\"158\":1,\"167\":1,\"176\":1,\"187\":1,\"196\":1,\"205\":1,\"216\":1,\"228\":1,\"236\":1,\"244\":1,\"253\":1,\"261\":1,\"266\":1,\"274\":1,\"283\":1,\"292\":1,\"301\":1,\"311\":1,\"320\":1,\"331\":1,\"339\":1,\"347\":1,\"358\":1,\"367\":1,\"376\":1,\"384\":1,\"393\":1,\"401\":1,\"412\":1,\"424\":1,\"433\":1,\"579\":1}}],[\"题目地址\",{\"0\":{\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"578\":1}}],[\"评测机将使用以下代码测试您的解决方案\",{\"1\":{\"283\":1}}],[\"评测系统内部使用整数\",{\"1\":{\"128\":1}}],[\"使得区间不断向右收缩\",{\"1\":{\"505\":1}}],[\"使\",{\"1\":{\"283\":1}}],[\"使用的是单向链表\",{\"1\":{\"569\":1}}],[\"使用颜色标记节点的状态\",{\"1\":{\"532\":1,\"536\":1}}],[\"使用扰动函数的目的是\",{\"1\":{\"493\":1}}],[\"使用中序遍历\",{\"1\":{\"434\":1}}],[\"使用双重循环进行遍历求和\",{\"1\":{\"334\":1}}],[\"使用双指针\",{\"1\":{\"130\":1,\"150\":1,\"171\":1}}],[\"使用同样的遍历方式\",{\"1\":{\"333\":1}}],[\"使用字母的特性\",{\"1\":{\"278\":1}}],[\"使用哈希表进行记录不同字母出现的次数\",{\"1\":{\"277\":1}}],[\"使用变量\",{\"1\":{\"268\":1}}],[\"使用标准的栈操作\",{\"1\":{\"253\":1}}],[\"使用两个集合分别存储两个数组中的元素需要\",{\"1\":{\"306\":1}}],[\"使用两个指针分别指向位置\",{\"1\":{\"426\":1}}],[\"使用两个指针\",{\"1\":{\"294\":1}}],[\"使用两个指针来判断遍历情况\",{\"1\":{\"93\":1}}],[\"使用两个变量\",{\"1\":{\"268\":1}}],[\"使用两个队列\",{\"1\":{\"238\":1}}],[\"使用两重循环分别枚举前两个数\",{\"1\":{\"160\":1,\"161\":1}}],[\"使用\",{\"1\":{\"123\":1,\"148\":2,\"292\":1,\"352\":1,\"369\":1,\"378\":1,\"385\":1,\"486\":1,\"526\":1,\"531\":1}}],[\"使用递归解题也符合要求\",{\"1\":{\"109\":1,\"118\":1}}],[\"使用队列存储遍历过程中的每一对节点\",{\"1\":{\"71\":1}}],[\"使用一个哈希表map存储\",{\"1\":{\"333\":1}}],[\"使用一个队列存储每一层的遍历结果\",{\"1\":{\"247\":1}}],[\"使用一个队列存储每一层的节点\",{\"1\":{\"178\":1}}],[\"使用一个队列维护节点\",{\"1\":{\"72\":1}}],[\"使用一个集合\",{\"1\":{\"90\":1}}],[\"使用一个\",{\"1\":{\"52\":1}}],[\"使用原型模式创建对象\",{\"1\":{\"33\":1}}],[\"更改\",{\"1\":{\"283\":1}}],[\"更新\",{\"1\":{\"340\":1,\"359\":1,\"371\":1}}],[\"更新重复次数\",{\"1\":{\"340\":2}}],[\"更新start\",{\"1\":{\"153\":1}}],[\"更新为当前节点的值\",{\"1\":{\"434\":1}}],[\"更新为\",{\"1\":{\"123\":1}}],[\"您需要执行以下操作\",{\"1\":{\"283\":1}}],[\"统计每个值出现的次数\",{\"1\":{\"456\":1}}],[\"统计数组中每个值为i的元素出现的次数\",{\"1\":{\"456\":1}}],[\"统计\",{\"1\":{\"276\":2}}],[\"某对应字母数量不同\",{\"1\":{\"276\":1}}],[\"某个章节学习到了泰勒公式\",{\"1\":{\"2\":1}}],[\"互为字母异位词\",{\"1\":{\"274\":1}}],[\"互不相同\",{\"1\":{\"261\":1}}],[\"编写一个函数\",{\"1\":{\"292\":1}}],[\"编写一个函数来判断\",{\"1\":{\"274\":1}}],[\"编写一个算法来判断一个数\",{\"1\":{\"196\":1}}],[\"待交换的节点\",{\"1\":{\"268\":1}}],[\"祖先定义\",{\"1\":{\"262\":1}}],[\"祖先的定义\",{\"1\":{\"261\":1}}],[\"情况下\",{\"1\":{\"503\":1}}],[\"情况\",{\"1\":{\"261\":1}}],[\"若两链表\",{\"1\":{\"581\":2}}],[\"若两个元素相等\",{\"1\":{\"443\":2}}],[\"若两个四元组元素一一对应\",{\"1\":{\"158\":1}}],[\"若两字符串互为字母异位词\",{\"1\":{\"276\":1}}],[\"若\",{\"1\":{\"274\":1,\"276\":2}}],[\"若其左子节点\",{\"1\":{\"261\":1}}],[\"若节点\",{\"1\":{\"261\":1}}],[\"均存在于给定的二叉树中\",{\"1\":{\"261\":1}}],[\"百度百科\",{\"1\":{\"261\":1}}],[\"故空间复杂度为\",{\"1\":{\"256\":1}}],[\"或根结点\",{\"1\":{\"517\":1}}],[\"或最大\",{\"1\":{\"448\":1}}],[\"或\",{\"1\":{\"255\":1,\"261\":2}}],[\"或者将元素复制添加到\",{\"1\":{\"483\":1}}],[\"或者树\",{\"1\":{\"385\":1}}],[\"或者\",{\"1\":{\"236\":1,\"253\":2,\"261\":1,\"503\":1,\"523\":1}}],[\"或者链表中的一个有效索引\",{\"1\":{\"128\":1}}],[\"或者实例化什么子类\",{\"1\":{\"52\":1}}],[\"元素的数组缓冲区\",{\"1\":{\"478\":1}}],[\"元素的顺序可能发生改变\",{\"1\":{\"283\":1}}],[\"元素\",{\"1\":{\"255\":2}}],[\"执行效率最低\",{\"1\":{\"446\":1}}],[\"执行效率最高\",{\"1\":{\"446\":1}}],[\"执行中序遍历\",{\"1\":{\"342\":1}}],[\"执行\",{\"1\":{\"253\":1}}],[\"换句话说\",{\"1\":{\"253\":1}}],[\"推到队列的末尾\",{\"1\":{\"253\":1}}],[\"额外空间\",{\"1\":{\"248\":1}}],[\"额外空间复杂度的\",{\"1\":{\"146\":1}}],[\"退出循环\",{\"1\":{\"247\":1,\"428\":1,\"503\":2}}],[\"循环链表\",{\"0\":{\"561\":1},\"1\":{\"561\":1}}],[\"循环不变量原则\",{\"1\":{\"508\":1}}],[\"循环的工作\",{\"1\":{\"506\":1}}],[\"循环下完成两个\",{\"1\":{\"506\":1}}],[\"循环停止条件\",{\"1\":{\"503\":1,\"504\":1}}],[\"循环公式为\",{\"1\":{\"491\":1}}],[\"循环就终止\",{\"1\":{\"403\":1}}],[\"循环终止条件\",{\"1\":{\"379\":1,\"403\":1,\"583\":1}}],[\"循环条件是当前链表还有2个以上的节点\",{\"1\":{\"269\":1}}],[\"循环遍历\",{\"1\":{\"247\":1}}],[\"循环至单词的末尾\",{\"1\":{\"153\":1}}],[\"节点所在的层\",{\"1\":{\"517\":1}}],[\"节点值\",{\"1\":{\"517\":1,\"562\":1}}],[\"节点之间的链接\",{\"1\":{\"517\":1}}],[\"节点的高度\",{\"1\":{\"517\":1}}],[\"节点的深度\",{\"1\":{\"517\":1}}],[\"节点的子节点的数量\",{\"1\":{\"517\":1}}],[\"节点的度\",{\"1\":{\"517\":1}}],[\"节点的右子树只包含\",{\"1\":{\"433\":1}}],[\"节点的左\",{\"1\":{\"433\":1}}],[\"节点为\",{\"1\":{\"387\":2}}],[\"节点不为\",{\"1\":{\"387\":2}}],[\"节点\",{\"1\":{\"261\":3}}],[\"节点入队\",{\"1\":{\"247\":1}}],[\"节点是这一行的第一个\",{\"1\":{\"120\":1,\"121\":1}}],[\"交集\",{\"1\":{\"301\":1}}],[\"交换他们的元素\",{\"1\":{\"574\":1}}],[\"交换链表中的节点\",{\"1\":{\"550\":1}}],[\"交换pivot到它最终的位置\",{\"1\":{\"454\":1}}],[\"交换array\",{\"1\":{\"454\":1}}],[\"交换\",{\"1\":{\"247\":1,\"294\":1,\"295\":1,\"446\":1}}],[\"交换左右子树\",{\"1\":{\"246\":1}}],[\"交替向中间移动\",{\"1\":{\"139\":1,\"140\":1}}],[\"旧\",{\"1\":{\"244\":1}}],[\"列队\",{\"2\":{\"241\":1}}],[\"列表中\",{\"1\":{\"527\":1}}],[\"列表中的节点数目在范围\",{\"1\":{\"205\":1}}],[\"列表\",{\"1\":{\"236\":1}}],[\"次交换\",{\"1\":{\"296\":1}}],[\"次\",{\"1\":{\"236\":1,\"253\":1,\"256\":1}}],[\"否则也不会导致\",{\"1\":{\"505\":1}}],[\"否则返回\",{\"1\":{\"311\":1,\"401\":1}}],[\"否则\",{\"1\":{\"236\":1,\"253\":1,\"384\":1}}],[\"否则就将集合中元素复制到\",{\"1\":{\"482\":1}}],[\"否则就将元素放进数组\",{\"1\":{\"93\":1}}],[\"否则就是当前节点\",{\"1\":{\"394\":1}}],[\"否则就让前一个节点指向他\",{\"1\":{\"120\":1}}],[\"压入栈顶\",{\"1\":{\"236\":1}}],[\"类是很粗糙的\",{\"1\":{\"511\":1}}],[\"类似之前算法的处理方式\",{\"1\":{\"504\":1}}],[\"类型\",{\"0\":{\"518\":1},\"1\":{\"482\":1}}],[\"类\",{\"1\":{\"236\":1,\"253\":1,\"412\":1,\"513\":1}}],[\"类的实例对象在\",{\"1\":{\"23\":1}}],[\"用作元素的集合\",{\"1\":{\"511\":1}}],[\"用于处理具有过期时间\",{\"1\":{\"574\":1}}],[\"用于保存遍历序列\",{\"1\":{\"525\":1}}],[\"用于默认大小的空实例的共享空数组实例\",{\"1\":{\"478\":1}}],[\"用于空实例的共享空数组实例\",{\"1\":{\"478\":1}}],[\"用于存放合并后的有序元素\",{\"1\":{\"453\":1}}],[\"用\",{\"1\":{\"340\":1,\"486\":1}}],[\"用户评测\",{\"1\":{\"283\":1}}],[\"用一个队列存放\",{\"1\":{\"255\":2}}],[\"用栈实现队列\",{\"0\":{\"251\":1,\"252\":1}}],[\"用队列实现栈\",{\"0\":{\"234\":1,\"235\":1}}],[\"用循环解决\",{\"1\":{\"208\":1}}],[\"滑动串口的指针和右指针\",{\"1\":{\"232\":1}}],[\"滑动窗口\",{\"0\":{\"230\":1,\"507\":1},\"1\":{\"229\":1}}],[\"窗口的长度为子数组的最小长度\",{\"1\":{\"230\":1}}],[\"符合题目时\",{\"1\":{\"230\":1}}],[\"子字符串问题\",{\"1\":{\"507\":2}}],[\"子集问题\",{\"1\":{\"470\":1}}],[\"子序列的长度逐渐增加\",{\"1\":{\"452\":1}}],[\"子树\",{\"1\":{\"433\":1}}],[\"子树中\",{\"1\":{\"261\":1}}],[\"子数组\",{\"1\":{\"228\":2}}],[\"子模块\",{\"1\":{\"0\":1}}],[\"长度\",{\"1\":{\"583\":2}}],[\"长度为\",{\"1\":{\"581\":2}}],[\"长度为奇数时\",{\"1\":{\"191\":1}}],[\"长度正确的预期答案\",{\"1\":{\"283\":1}}],[\"长度不相等\",{\"1\":{\"276\":1}}],[\"长度最小的子数组\",{\"0\":{\"226\":1,\"227\":1}}],[\"反向填充数组\",{\"1\":{\"456\":1,\"458\":1}}],[\"反向\",{\"1\":{\"220\":1}}],[\"反转链表\",{\"0\":{\"214\":1,\"215\":1}}],[\"反转字符串\",{\"0\":{\"290\":1,\"291\":1,\"365\":1,\"366\":1},\"1\":{\"153\":1}}],[\"反转字符串中的单词\",{\"0\":{\"144\":1,\"145\":1}}],[\"反转后的字符串需要将单词间的空格减少到仅有一个\",{\"1\":{\"146\":1}}],[\"反转后的字符串中不能存在前导空格和尾随空格\",{\"1\":{\"146\":1}}],[\"引用\",{\"1\":{\"219\":1,\"412\":1}}],[\"引入一个\",{\"1\":{\"122\":1}}],[\"直接返回\",{\"1\":{\"244\":1,\"261\":3,\"340\":1,\"359\":1,\"394\":1,\"403\":1,\"434\":2}}],[\"直接删除\",{\"0\":{\"206\":1}}],[\"直到满足最大堆的性质\",{\"1\":{\"574\":1}}],[\"直到查询到不冲突\",{\"1\":{\"465\":1}}],[\"直到最高位\",{\"1\":{\"458\":1}}],[\"直到最后一个节点才进行处理\",{\"1\":{\"178\":1,\"179\":1}}],[\"直到增量为1\",{\"1\":{\"452\":1}}],[\"直到全部待排序的数据元素排完\",{\"1\":{\"448\":1}}],[\"直到剩下一个数字\",{\"1\":{\"445\":1}}],[\"直到不满足\",{\"1\":{\"232\":1}}],[\"直到符合最小窗口的长度\",{\"1\":{\"232\":1}}],[\"直到\",{\"1\":{\"123\":1}}],[\"直到无法继续删除\",{\"1\":{\"88\":1}}],[\"直到遍历完成\",{\"1\":{\"82\":1}}],[\"直到现在\",{\"1\":{\"4\":1}}],[\"虚拟节点\",{\"1\":{\"205\":1}}],[\"虚拟头节点\",{\"0\":{\"209\":1,\"268\":1,\"548\":1},\"1\":{\"122\":1,\"123\":1}}],[\"新节点\",{\"1\":{\"564\":3}}],[\"新节点的\",{\"1\":{\"564\":1}}],[\"新节点的头节点为null\",{\"1\":{\"564\":1}}],[\"新节点为白色\",{\"1\":{\"532\":1,\"536\":1}}],[\"新节点会成为链表的第一个节点\",{\"1\":{\"412\":1}}],[\"新增的数据位置是\",{\"1\":{\"486\":1}}],[\"新的最小值\",{\"1\":{\"448\":1}}],[\"新的头节点\",{\"1\":{\"205\":1}}],[\"新建一个相同类型的对象\",{\"1\":{\"31\":1}}],[\"移除所有数值等于\",{\"1\":{\"283\":1}}],[\"移除元素\",{\"0\":{\"281\":1,\"282\":1}}],[\"移除并返回栈顶元素\",{\"1\":{\"236\":1}}],[\"移除链表元素\",{\"0\":{\"203\":1,\"204\":1},\"1\":{\"548\":1}}],[\"移动的时候要注意处理相同元素情况\",{\"1\":{\"139\":2}}],[\"移动\",{\"1\":{\"139\":2}}],[\"主要通过实现\",{\"1\":{\"574\":1}}],[\"主函数\",{\"1\":{\"454\":1}}],[\"主操作不变\",{\"1\":{\"200\":1}}],[\"主管\",{\"1\":{\"47\":1}}],[\"快速排序\",{\"1\":{\"443\":1,\"454\":1}}],[\"快慢指针法\",{\"1\":{\"506\":1}}],[\"快慢指针\",{\"0\":{\"549\":1},\"1\":{\"200\":1}}],[\"快乐数\",{\"0\":{\"194\":1,\"195\":1},\"1\":{\"196\":2,\"199\":1}}],[\"检查当前节点的值是否在允许的范围内\",{\"1\":{\"437\":1}}],[\"检查它是否轴对称\",{\"1\":{\"67\":1}}],[\"检测一个链表是否有环\",{\"1\":{\"198\":1}}],[\"链长度为\",{\"1\":{\"583\":2}}],[\"链接在内存中各个节点\",{\"1\":{\"562\":1}}],[\"链中的所有其他数字都是节点\",{\"1\":{\"198\":1}}],[\"链表必须\",{\"1\":{\"579\":1}}],[\"链表性能分析\",{\"0\":{\"568\":1}}],[\"链表操作\",{\"0\":{\"563\":1}}],[\"链表节点类\",{\"1\":{\"562\":1}}],[\"链表节点交换的指针变动\",{\"1\":{\"269\":1}}],[\"链表的组成单位是\",{\"1\":{\"562\":1}}],[\"链表的基本操作\",{\"0\":{\"551\":1}}],[\"链表在内存中可不是连续分布的\",{\"1\":{\"562\":1}}],[\"链表存储方式\",{\"0\":{\"562\":1}}],[\"链表类型\",{\"0\":{\"558\":1}}],[\"链表是通过\",{\"1\":{\"562\":1}}],[\"链表是一种通过指针串联在一起的线性结构\",{\"1\":{\"557\":1}}],[\"链表是什么\",{\"0\":{\"557\":1}}],[\"链表理论基础\",{\"0\":{\"556\":1}}],[\"链表相交\",{\"0\":{\"552\":1,\"577\":1,\"578\":1},\"1\":{\"552\":1}}],[\"链表总结篇\",{\"0\":{\"547\":1}}],[\"链表和红黑树\",{\"1\":{\"492\":1}}],[\"链表基本操作\",{\"1\":{\"413\":1}}],[\"链表结果\",{\"1\":{\"413\":1}}],[\"链表变为\",{\"1\":{\"412\":2}}],[\"链表可以选用迭代或递归方式完成反转\",{\"1\":{\"216\":1}}],[\"链表中数据的插入\",{\"1\":{\"569\":1}}],[\"链表中节点的数目在范围\",{\"1\":{\"266\":1}}],[\"链表中节点的数目范围是\",{\"1\":{\"216\":1}}],[\"链表中节点的数目范围在范围\",{\"1\":{\"128\":1}}],[\"链表中结点的数目为\",{\"1\":{\"167\":1}}],[\"链表中没有环\",{\"1\":{\"128\":1}}],[\"链表中有一个环\",{\"1\":{\"128\":2}}],[\"链表\",{\"1\":{\"128\":1,\"129\":1,\"168\":1,\"205\":1,\"217\":1,\"267\":1,\"461\":1,\"579\":6,\"580\":1},\"2\":{\"134\":1,\"173\":1,\"213\":1,\"225\":1,\"421\":1,\"555\":1,\"571\":1,\"585\":1}}],[\"结合虚拟头结点\",{\"1\":{\"550\":1}}],[\"结果存放\",{\"1\":{\"491\":1}}],[\"结果为\",{\"1\":{\"196\":1,\"261\":2,\"493\":2}}],[\"结点右子树中所含节点的值\",{\"1\":{\"339\":1}}],[\"结点左子树中所含节点的值\",{\"1\":{\"339\":1}}],[\"结构型模式\",{\"0\":{\"10\":1}}],[\"组成的新数组\",{\"1\":{\"424\":1}}],[\"组成\",{\"1\":{\"187\":1}}],[\"组合问题\",{\"1\":{\"470\":1}}],[\"组合\",{\"1\":{\"139\":1}}],[\"保持其原始结构\",{\"1\":{\"579\":1}}],[\"保证\",{\"1\":{\"579\":1}}],[\"保证首次遇到的一定是最右边的节点\",{\"1\":{\"181\":1,\"182\":1}}],[\"保存节点值\",{\"1\":{\"525\":1}}],[\"保存了\",{\"1\":{\"16\":1}}],[\"按照通常的思维\",{\"1\":{\"380\":1}}],[\"按照题目进行模拟\",{\"1\":{\"378\":1}}],[\"按照从顶部到底部的顺序\",{\"1\":{\"176\":1}}],[\"按照层序遍历的方式\",{\"1\":{\"119\":1}}],[\"根\",{\"1\":{\"533\":1}}],[\"根节点所在层为\",{\"1\":{\"517\":1}}],[\"根节点之外的节点\",{\"1\":{\"517\":1}}],[\"根节点的值是\",{\"1\":{\"433\":1}}],[\"根节点和\",{\"1\":{\"324\":1}}],[\"根节点\",{\"1\":{\"176\":1,\"522\":2,\"529\":1,\"530\":1,\"531\":1}}],[\"根据当前子序列和大小的情况\",{\"1\":{\"507\":1}}],[\"根据上面的构造函数可知\",{\"1\":{\"484\":1}}],[\"根据容量给\",{\"1\":{\"480\":1}}],[\"根据集合的构造函数\",{\"0\":{\"482\":1}}],[\"根据集合\",{\"1\":{\"479\":1}}],[\"根据初始容量来创建\",{\"0\":{\"480\":1}}],[\"根据初始容量\",{\"1\":{\"479\":1}}],[\"根据桶的长度以及数据的最大值和最小值\",{\"1\":{\"457\":1}}],[\"根据中序遍历结果\",{\"1\":{\"359\":1}}],[\"根据\",{\"1\":{\"54\":1}}],[\"刚好指向倒数第\",{\"1\":{\"171\":1}}],[\"刚好走好倒数第\",{\"1\":{\"169\":1}}],[\"怎么知道是倒数第\",{\"1\":{\"171\":1}}],[\"怎么能靠单纯的思考就能的出来呢\",{\"1\":{\"2\":1}}],[\"先将根结点入栈\",{\"1\":{\"533\":1}}],[\"先将数据放入堆中\",{\"1\":{\"455\":1}}],[\"先记录队列中的结点数量\",{\"1\":{\"526\":1}}],[\"先进先出\",{\"1\":{\"524\":1}}],[\"先按低位排序\",{\"1\":{\"458\":1}}],[\"先判断长度一致\",{\"1\":{\"278\":1}}],[\"先判断头结点的情况\",{\"1\":{\"206\":1}}],[\"先存储\",{\"1\":{\"219\":1}}],[\"先递归右子树\",{\"1\":{\"181\":1,\"182\":1}}],[\"先走\",{\"1\":{\"169\":1,\"171\":1}}],[\"先翻转整个字符串\",{\"1\":{\"152\":1}}],[\"跳过重复数字\",{\"1\":{\"162\":1}}],[\"跳过单词间空格\",{\"1\":{\"151\":1}}],[\"枚举四元组的时间复杂度是\",{\"1\":{\"162\":1}}],[\"枚举第二个数\",{\"1\":{\"162\":1}}],[\"枚举第一个数\",{\"1\":{\"162\":1}}],[\"枚举类\",{\"0\":{\"28\":1}}],[\"81\",{\"1\":{\"200\":4}}],[\"82\",{\"1\":{\"196\":3}}],[\"8\",{\"1\":{\"158\":1,\"261\":2,\"301\":1,\"320\":2,\"376\":1,\"490\":1,\"494\":1,\"504\":1,\"579\":7}}],[\"任何带有\",{\"1\":{\"478\":1}}],[\"任何时候都要去寻找反馈\",{\"1\":{\"5\":1}}],[\"任意二叉树\",{\"0\":{\"540\":1}}],[\"任意放一个进入结果数组即可\",{\"1\":{\"427\":1}}],[\"任意顺序\",{\"1\":{\"158\":1,\"339\":1}}],[\"翻转链表\",{\"1\":{\"549\":1}}],[\"翻转这棵二叉树\",{\"1\":{\"244\":1}}],[\"翻转二叉树是改变树\",{\"1\":{\"245\":1}}],[\"翻转二叉树\",{\"0\":{\"242\":1,\"243\":1}}],[\"翻转单词\",{\"1\":{\"153\":1}}],[\"翻转每一个单词\",{\"1\":{\"153\":1}}],[\"翻转每个单词\",{\"1\":{\"153\":1}}],[\"翻转字符串\",{\"1\":{\"153\":1}}],[\"添加一个元素在数组末尾\",{\"1\":{\"574\":1}}],[\"添加中节点\",{\"1\":{\"537\":3}}],[\"添加左节点\",{\"1\":{\"537\":3}}],[\"添加右节点\",{\"1\":{\"537\":3}}],[\"添加成功返回\",{\"1\":{\"486\":1}}],[\"添加操作\",{\"0\":{\"484\":1,\"485\":1}}],[\"添加单词\",{\"1\":{\"151\":1}}],[\"添加元素\",{\"1\":{\"95\":2,\"461\":1}}],[\"删除为\",{\"1\":{\"568\":1}}],[\"删除链表的第\",{\"1\":{\"551\":1}}],[\"删除链表的中间节点\",{\"1\":{\"550\":1}}],[\"删除链表的倒数第\",{\"0\":{\"166\":1},\"1\":{\"167\":1}}],[\"删除链表的倒数第n个结点\",{\"0\":{\"165\":1}}],[\"删除链表\",{\"1\":{\"550\":1}}],[\"删除倒数第\",{\"0\":{\"550\":1},\"1\":{\"550\":1}}],[\"删除最近添加但尚未删除的元素\",{\"1\":{\"511\":1}}],[\"删除\",{\"1\":{\"476\":1,\"569\":1}}],[\"删除元素\",{\"1\":{\"461\":1}}],[\"删除方式一样\",{\"1\":{\"210\":1}}],[\"删除值相同的头结点后\",{\"1\":{\"208\":1}}],[\"删除节点\",{\"0\":{\"567\":1},\"1\":{\"205\":1,\"415\":1}}],[\"删除首尾空格\",{\"1\":{\"151\":1}}],[\"删除字符串中的所有相邻重复项\",{\"0\":{\"86\":1,\"87\":1}}],[\"倒数第\",{\"1\":{\"170\":1}}],[\"倒序遍历字符串\",{\"1\":{\"150\":1}}],[\"倒序遍历+双指针\",{\"0\":{\"150\":1}}],[\"倒排字符串列表\",{\"1\":{\"148\":1}}],[\"占用\",{\"1\":{\"149\":1,\"151\":1,\"248\":1,\"526\":1}}],[\"线性\",{\"1\":{\"475\":1}}],[\"线性探测法\",{\"0\":{\"465\":1}}],[\"线性遍历字符串\",{\"1\":{\"149\":1,\"151\":1}}],[\"线程安全\",{\"0\":{\"25\":1},\"1\":{\"25\":1}}],[\"正确的递归终止条件\",{\"1\":{\"437\":1}}],[\"正方形矩阵\",{\"1\":{\"376\":1}}],[\"正则匹配连续的空白字符作为分隔符分割\",{\"1\":{\"149\":1}}],[\"正常情况下\",{\"1\":{\"31\":1}}],[\"解数独等等\",{\"1\":{\"470\":1}}],[\"解决什么问题\",{\"0\":{\"470\":1}}],[\"解决\",{\"1\":{\"189\":1}}],[\"解法也相似\",{\"1\":{\"160\":1}}],[\"解法\",{\"1\":{\"146\":1}}],[\"解释\",{\"1\":{\"58\":1,\"88\":1,\"109\":1,\"118\":1,\"128\":3,\"137\":3,\"146\":2,\"196\":1,\"228\":1,\"236\":1,\"253\":1,\"261\":2,\"283\":2,\"301\":1,\"331\":1,\"401\":2,\"412\":1,\"424\":1,\"433\":1,\"579\":3}}],[\"原则\",{\"1\":{\"574\":1}}],[\"原来的\",{\"1\":{\"485\":1}}],[\"原地\",{\"1\":{\"146\":1,\"283\":1,\"285\":1,\"292\":1}}],[\"原型\",{\"1\":{\"32\":1}}],[\"原型指被复制的实例\",{\"1\":{\"31\":1}}],[\"原型模式将克隆过程委派给被克隆的实际对象\",{\"1\":{\"32\":1}}],[\"原型模式能够使你用原型实例指定创建对象的种类\",{\"1\":{\"31\":1}}],[\"原型模式\",{\"0\":{\"30\":1}}],[\"顺序颠倒且\",{\"1\":{\"146\":1}}],[\"忽略答案的存储空间\",{\"1\":{\"141\":1}}],[\"往后的查找不满足\",{\"1\":{\"141\":1}}],[\"往中间靠拢\",{\"1\":{\"141\":1}}],[\"排列问题\",{\"1\":{\"470\":1}}],[\"排在\",{\"1\":{\"443\":2}}],[\"排除重复答案\",{\"1\":{\"141\":1}}],[\"排序算法\",{\"2\":{\"459\":1}}],[\"排序方式\",{\"1\":{\"443\":1}}],[\"排序前\",{\"1\":{\"443\":2}}],[\"排序后\",{\"1\":{\"424\":1,\"443\":2}}],[\"排序的整数数组\",{\"1\":{\"424\":1}}],[\"排序的时间复杂度是\",{\"1\":{\"162\":1}}],[\"排序的时间复杂度为\",{\"1\":{\"139\":1,\"141\":1}}],[\"排序解决重复问题\",{\"1\":{\"161\":1}}],[\"排序\",{\"1\":{\"160\":1,\"283\":1,\"424\":2}}],[\"排序+双指针\",{\"0\":{\"139\":1}}],[\"三重循环枚举\",{\"1\":{\"141\":1}}],[\"三数之和\",{\"0\":{\"135\":1,\"136\":1},\"1\":{\"159\":1,\"160\":1}}],[\"右子节点入队\",{\"1\":{\"525\":1}}],[\"右子节点引用\",{\"1\":{\"517\":1}}],[\"右子树\",{\"1\":{\"261\":2,\"529\":1,\"530\":1,\"531\":1}}],[\"右子树都不包含\",{\"1\":{\"261\":1}}],[\"右子树中\",{\"1\":{\"261\":1}}],[\"右子树的所有节点的值\",{\"1\":{\"522\":1}}],[\"右子树的节点都比根节点大\",{\"1\":{\"395\":1}}],[\"右子树的深度\",{\"1\":{\"79\":1}}],[\"右子树的最大深度\",{\"1\":{\"79\":1,\"80\":1,\"81\":1}}],[\"右移16位\",{\"1\":{\"493\":1}}],[\"右半部分的起始索引\",{\"1\":{\"453\":1}}],[\"右\",{\"1\":{\"261\":1,\"263\":1,\"362\":1,\"533\":1,\"535\":3}}],[\"右边界缩减\",{\"1\":{\"378\":1}}],[\"右边\",{\"1\":{\"139\":1}}],[\"有\",{\"1\":{\"581\":1}}],[\"有两个变量\",{\"1\":{\"581\":1}}],[\"有两道题\",{\"1\":{\"517\":1}}],[\"有交点\",{\"1\":{\"579\":1}}],[\"有什么区别\",{\"1\":{\"490\":1}}],[\"有几种排列方式\",{\"1\":{\"470\":1}}],[\"有序数组的平方\",{\"0\":{\"422\":1,\"423\":1}}],[\"有可能两个指针都指向\",{\"1\":{\"582\":1}}],[\"有可能是\",{\"1\":{\"505\":1}}],[\"有可能是重复答案\",{\"1\":{\"139\":1}}],[\"有可能出现在\",{\"1\":{\"443\":1}}],[\"有可能越界\",{\"1\":{\"370\":1}}],[\"有效\",{\"1\":{\"433\":1}}],[\"有效的字母异位词\",{\"0\":{\"272\":1,\"273\":1},\"1\":{\"314\":1}}],[\"有效的括号\",{\"0\":{\"185\":1,\"186\":1}}],[\"有效字符串需满足\",{\"1\":{\"187\":1}}],[\"有这么一个问题\",{\"1\":{\"4\":1}}],[\"终止循环\",{\"1\":{\"139\":1}}],[\"终止条件\",{\"1\":{\"68\":1,\"79\":1,\"244\":1,\"246\":1,\"261\":1,\"471\":2}}],[\"又是最小\",{\"1\":{\"139\":1}}],[\"记录头节点\",{\"1\":{\"564\":1}}],[\"记录\",{\"1\":{\"313\":1}}],[\"记录对于每个固定指针\",{\"1\":{\"139\":1}}],[\"记得建立\",{\"1\":{\"0\":1}}],[\"处理根节点\",{\"1\":{\"529\":1}}],[\"处理节点\",{\"1\":{\"471\":1}}],[\"处理的时候\",{\"1\":{\"434\":1}}],[\"处理后变成根节点的右子树\",{\"1\":{\"246\":1}}],[\"处理左子树\",{\"1\":{\"246\":1}}],[\"处理右子树后\",{\"1\":{\"246\":1}}],[\"处理一次即可\",{\"1\":{\"139\":1}}],[\"处\",{\"1\":{\"139\":1}}],[\"暴力枚举\",{\"1\":{\"139\":1}}],[\"答案中不可以包含重复的三元组\",{\"1\":{\"137\":1}}],[\"答案保证唯一\",{\"1\":{\"88\":1}}],[\"请不要使用内置的\",{\"1\":{\"412\":1}}],[\"请找出该二叉树中每一层的最大值\",{\"1\":{\"347\":1}}],[\"请尝试设计一个\",{\"1\":{\"228\":1}}],[\"请尝试使用\",{\"1\":{\"146\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"579\":1}}],[\"请你找出并返回满足下述全部条件且不重复的四元组\",{\"1\":{\"158\":1}}],[\"请你\",{\"1\":{\"424\":1}}],[\"请你计算有多少个元组\",{\"1\":{\"331\":1}}],[\"请你仅使用两个栈实现先入先出队列\",{\"1\":{\"253\":1}}],[\"请你仅使用两个队列实现一个后入先出\",{\"1\":{\"236\":1}}],[\"请你反转链表\",{\"1\":{\"216\":1}}],[\"请你反转字符串中\",{\"1\":{\"146\":1}}],[\"请你删除链表中所有满足\",{\"1\":{\"205\":1}}],[\"请你在该数组中找出\",{\"1\":{\"58\":1}}],[\"请\",{\"1\":{\"137\":1}}],[\"且元素按顺时针顺序螺旋排列的\",{\"1\":{\"376\":1}}],[\"且分列\",{\"1\":{\"261\":1}}],[\"且在同一重循环中不能多次枚举到相同的元素\",{\"1\":{\"160\":1}}],[\"且不包含任何额外的空格\",{\"1\":{\"146\":1}}],[\"且不重复的三元组\",{\"1\":{\"137\":1}}],[\"且\",{\"1\":{\"137\":1,\"261\":2}}],[\"k−1\",{\"1\":{\"200\":2}}],[\"k++\",{\"1\":{\"141\":1,\"453\":5}}],[\"k\",{\"1\":{\"137\":4,\"139\":9,\"141\":9,\"200\":1,\"283\":11,\"285\":1,\"331\":3,\"367\":8,\"369\":2,\"371\":4,\"453\":3,\"553\":1}}],[\"key上\",{\"1\":{\"462\":1}}],[\"key\",{\"1\":{\"61\":1,\"333\":1,\"461\":1,\"462\":1,\"493\":4}}],[\"第一个值和第二个值进行异或运算\",{\"1\":{\"493\":1}}],[\"第一个值\",{\"1\":{\"493\":1}}],[\"第一次\",{\"1\":{\"582\":1}}],[\"第一次扩容的数组长度\",{\"1\":{\"485\":1}}],[\"第一次扩容\",{\"0\":{\"484\":1}}],[\"第一次循环后的情况如下\",{\"1\":{\"247\":1}}],[\"第一次符合条件为窗口长度\",{\"1\":{\"232\":1}}],[\"第一次相遇时\",{\"1\":{\"132\":1}}],[\"第一次相遇\",{\"1\":{\"132\":1}}],[\"第三个元素导致的三数之和有可能导致\",{\"1\":{\"141\":1}}],[\"第三个元素会导致和为\",{\"1\":{\"139\":1}}],[\"第三重循环枚举到的元素不小于当前第二重循环枚举到的元素\",{\"1\":{\"141\":1}}],[\"第二个值\",{\"1\":{\"493\":1}}],[\"第二个枚举元素的下标要右边移动\",{\"1\":{\"141\":1}}],[\"第二次扩容\",{\"0\":{\"485\":1}}],[\"第二次相遇\",{\"1\":{\"132\":1}}],[\"第二重循环枚举到的元素不小于当前第一重循环枚举到的元素\",{\"1\":{\"141\":1}}],[\"判断其是否是一个有效的二叉搜索树\",{\"1\":{\"433\":1}}],[\"判断条件\",{\"1\":{\"403\":1}}],[\"判断是否是众数\",{\"1\":{\"342\":1}}],[\"判断是否存在三元组\",{\"1\":{\"137\":1}}],[\"判断\",{\"1\":{\"261\":1,\"311\":1}}],[\"判断字符串是否有效\",{\"1\":{\"187\":1}}],[\"判断链表是否环\",{\"1\":{\"131\":1}}],[\"判断两节点\",{\"1\":{\"68\":2}}],[\"恰好等于\",{\"1\":{\"130\":1}}],[\"圈的环长度\",{\"1\":{\"130\":1}}],[\"加入到结果集\",{\"1\":{\"537\":3}}],[\"加入空节点做为标记\",{\"1\":{\"537\":3}}],[\"加入根节点\",{\"1\":{\"525\":1}}],[\"加大随机性\",{\"1\":{\"493\":1}}],[\"加上\",{\"1\":{\"130\":1}}],[\"加载时\",{\"1\":{\"27\":1}}],[\"走完\",{\"1\":{\"581\":2}}],[\"走两步\",{\"1\":{\"200\":1}}],[\"走一步\",{\"1\":{\"200\":1}}],[\"走了\",{\"1\":{\"132\":2}}],[\"走过的节点数为\",{\"1\":{\"130\":2}}],[\"走到空节点时时\",{\"1\":{\"169\":1}}],[\"走到\",{\"1\":{\"130\":1}}],[\"z\",{\"1\":{\"130\":1,\"132\":1}}],[\"your\",{\"1\":{\"256\":1,\"416\":1}}],[\"y+z\",{\"1\":{\"130\":3}}],[\"y\",{\"1\":{\"130\":1,\"162\":6}}],[\"yml\",{\"1\":{\"0\":2}}],[\"步骤1\",{\"1\":{\"564\":2}}],[\"步骤解析\",{\"1\":{\"445\":1}}],[\"步骤二\",{\"1\":{\"270\":1}}],[\"步骤三\",{\"1\":{\"270\":1}}],[\"步骤一\",{\"1\":{\"270\":1}}],[\"步才能到达慢跑者\",{\"1\":{\"200\":1}}],[\"步\",{\"1\":{\"130\":1,\"132\":2,\"169\":1,\"171\":1}}],[\"分钟或\",{\"1\":{\"574\":1}}],[\"分析如下\",{\"1\":{\"503\":1}}],[\"分布的越均匀越好\",{\"1\":{\"457\":1}}],[\"分隔开\",{\"1\":{\"146\":1}}],[\"分别出发\",{\"1\":{\"581\":1}}],[\"分别从\",{\"1\":{\"581\":1}}],[\"分别对应的实现类是哪个\",{\"1\":{\"574\":1}}],[\"分别对左右两半进行排序\",{\"1\":{\"453\":1}}],[\"分别对这两半进行排序\",{\"1\":{\"453\":1}}],[\"分别指向待反转的范围\",{\"1\":{\"371\":1}}],[\"分别指向字符数组首元素\",{\"1\":{\"294\":1}}],[\"分别指向滑动窗口的开始位置和结束位置\",{\"1\":{\"230\":1}}],[\"分别在数组索引\",{\"1\":{\"139\":1}}],[\"分别定义为\",{\"1\":{\"130\":1}}],[\"分支\",{\"1\":{\"0\":1}}],[\"环形入口节点到\",{\"1\":{\"130\":1}}],[\"环形证明\",{\"1\":{\"129\":1}}],[\"环形链表\",{\"0\":{\"126\":1,\"127\":1,\"553\":1},\"1\":{\"553\":1}}],[\"仅用\",{\"1\":{\"579\":1}}],[\"仅包含小写字母\",{\"1\":{\"274\":1}}],[\"仅作为临时放置\",{\"1\":{\"239\":1}}],[\"仅由小写英文组成\",{\"1\":{\"367\":1}}],[\"仅由小写英文字母组成\",{\"1\":{\"88\":1}}],[\"仅由括号\",{\"1\":{\"187\":1}}],[\"仅仅是为了标识链表的实际情况\",{\"1\":{\"128\":1}}],[\"开始相交\",{\"1\":{\"579\":1}}],[\"开始\",{\"1\":{\"128\":1,\"412\":1,\"475\":2,\"501\":1}}],[\"索引从\",{\"1\":{\"128\":1,\"501\":1}}],[\"让数据分配更加均匀\",{\"1\":{\"493\":1}}],[\"让一个指针先走\",{\"1\":{\"171\":1}}],[\"让\",{\"1\":{\"132\":1,\"169\":1,\"171\":2}}],[\"让他赋值给\",{\"1\":{\"123\":1}}],[\"让这个指针指向其下一个右侧节点\",{\"1\":{\"109\":1,\"118\":1}}],[\"继续走\",{\"1\":{\"581\":2}}],[\"继续比较其节点和其父节点\",{\"1\":{\"574\":1}}],[\"继续更新子数组的最小长度\",{\"1\":{\"230\":1}}],[\"继续往右移\",{\"1\":{\"230\":1,\"231\":1}}],[\"继续访问这一行的下一个节点\",{\"1\":{\"123\":1}}],[\"继续右边遍历\",{\"1\":{\"113\":1}}],[\"去替代\",{\"1\":{\"511\":1}}],[\"去找下一个单词\",{\"1\":{\"153\":1}}],[\"去掉字符串末尾的空白字符\",{\"1\":{\"153\":1}}],[\"去掉字符串开头的空白字符\",{\"1\":{\"153\":1}}],[\"去掉多余空格\",{\"1\":{\"153\":1}}],[\"去除空格\",{\"1\":{\"152\":1}}],[\"去串联\",{\"1\":{\"123\":1}}],[\"去送给\",{\"1\":{\"15\":1}}],[\"模拟类的题目在数组中很常见\",{\"1\":{\"508\":1}}],[\"模拟行为\",{\"0\":{\"508\":1}}],[\"模拟\",{\"1\":{\"377\":1}}],[\"模拟链表串联\",{\"0\":{\"122\":1}}],[\"模式为所有支持克隆的对象\",{\"1\":{\"32\":1}}],[\"左子节点依次入栈\",{\"1\":{\"532\":1,\"536\":1}}],[\"左子节点入队\",{\"1\":{\"525\":1}}],[\"左子节点引用\",{\"1\":{\"517\":1}}],[\"左子树\",{\"1\":{\"529\":1,\"530\":1,\"531\":1}}],[\"左子树和右子树都要满足以上两点\",{\"1\":{\"522\":1}}],[\"左子树和右子树都是二叉搜索树\",{\"1\":{\"339\":1}}],[\"左子树已经发生变化\",{\"1\":{\"246\":1}}],[\"左子树的所有节点的值\",{\"1\":{\"522\":1}}],[\"左子树的节点都比根节点小\",{\"1\":{\"395\":1}}],[\"左子树的深度\",{\"1\":{\"79\":1}}],[\"左子树的最大深度\",{\"1\":{\"79\":1,\"80\":1,\"81\":1}}],[\"左元素还是右元素最终有一个没做判断\",{\"1\":{\"503\":1}}],[\"左半部分的起始索引\",{\"1\":{\"453\":1}}],[\"左中右\",{\"1\":{\"434\":1}}],[\"左中右的遍历顺序是一个单调递增数组\",{\"1\":{\"361\":1}}],[\"左闭右必区间\",{\"0\":{\"407\":1}}],[\"左闭右开\",{\"1\":{\"403\":1,\"504\":1}}],[\"左右区间的比较\",{\"1\":{\"404\":1}}],[\"左右区间的闭合\",{\"1\":{\"404\":1}}],[\"左右子节点交换\",{\"1\":{\"244\":1}}],[\"左右子节点如果不为空就入队\",{\"1\":{\"121\":1}}],[\"左\",{\"1\":{\"261\":1,\"263\":1,\"361\":1,\"362\":1,\"533\":1,\"535\":3}}],[\"左括号必须以正确的顺序闭合\",{\"1\":{\"187\":1}}],[\"左括号必须用相同类型的右括号闭合\",{\"1\":{\"187\":1}}],[\"左边\",{\"1\":{\"139\":1}}],[\"没有交点\",{\"1\":{\"579\":1}}],[\"没有键值相等的节点\",{\"1\":{\"522\":1}}],[\"没有链接到其他子节点的节点\",{\"1\":{\"517\":1}}],[\"没有的字母\",{\"1\":{\"313\":1}}],[\"没有额外的空间\",{\"1\":{\"123\":1}}],[\"没有前一个节点指向他\",{\"1\":{\"120\":1}}],[\"没有新建实例\",{\"1\":{\"31\":1}}],[\"层次遍历则可以使用\",{\"1\":{\"523\":1}}],[\"层\",{\"1\":{\"223\":1,\"323\":2}}],[\"层序遍历题目\",{\"1\":{\"544\":1}}],[\"层序遍历要求我们区分每一层\",{\"1\":{\"526\":1}}],[\"层序遍历要求的输入结果和\",{\"1\":{\"526\":1}}],[\"层序遍历\",{\"0\":{\"178\":1,\"181\":1,\"247\":1,\"524\":1,\"526\":1,\"527\":1},\"1\":{\"118\":1,\"177\":1,\"180\":1,\"245\":1,\"248\":1,\"320\":1,\"524\":1,\"525\":1}}],[\"层节点的\",{\"1\":{\"111\":1}}],[\"层节点之间建立\",{\"1\":{\"111\":1}}],[\"表示函数返回\",{\"1\":{\"531\":1}}],[\"表示开启新方法\",{\"1\":{\"531\":1}}],[\"表示\",{\"0\":{\"538\":1},\"1\":{\"504\":1}}],[\"表示树的高度\",{\"1\":{\"351\":1}}],[\"表示访下一层节点的前一个节点\",{\"1\":{\"123\":1}}],[\"表示每层的末尾\",{\"1\":{\"118\":1}}],[\"表现出来的是一种固执\",{\"1\":{\"2\":1}}],[\"由小写英文字母组成\",{\"1\":{\"311\":1}}],[\"由\",{\"1\":{\"118\":1}}],[\"由于这两个链表不相交\",{\"1\":{\"579\":1}}],[\"由于我们更新\",{\"1\":{\"505\":1}}],[\"由于不需要传初始容量\",{\"1\":{\"481\":1}}],[\"由于需要根据索引来查找节点\",{\"1\":{\"414\":1}}],[\"由于要进行删除操作\",{\"1\":{\"170\":1}}],[\"由于\",{\"1\":{\"130\":1,\"406\":1}}],[\"由于两字母相邻且相同\",{\"1\":{\"88\":1}}],[\"由于每次都是\",{\"1\":{\"15\":1}}],[\"序列化输出按层序遍历顺序\",{\"1\":{\"118\":1}}],[\"序列化的输出按层序遍历排列\",{\"1\":{\"109\":1}}],[\"再进行收集\",{\"1\":{\"458\":1}}],[\"再按高位排序\",{\"1\":{\"458\":1}}],[\"再递归的执行两个树的左节点\",{\"1\":{\"385\":1}}],[\"再赋给树\",{\"1\":{\"385\":1}}],[\"再将\",{\"1\":{\"239\":1}}],[\"再翻转每个单词\",{\"1\":{\"152\":1}}],[\"再到环形入口节点节点数为\",{\"1\":{\"130\":1}}],[\"再建立第\",{\"1\":{\"111\":1}}],[\"再次显示图片\",{\"1\":{\"17\":1}}],[\"即树退化为链表时\",{\"1\":{\"531\":1}}],[\"即满二叉树时\",{\"1\":{\"526\":1}}],[\"即不断向左收缩\",{\"1\":{\"504\":1}}],[\"即与\",{\"1\":{\"482\":1}}],[\"即二叉树的高度\",{\"1\":{\"436\":1}}],[\"即每个节点要存储本身的值\",{\"1\":{\"417\":1}}],[\"即递归的栈空间的空间代价\",{\"1\":{\"342\":1}}],[\"即遍历这棵树的复杂度\",{\"1\":{\"342\":1}}],[\"即默认当前这个是众数\",{\"1\":{\"340\":1}}],[\"即从左到右\",{\"1\":{\"320\":1}}],[\"即为新的数组长度\",{\"1\":{\"285\":1}}],[\"即为最近公共祖先\",{\"1\":{\"261\":1}}],[\"即\",{\"1\":{\"266\":1,\"268\":1,\"339\":1,\"434\":2,\"485\":1,\"503\":1,\"504\":1,\"581\":2,\"583\":1}}],[\"即分别在左\",{\"1\":{\"261\":1}}],[\"即使其中一个操作可能花费较长时间\",{\"1\":{\"253\":1}}],[\"即看成一个链表\",{\"1\":{\"199\":1}}],[\"即第\",{\"1\":{\"111\":1}}],[\"即原型\",{\"1\":{\"32\":1}}],[\"找满足条件的最右侧的值\",{\"0\":{\"505\":1}}],[\"找满足条件的最左侧的值\",{\"0\":{\"504\":1}}],[\"找出待排序数组中最大和最小的元素\",{\"1\":{\"456\":1}}],[\"找出第\",{\"1\":{\"445\":1}}],[\"找出并返回\",{\"1\":{\"339\":1}}],[\"找出该数组中满足其总和大于等于target的长度最小的\",{\"1\":{\"228\":1}}],[\"找出其最小深度\",{\"1\":{\"100\":1}}],[\"找到分区的索引\",{\"1\":{\"454\":1}}],[\"找到中间索引\",{\"1\":{\"453\":1}}],[\"找到合适的位置插入\",{\"1\":{\"451\":1}}],[\"找到相应位置并插入\",{\"1\":{\"450\":1}}],[\"找到从\",{\"1\":{\"449\":1}}],[\"找到map是否存在\",{\"1\":{\"333\":1}}],[\"找到该树中两个指定节点的最近公共祖先\",{\"1\":{\"261\":1}}],[\"找到更小的窗口长度\",{\"1\":{\"230\":1,\"231\":1}}],[\"找到重复答案\",{\"1\":{\"141\":1}}],[\"找到邻居\",{\"1\":{\"111\":1}}],[\"本质上就是赋值给\",{\"1\":{\"483\":1}}],[\"本质上是不变的\",{\"1\":{\"322\":1}}],[\"本层集合中元素\",{\"1\":{\"471\":1}}],[\"本题与\",{\"1\":{\"160\":1,\"358\":1}}],[\"本题中递归程序的隐式栈空间不计入额外空间复杂度\",{\"1\":{\"118\":1}}],[\"本题中递归程序占用的栈空间不算做额外的空间复杂度\",{\"1\":{\"109\":1}}],[\"本人经历过两次考研\",{\"1\":{\"3\":1}}],[\"标志着每一层的结束\",{\"1\":{\"109\":1}}],[\"如调整队列参数\",{\"1\":{\"574\":1}}],[\"如定期发送报告\",{\"1\":{\"574\":1}}],[\"如何理解以及模板\",{\"0\":{\"471\":1}}],[\"如何找到这个环的入口\",{\"1\":{\"131\":1}}],[\"如图\",{\"1\":{\"109\":1,\"118\":1}}],[\"如果队列某些操作\",{\"1\":{\"574\":1}}],[\"如果队列为空\",{\"1\":{\"253\":1}}],[\"如果订单在\",{\"1\":{\"574\":1}}],[\"如果之前的头节点为null\",{\"1\":{\"564\":1}}],[\"如果递归没有终止\",{\"1\":{\"542\":1}}],[\"如果遇到的节点为灰色\",{\"1\":{\"532\":1,\"536\":1}}],[\"如果遇到的节点为白色\",{\"1\":{\"532\":1,\"536\":1}}],[\"如果把边的数量换成节点数量\",{\"1\":{\"517\":1}}],[\"如果非要用\",{\"1\":{\"503\":1}}],[\"如果选择偶数会导致乘积运算时数据溢出\",{\"1\":{\"491\":1}}],[\"如果修改了\",{\"1\":{\"486\":1}}],[\"如果修改了数组内容\",{\"1\":{\"486\":1}}],[\"如果容量不足则需要扩容\",{\"1\":{\"484\":1}}],[\"如果集合的类型是\",{\"1\":{\"482\":1}}],[\"如果传进来的集合为空\",{\"1\":{\"482\":1}}],[\"如果元素\",{\"1\":{\"448\":1}}],[\"如果在这一轮排序中没有交换过\",{\"1\":{\"446\":1}}],[\"如果提前发现左子树不符合二叉搜索树的定义\",{\"1\":{\"434\":1}}],[\"如果遍历结束没有找到\",{\"1\":{\"418\":1}}],[\"如果下标有效\",{\"1\":{\"412\":1}}],[\"如果下标无效\",{\"1\":{\"412\":1}}],[\"如果超过了这个条件\",{\"1\":{\"403\":1}}],[\"如果目标值存在返回下标\",{\"1\":{\"401\":1}}],[\"如果搜索到叶子节点还没找到\",{\"1\":{\"394\":1}}],[\"如果节点不存在\",{\"1\":{\"393\":1}}],[\"如果节点值不同\",{\"1\":{\"68\":1}}],[\"如果一棵树为空\",{\"1\":{\"385\":1}}],[\"如果剩余字符小于\",{\"1\":{\"367\":1}}],[\"如果剩余字符少于\",{\"1\":{\"367\":1}}],[\"如果当前数组已使用长度+1\",{\"1\":{\"486\":1}}],[\"如果当前元素小于或等于pivot\",{\"1\":{\"454\":1}}],[\"如果当前节点的\",{\"1\":{\"434\":1}}],[\"如果当前节点比\",{\"1\":{\"394\":2}}],[\"如果当前节点是新的一层\",{\"1\":{\"349\":1}}],[\"如果当前层的左子节点不为空\",{\"1\":{\"123\":1}}],[\"如果不满足条件\",{\"1\":{\"450\":1}}],[\"如果不是众数\",{\"1\":{\"340\":1}}],[\"如果不存在符合条件的子数组\",{\"1\":{\"228\":1}}],[\"如果不存在环\",{\"1\":{\"130\":1}}],[\"如果是第一次比较的情况\",{\"1\":{\"434\":1}}],[\"如果是双向链表\",{\"1\":{\"412\":1}}],[\"如果是众数\",{\"1\":{\"340\":1}}],[\"如果是快乐数\",{\"1\":{\"200\":1}}],[\"如果树\",{\"1\":{\"387\":2}}],[\"如果树为空\",{\"1\":{\"359\":1,\"394\":1,\"434\":1}}],[\"如果树中有不止一个众数\",{\"1\":{\"339\":1}}],[\"如果树是空\",{\"1\":{\"104\":1}}],[\"如果某个字符数量检查情况中\",{\"1\":{\"313\":1}}],[\"如果两个链表相交则不能为\",{\"1\":{\"579\":2}}],[\"如果两个链表没有交点\",{\"1\":{\"579\":1}}],[\"如果两个节点重叠\",{\"1\":{\"384\":1}}],[\"如果两个字符串的长度不相等\",{\"1\":{\"313\":1}}],[\"如果两个单词间有多余的空格\",{\"1\":{\"146\":1}}],[\"如果可以\",{\"1\":{\"311\":1}}],[\"如果可以还想创新\",{\"1\":{\"3\":1}}],[\"如果相同的时候\",{\"1\":{\"285\":1}}],[\"如果相遇\",{\"1\":{\"200\":1}}],[\"如果所有的断言都通过\",{\"1\":{\"283\":1}}],[\"如果输入字符串包含\",{\"1\":{\"274\":1}}],[\"如果栈是空的\",{\"1\":{\"236\":1}}],[\"如果栈为空或者栈顶元素与\",{\"1\":{\"189\":1}}],[\"如果你已经实现o\",{\"1\":{\"228\":1}}],[\"如果你文档需要\",{\"1\":{\"0\":1}}],[\"如果他们的起点是相隔\",{\"1\":{\"200\":1}}],[\"如果没有找到的情况下\",{\"1\":{\"503\":1}}],[\"如果没有循环\",{\"1\":{\"200\":1}}],[\"如果没有则加载\",{\"1\":{\"17\":1}}],[\"如果这个过程\",{\"1\":{\"196\":1}}],[\"如果与栈顶元素一样\",{\"1\":{\"189\":1}}],[\"如果字符串在你使用的编程语言中是一种可变数据类型\",{\"1\":{\"146\":1}}],[\"如果和\",{\"1\":{\"139\":3}}],[\"如果使用\",{\"1\":{\"139\":1}}],[\"如果存在环\",{\"1\":{\"130\":1}}],[\"如果链表中有某个节点\",{\"1\":{\"128\":1}}],[\"如果链表无环\",{\"1\":{\"128\":1}}],[\"如果\",{\"1\":{\"120\":1,\"121\":1,\"128\":1,\"139\":2,\"196\":1,\"198\":2,\"261\":1,\"313\":1,\"359\":1,\"388\":3,\"403\":1,\"412\":2,\"445\":1,\"480\":1,\"504\":2,\"579\":2}}],[\"如果上一层已经完成串联\",{\"1\":{\"113\":1}}],[\"如果找不到下一个右侧节点\",{\"1\":{\"109\":1,\"118\":1}}],[\"如果左子树为空\",{\"1\":{\"104\":1}}],[\"如果只有根节点\",{\"1\":{\"104\":1}}],[\"如果只有两个重复元素\",{\"1\":{\"60\":1}}],[\"如果数组尾元素\",{\"1\":{\"93\":1}}],[\"如果以节点来说明\",{\"1\":{\"69\":1}}],[\"如果都为空\",{\"1\":{\"68\":1}}],[\"如果其中一个为空\",{\"1\":{\"68\":1}}],[\"如果有环\",{\"1\":{\"131\":1}}],[\"如果有\",{\"1\":{\"60\":1}}],[\"初始容量为\",{\"1\":{\"486\":1}}],[\"初始增量\",{\"1\":{\"452\":1}}],[\"初始化一个列表\",{\"1\":{\"525\":1}}],[\"初始化队列\",{\"1\":{\"525\":1}}],[\"初始化条件\",{\"1\":{\"503\":1,\"504\":1}}],[\"初始化容量\",{\"0\":{\"494\":1},\"1\":{\"492\":1}}],[\"初始化消耗\",{\"1\":{\"416\":1,\"419\":1}}],[\"初始化\",{\"1\":{\"412\":1}}],[\"初始化为\",{\"1\":{\"268\":1}}],[\"初始化项目并上传到github\",{\"1\":{\"0\":1}}],[\"初始状态下\",{\"1\":{\"109\":1,\"118\":1}}],[\"指的都是一个函数\",{\"1\":{\"469\":1}}],[\"指针域的指针\",{\"1\":{\"562\":1}}],[\"指针域\",{\"1\":{\"557\":1}}],[\"指针使用常数大小的额外空间\",{\"1\":{\"141\":1}}],[\"指针相遇节点节点数为\",{\"1\":{\"130\":1}}],[\"指针与\",{\"1\":{\"130\":1}}],[\"指针再次到达\",{\"1\":{\"128\":1}}],[\"指针后\",{\"1\":{\"111\":1}}],[\"指针只有两种类型\",{\"1\":{\"111\":1}}],[\"指针连接\",{\"1\":{\"109\":1,\"118\":1}}],[\"指针都被设置为\",{\"1\":{\"109\":1,\"118\":1}}],[\"指针设置为\",{\"1\":{\"109\":1,\"118\":1}}],[\"指针\",{\"1\":{\"109\":2,\"111\":1,\"113\":1,\"118\":2,\"581\":2}}],[\"指向下一节点的引用\",{\"1\":{\"562\":1}}],[\"指向下一个\",{\"1\":{\"369\":1}}],[\"指向下个单词的尾字符\",{\"1\":{\"151\":1}}],[\"指向的元素\",{\"1\":{\"294\":1}}],[\"指向\",{\"1\":{\"261\":2}}],[\"指向头节点\",{\"1\":{\"218\":1}}],[\"指向虚拟节点\",{\"1\":{\"218\":1}}],[\"指向单词的范围\",{\"1\":{\"150\":1}}],[\"指向最左的元素\",{\"1\":{\"139\":1}}],[\"指向最后的数组末尾指针\",{\"1\":{\"95\":1}}],[\"指向上一个元素\",{\"1\":{\"93\":1}}],[\"填充的行肯定在\",{\"1\":{\"380\":2}}],[\"填充的列肯定在\",{\"1\":{\"380\":2}}],[\"填充到8时\",{\"1\":{\"378\":1}}],[\"填充它的每个\",{\"1\":{\"109\":1,\"118\":1}}],[\"填充每个节点的下一个右侧节点指针ii\",{\"1\":{\"544\":1}}],[\"填充每个节点的下一个右侧节点指针\",{\"0\":{\"107\":1,\"108\":1,\"116\":1,\"117\":1},\"1\":{\"544\":1}}],[\"完全二叉树中\",{\"1\":{\"540\":1}}],[\"完全二叉树\",{\"0\":{\"520\":1}}],[\"完成处理\",{\"1\":{\"111\":1}}],[\"完美二叉树\",{\"0\":{\"539\":1},\"1\":{\"109\":1}}],[\"完善\",{\"1\":{\"0\":2}}],[\"深度\",{\"1\":{\"517\":1}}],[\"深度优先搜索\",{\"1\":{\"321\":1}}],[\"深度遍历\",{\"1\":{\"177\":1}}],[\"深度为1\",{\"1\":{\"102\":1}}],[\"深度概念\",{\"1\":{\"78\":1}}],[\"550317560\",{\"1\":{\"392\":1}}],[\"59\",{\"0\":{\"374\":1,\"375\":1}}],[\"541\",{\"0\":{\"365\":1,\"366\":1}}],[\"530\",{\"0\":{\"356\":1,\"357\":1}}],[\"515\",{\"0\":{\"345\":1,\"346\":1},\"1\":{\"544\":1}}],[\"501\",{\"0\":{\"337\":1,\"338\":1}}],[\"5000\",{\"1\":{\"216\":3,\"393\":1}}],[\"50\",{\"1\":{\"205\":2,\"283\":1}}],[\"5\",{\"1\":{\"100\":2,\"109\":2,\"118\":2,\"128\":2,\"137\":2,\"167\":2,\"176\":1,\"205\":2,\"216\":2,\"261\":9,\"274\":1,\"283\":2,\"292\":1,\"301\":1,\"311\":1,\"320\":4,\"339\":2,\"347\":1,\"376\":1,\"384\":3,\"393\":1,\"401\":2,\"433\":2,\"485\":3,\"486\":1,\"504\":1,\"529\":1,\"530\":1,\"531\":1,\"543\":1,\"579\":9}}],[\"修改输入数组\",{\"1\":{\"292\":1}}],[\"修改节点指向\",{\"1\":{\"218\":1}}],[\"修改\",{\"1\":{\"93\":1}}],[\"把第一个没有排序过的元素设置为最小值\",{\"1\":{\"448\":1}}],[\"把他们相加\",{\"1\":{\"387\":1}}],[\"把当前元素添加进去\",{\"1\":{\"232\":1}}],[\"把下一层串联成一个链表之后\",{\"1\":{\"123\":1}}],[\"把每一层当成一个链表进行遍历\",{\"1\":{\"112\":1}}],[\"把数组当成一个队列使用\",{\"1\":{\"93\":1}}],[\"把这门技术的祖宗十八代都挖出来\",{\"1\":{\"3\":1}}],[\"此时需遍历\",{\"1\":{\"583\":1}}],[\"此时根据代码\",{\"1\":{\"485\":1}}],[\"此时有\",{\"1\":{\"484\":1}}],[\"此时整个数组成为一个子序列\",{\"1\":{\"452\":1}}],[\"此时不需要翻转\",{\"1\":{\"371\":1}}],[\"此时应该是最后一次\",{\"1\":{\"371\":1}}],[\"此时树的高度与节点个数一样\",{\"1\":{\"326\":1}}],[\"此时高度为\",{\"1\":{\"263\":1}}],[\"此时的\",{\"1\":{\"261\":1}}],[\"此时\",{\"1\":{\"232\":1,\"261\":1,\"351\":1,\"378\":1,\"503\":1}}],[\"此时剩余两个元素都\",{\"1\":{\"141\":1}}],[\"此时将队列尾部元素删除\",{\"1\":{\"90\":1}}],[\"此时代理对象会检查realimage是否已经加载\",{\"1\":{\"17\":1}}],[\"存放结果\",{\"1\":{\"471\":1}}],[\"存放在序列的起始位置\",{\"1\":{\"448\":1}}],[\"存入数组c的第i项\",{\"1\":{\"456\":1}}],[\"存储\",{\"1\":{\"478\":1}}],[\"存储相同的数据类型数据\",{\"1\":{\"475\":1}}],[\"存储众数元素\",{\"1\":{\"340\":1}}],[\"存储头节点\",{\"1\":{\"169\":1}}],[\"存储虚拟头节点\",{\"1\":{\"169\":2}}],[\"存储遍历的情况\",{\"1\":{\"90\":1}}],[\"存在\",{\"1\":{\"60\":1,\"313\":1,\"503\":1}}],[\"数据同步\",{\"1\":{\"574\":1}}],[\"数据域\",{\"1\":{\"557\":1}}],[\"数据结构使用过程叙述\",{\"1\":{\"513\":1}}],[\"数据类型的大小\",{\"1\":{\"475\":1}}],[\"数字和空格\",{\"1\":{\"146\":1}}],[\"数字或者队列\",{\"1\":{\"90\":1}}],[\"数组的特点\",{\"0\":{\"501\":1}}],[\"数组是存放在\",{\"1\":{\"500\":1}}],[\"数组总结篇\",{\"0\":{\"499\":1}}],[\"数组会受影响嘛\",{\"1\":{\"486\":1}}],[\"数组被包装成\",{\"1\":{\"486\":1}}],[\"数组转换为\",{\"1\":{\"486\":1}}],[\"数组容量缓冲区的容量扩容为\",{\"1\":{\"484\":1}}],[\"数组列表的大小\",{\"1\":{\"478\":1}}],[\"数组首地址\",{\"1\":{\"475\":1}}],[\"数组元素则是对应的value\",{\"1\":{\"462\":1}}],[\"数组变为\",{\"1\":{\"424\":2}}],[\"数组可以通过索引的方式进行重新设置值\",{\"1\":{\"350\":1}}],[\"数组中小于\",{\"1\":{\"504\":2}}],[\"数组中每个元素之和都不相同\",{\"1\":{\"334\":1}}],[\"数组中同一个元素在答案里不能重复出现\",{\"1\":{\"58\":1}}],[\"数组长度都是\",{\"1\":{\"331\":1}}],[\"数组长度为常数\",{\"1\":{\"278\":1}}],[\"数组为空时\",{\"1\":{\"95\":1}}],[\"数组\",{\"0\":{\"93\":1,\"475\":1},\"1\":{\"89\":1,\"283\":1,\"284\":1,\"377\":1,\"402\":1,\"461\":1},\"2\":{\"143\":1,\"164\":1,\"289\":1,\"308\":1,\"336\":1,\"409\":1,\"430\":1}}],[\"遍历到最底层之前\",{\"1\":{\"526\":1}}],[\"遍历改造成了层序遍历\",{\"1\":{\"526\":1}}],[\"遍历数据\",{\"1\":{\"457\":1}}],[\"遍历数组\",{\"1\":{\"285\":1}}],[\"遍历后续的元素\",{\"1\":{\"448\":1}}],[\"遍历时\",{\"1\":{\"418\":1}}],[\"遍历找到最后一个节点\",{\"1\":{\"416\":1}}],[\"遍历的节点个数\",{\"1\":{\"396\":1}}],[\"遍历的长度为字符串长度n\",{\"1\":{\"371\":1}}],[\"遍历右子树\",{\"1\":{\"340\":1}}],[\"遍历第一个节点时\",{\"1\":{\"340\":1}}],[\"遍历左子树\",{\"1\":{\"340\":1}}],[\"遍历\",{\"0\":{\"523\":1},\"1\":{\"333\":1}}],[\"遍历完\",{\"1\":{\"123\":1}}],[\"遍历这一层节点组织成的链表\",{\"1\":{\"113\":1}}],[\"遍历字符串所需要的时间复杂度\",{\"1\":{\"315\":1}}],[\"遍历字符串\",{\"1\":{\"90\":1}}],[\"遍历原对象的属性\",{\"1\":{\"31\":1}}],[\"都可以使用\",{\"1\":{\"523\":1}}],[\"都会改变\",{\"1\":{\"504\":1}}],[\"都会将该层所有节点入队\",{\"1\":{\"352\":1}}],[\"都是先将数据一份为二然后再逐个处理\",{\"1\":{\"454\":1}}],[\"都是\",{\"1\":{\"292\":1}}],[\"都不在\",{\"1\":{\"261\":1}}],[\"都不为空\",{\"1\":{\"261\":1}}],[\"都不是\",{\"1\":{\"261\":1}}],[\"都不会影响最终的结果\",{\"1\":{\"90\":1}}],[\"都保证栈不为空\",{\"1\":{\"236\":1}}],[\"都失败了\",{\"1\":{\"3\":1}}],[\"双向链表还是循环链表\",{\"1\":{\"569\":1}}],[\"双链表\",{\"0\":{\"560\":1}}],[\"双链表实现\",{\"0\":{\"417\":1}}],[\"双重循环的时间复杂度为\",{\"1\":{\"141\":1}}],[\"双重检查锁\",{\"1\":{\"26\":1}}],[\"双指针遍历各自所在链表后\",{\"1\":{\"582\":1}}],[\"双指针法来移除链表倒数第\",{\"1\":{\"550\":1}}],[\"双指针法\",{\"0\":{\"506\":1},\"1\":{\"506\":1}}],[\"双指针指向相等时\",{\"1\":{\"427\":1}}],[\"双指针移动的更新\",{\"1\":{\"370\":1}}],[\"双指针为什么要交替移动\",{\"1\":{\"141\":1}}],[\"双指针使用常数大小的额外空间\",{\"1\":{\"132\":1}}],[\"双指针\",{\"0\":{\"169\":1,\"218\":1},\"1\":{\"95\":1,\"138\":1,\"139\":3,\"140\":1,\"147\":1,\"168\":1,\"217\":1,\"293\":1,\"368\":1,\"425\":1,\"580\":1},\"2\":{\"143\":1,\"164\":1,\"373\":1}}],[\"双端队列的直接实现类是\",{\"1\":{\"574\":1}}],[\"双端队列\",{\"0\":{\"90\":1},\"1\":{\"236\":1,\"253\":1,\"574\":1}}],[\"栈帧空间\",{\"1\":{\"531\":1}}],[\"栈是一种\",{\"1\":{\"511\":1}}],[\"栈是后进先出\",{\"1\":{\"238\":1}}],[\"栈理论基础篇\",{\"0\":{\"510\":1}}],[\"栈\",{\"1\":{\"89\":1,\"188\":1,\"237\":1,\"523\":2},\"2\":{\"193\":1,\"241\":1,\"258\":1,\"515\":1}}],[\"其子节点的优先级\",{\"1\":{\"574\":1}}],[\"其核心思想如下\",{\"1\":{\"536\":1}}],[\"其余节点度为\",{\"1\":{\"519\":1}}],[\"其余字符保持原样\",{\"1\":{\"367\":1}}],[\"其实这也是写程序中的重要原则\",{\"1\":{\"508\":1}}],[\"其实相当于告诉我们\",{\"1\":{\"504\":1}}],[\"其实是相当于调用\",{\"1\":{\"484\":1}}],[\"其实外面都充满着答案\",{\"1\":{\"3\":1}}],[\"其数值等于两值之差的绝对值\",{\"1\":{\"358\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"292\":1}}],[\"其元素排列顺序和出栈顺序相同\",{\"1\":{\"239\":1}}],[\"其尾部连接到第一个节点\",{\"1\":{\"128\":1}}],[\"其尾部连接到第二个节点\",{\"1\":{\"128\":1}}],[\"其所有叶子节点都在同一层\",{\"1\":{\"109\":1}}],[\"其中哈希表操作都是\",{\"1\":{\"334\":1}}],[\"其中一个在\",{\"1\":{\"261\":1}}],[\"其中\",{\"1\":{\"104\":1,\"130\":1,\"139\":1,\"153\":1,\"182\":1,\"239\":1,\"333\":1,\"351\":2,\"353\":1,\"416\":1,\"419\":1,\"458\":1,\"517\":1,\"526\":1}}],[\"其中又只有\",{\"1\":{\"88\":1}}],[\"之后足够存放下一个数据\",{\"1\":{\"486\":1}}],[\"之后我们得到字符串\",{\"1\":{\"88\":1}}],[\"之间的头节点的前驱节点是新节点\",{\"1\":{\"564\":1}}],[\"之间的映射\",{\"1\":{\"461\":1}}],[\"之间\",{\"1\":{\"320\":1,\"401\":2}}],[\"之间用单个空格连接的结果字符串\",{\"1\":{\"146\":1}}],[\"之所以这么说\",{\"1\":{\"3\":1}}],[\"中继续搜索\",{\"1\":{\"504\":1}}],[\"中最小的元素的索引\",{\"1\":{\"449\":1}}],[\"中最近公共祖先的定义为\",{\"1\":{\"261\":1}}],[\"中节点数目为\",{\"1\":{\"579\":2}}],[\"中节点访问过\",{\"1\":{\"537\":3}}],[\"中节点\",{\"1\":{\"434\":1}}],[\"中因此返回\",{\"1\":{\"401\":1}}],[\"中并且下标为\",{\"1\":{\"401\":1}}],[\"中找到节点值等于\",{\"1\":{\"393\":1}}],[\"中心数字无法在迭代过程中被填充\",{\"1\":{\"378\":1}}],[\"中序遍历+双指针\",{\"0\":{\"434\":1}}],[\"中序遍历的结果是一个单调递增的数组\",{\"1\":{\"394\":1}}],[\"中序遍历\",{\"0\":{\"359\":1,\"394\":1,\"530\":1,\"534\":1},\"1\":{\"436\":1,\"530\":1,\"537\":1,\"543\":1}}],[\"中序遍历序列是\",{\"1\":{\"340\":1}}],[\"中使用一次\",{\"1\":{\"311\":1}}],[\"中使用至少一个空格将字符串中的\",{\"1\":{\"146\":1}}],[\"中不等于\",{\"1\":{\"283\":1}}],[\"中与\",{\"1\":{\"283\":1}}],[\"中每个字符出现的次数都相同\",{\"1\":{\"274\":1}}],[\"中处理\",{\"1\":{\"263\":1}}],[\"中进行\",{\"1\":{\"255\":1}}],[\"中的\",{\"1\":{\"401\":1}}],[\"中的任何元素的重复次数还要大\",{\"1\":{\"340\":1}}],[\"中的所有元素是不重复的\",{\"1\":{\"401\":1}}],[\"中的所有\",{\"1\":{\"339\":1}}],[\"中的每个字符只能在\",{\"1\":{\"311\":1}}],[\"中的前五个元素为\",{\"1\":{\"283\":1}}],[\"中的前两个元素均为\",{\"1\":{\"283\":1}}],[\"中的元素依次出栈压入\",{\"1\":{\"239\":2}}],[\"中的元素总长度\",{\"1\":{\"149\":1}}],[\"中的字符串总长度\",{\"1\":{\"151\":1}}],[\"中可能会存在前导空格\",{\"1\":{\"146\":1}}],[\"中\",{\"0\":{\"528\":1},\"1\":{\"88\":1,\"146\":1,\"261\":2,\"340\":1,\"361\":1,\"362\":1,\"388\":1,\"482\":1,\"483\":1,\"511\":1,\"528\":1,\"535\":3,\"541\":1,\"569\":1,\"573\":2,\"579\":4}}],[\"中有这样一个故事\",{\"1\":{\"15\":1}}],[\"例如寻找距离尾部第\",{\"1\":{\"553\":1}}],[\"例如\",{\"1\":{\"88\":1,\"253\":1}}],[\"会实现一个\",{\"1\":{\"574\":1}}],[\"会发现\",{\"1\":{\"485\":1}}],[\"会发现连续的数字是一小段一小段的出现\",{\"1\":{\"340\":1}}],[\"会发生第二次\",{\"1\":{\"485\":1}}],[\"会调用\",{\"1\":{\"485\":1}}],[\"会将所有的key能映射到数组上对应的索引\",{\"1\":{\"462\":1}}],[\"会获取对应该层的答案\",{\"1\":{\"325\":1}}],[\"会相遇\",{\"1\":{\"200\":1}}],[\"会先到\",{\"1\":{\"198\":1}}],[\"会先于\",{\"1\":{\"130\":1}}],[\"会选择两个相邻且相同的字母\",{\"1\":{\"88\":1}}],[\"会让人学的更加透彻\",{\"1\":{\"2\":1}}],[\"重叠的链长度为\",{\"1\":{\"583\":1}}],[\"重新取出栈中元素\",{\"1\":{\"537\":3}}],[\"重新记录\",{\"1\":{\"342\":1}}],[\"重复\",{\"1\":{\"533\":1}}],[\"重复上一个过程\",{\"1\":{\"445\":1}}],[\"重复的情况\",{\"1\":{\"342\":1}}],[\"重复答案\",{\"1\":{\"141\":1}}],[\"重复项删除操作\",{\"1\":{\"88\":1}}],[\"重写工厂方法\",{\"1\":{\"36\":1}}],[\"重写clone方法\",{\"1\":{\"33\":1}}],[\"队列里面的元素实现了\",{\"1\":{\"574\":1}}],[\"队列既可以是数组实现也可以是链表实现\",{\"1\":{\"573\":1}}],[\"队列理论基础篇\",{\"0\":{\"572\":1}}],[\"队列出队\",{\"1\":{\"525\":1}}],[\"队列遵循\",{\"1\":{\"524\":1}}],[\"队列所需要的空间最多不超过\",{\"1\":{\"353\":1}}],[\"队列所需要用到的空间是\",{\"1\":{\"324\":1}}],[\"队列中最多同时存在\",{\"1\":{\"526\":1}}],[\"队列中最多不会超过\",{\"1\":{\"72\":1}}],[\"队列中会有\",{\"1\":{\"256\":1}}],[\"队列应当支持一般队列支持的所有操作\",{\"1\":{\"253\":1}}],[\"队列最多同时存储\",{\"1\":{\"248\":1}}],[\"队列是先进先出\",{\"1\":{\"238\":1}}],[\"队列存放节点所需要的空间不超过\",{\"1\":{\"121\":1}}],[\"队列\",{\"1\":{\"82\":1,\"83\":1,\"237\":1,\"254\":1,\"524\":1,\"573\":1},\"2\":{\"576\":1}}],[\"树能始终保持高效的数据操作性能\",{\"1\":{\"541\":1}}],[\"树是\",{\"1\":{\"541\":1}}],[\"树结构的开端\",{\"1\":{\"517\":1}}],[\"树结构的基本单位是节点\",{\"1\":{\"517\":1}}],[\"树专题\",{\"0\":{\"516\":1}}],[\"树形结构\",{\"1\":{\"471\":1}}],[\"树形\",{\"1\":{\"469\":1}}],[\"树退化成一个链表\",{\"1\":{\"351\":1}}],[\"树退化成链表\",{\"1\":{\"326\":1}}],[\"树只有两层\",{\"1\":{\"324\":1}}],[\"树\",{\"1\":{\"321\":1,\"385\":1},\"2\":{\"328\":1}}],[\"树中任意两不同节点值之间的最小差值\",{\"1\":{\"358\":1}}],[\"树中的节点数在范围\",{\"1\":{\"118\":1}}],[\"树中节点孩子的数量就是集合的大小\",{\"1\":{\"471\":1}}],[\"树中节点的数目范围是\",{\"1\":{\"358\":1}}],[\"树中节点的数目在范围\",{\"1\":{\"339\":1}}],[\"树中节点的数量在\",{\"1\":{\"77\":1,\"109\":1}}],[\"树中节点数在\",{\"1\":{\"393\":1}}],[\"树中节点数目范围在\",{\"1\":{\"244\":1,\"433\":1}}],[\"树中节点数目在范围\",{\"1\":{\"67\":1,\"261\":1}}],[\"树中节点数的范围在\",{\"1\":{\"100\":1}}],[\"树呈现链状\",{\"1\":{\"104\":1}}],[\"树的节点总数在\",{\"1\":{\"320\":1}}],[\"树的高度不会超过\",{\"1\":{\"320\":1}}],[\"树的序列化输入是用层序遍历\",{\"1\":{\"320\":1}}],[\"树的层序遍历\",{\"1\":{\"82\":1}}],[\"树的最大深度\",{\"1\":{\"81\":1}}],[\"求树的大深度\",{\"1\":{\"81\":1}}],[\"因此返回\",{\"1\":{\"579\":1}}],[\"因此所有\",{\"1\":{\"540\":1}}],[\"因此下次\",{\"1\":{\"503\":1}}],[\"因此最终会返回\",{\"1\":{\"484\":1}}],[\"因此提供查询节点的方法\",{\"1\":{\"414\":1}}],[\"因此我们不能跳过这个\",{\"1\":{\"406\":1}}],[\"因此我们更新左边界的时候\",{\"1\":{\"403\":1}}],[\"因此我们需要\",{\"1\":{\"160\":1}}],[\"因此右边界我们是判断不到的\",{\"1\":{\"403\":1}}],[\"因此\",{\"1\":{\"359\":1,\"523\":1}}],[\"因此对于某个节点来说\",{\"1\":{\"325\":1}}],[\"因此在单次\",{\"1\":{\"323\":1}}],[\"因此它们并不计入评测\",{\"1\":{\"283\":2}}],[\"因此空间复杂度为常数\",{\"1\":{\"278\":1}}],[\"因此空间复杂度为\",{\"1\":{\"263\":1}}],[\"因此时间复杂度为\",{\"1\":{\"263\":1,\"436\":1}}],[\"因此要找到\",{\"1\":{\"170\":1}}],[\"因此总时间复杂度为\",{\"1\":{\"162\":1}}],[\"因此需要先排序\",{\"1\":{\"141\":1}}],[\"因此深度是\",{\"1\":{\"79\":1}}],[\"因为第一个元素可以认为是已排序的\",{\"1\":{\"451\":1}}],[\"因为java语言不需要申请长度为n的数组来存储字符\",{\"1\":{\"371\":1}}],[\"因为要取\",{\"1\":{\"370\":1}}],[\"因为根据定义最近公共祖先节点可以为节点本身\",{\"1\":{\"261\":1}}],[\"因为左子节点在翻转后会发生变化\",{\"1\":{\"244\":1}}],[\"因为\",{\"1\":{\"58\":1}}],[\"说法\",{\"1\":{\"517\":1}}],[\"说明数组已经有序\",{\"1\":{\"446\":1}}],[\"说明左子树是不符合二叉搜索树\",{\"1\":{\"434\":1}}],[\"说明找到了目标节点并返回\",{\"1\":{\"418\":1}}],[\"说明要往\",{\"1\":{\"394\":2}}],[\"说明\",{\"1\":{\"93\":1,\"100\":1,\"139\":2,\"253\":1,\"261\":2,\"313\":1}}],[\"说明不是重复项\",{\"1\":{\"90\":1}}],[\"说明不是叶节点\",{\"1\":{\"79\":1}}],[\"说明此时是重复项已经出现\",{\"1\":{\"90\":1}}],[\"说的更简单一点\",{\"1\":{\"4\":1}}],[\"quicksort\",{\"1\":{\"454\":3}}],[\"queue<integer>\",{\"1\":{\"239\":2}}],[\"queue<treenode>\",{\"1\":{\"72\":1,\"525\":1,\"526\":1}}],[\"queues\",{\"1\":{\"235\":1}}],[\"queue\",{\"1\":{\"83\":5,\"92\":7,\"120\":1,\"121\":7,\"180\":7,\"191\":7,\"252\":1,\"253\":4,\"353\":7,\"362\":5,\"388\":10,\"525\":6,\"526\":7,\"573\":2,\"574\":4}}],[\"q2\",{\"1\":{\"239\":7}}],[\"q1\",{\"1\":{\"239\":12}}],[\"q\",{\"1\":{\"72\":10,\"261\":21,\"263\":4}}],[\"相等\",{\"1\":{\"582\":2}}],[\"相交的位置在\",{\"1\":{\"583\":2}}],[\"相交部分长度为\",{\"1\":{\"581\":1}}],[\"相交节点前有\",{\"1\":{\"579\":4}}],[\"相交节点的值为\",{\"1\":{\"579\":2}}],[\"相当于闭区间\",{\"1\":{\"503\":1}}],[\"相当于调用\",{\"1\":{\"484\":1}}],[\"相当于缩小左边界\",{\"1\":{\"380\":1}}],[\"相当于缩小下边界\",{\"1\":{\"380\":1}}],[\"相当于缩小右边界\",{\"1\":{\"380\":1}}],[\"相当于缩小上边界\",{\"1\":{\"380\":1}}],[\"相当于处理这一对节点\",{\"1\":{\"71\":1}}],[\"相同类型数据\",{\"1\":{\"500\":1}}],[\"相同\",{\"1\":{\"358\":1}}],[\"相同的节点\",{\"1\":{\"340\":1}}],[\"相似\",{\"1\":{\"160\":1}}],[\"相遇点到入环点的距离\",{\"1\":{\"130\":1}}],[\"相遇时\",{\"1\":{\"130\":1}}],[\"相处\",{\"1\":{\"15\":1}}],[\"入栈顺序\",{\"1\":{\"535\":1}}],[\"入栈是右括号\",{\"1\":{\"190\":1}}],[\"入队一次\",{\"1\":{\"324\":1,\"326\":1}}],[\"入队\",{\"1\":{\"71\":2}}],[\"入队两次\",{\"1\":{\"71\":1}}],[\"入参是左子节点与右子节点\",{\"1\":{\"68\":1}}],[\"将空节点弹出\",{\"1\":{\"537\":3}}],[\"将该节点弹出\",{\"1\":{\"537\":3}}],[\"将右节点和左节点依次入栈\",{\"1\":{\"533\":1}}],[\"将其右子节点\",{\"1\":{\"532\":1}}],[\"将整数按位拆分成不同的数字\",{\"1\":{\"458\":1}}],[\"将每个桶中排序好的数据拼接在一起\",{\"1\":{\"457\":1}}],[\"将每一行看成一个链表进行处理\",{\"1\":{\"123\":1}}],[\"将每一层想象成一条链表\",{\"1\":{\"119\":1}}],[\"将属于一定范围内的数据\",{\"1\":{\"457\":1}}],[\"将数组尾元素替换根元素\",{\"1\":{\"574\":1}}],[\"将数组分成两半\",{\"1\":{\"453\":1}}],[\"将数据填充到指定的桶中\",{\"1\":{\"457\":1}}],[\"将数据都放到指定的桶中\",{\"1\":{\"457\":1}}],[\"将数据转化为键存储在额外的数组空间里\",{\"1\":{\"456\":1}}],[\"将临时数组中的元素复制回原数组\",{\"1\":{\"453\":1}}],[\"将当前元素与已排序部分的元素比较\",{\"1\":{\"451\":1}}],[\"将第一个元素标记为已排序\",{\"1\":{\"450\":1}}],[\"将找到的最小元素交换到当前位置\",{\"1\":{\"449\":1}}],[\"将最小值和第一个没有排序的元素进行交换\",{\"1\":{\"448\":1}}],[\"将相邻的两个元素\",{\"1\":{\"445\":1}}],[\"将一个值为\",{\"1\":{\"412\":3}}],[\"将在\",{\"1\":{\"401\":1}}],[\"将两个树的节点相加后\",{\"1\":{\"385\":1}}],[\"将访问的节点放进栈\",{\"1\":{\"362\":1}}],[\"将二叉树的层序遍历扩展到\",{\"1\":{\"322\":1}}],[\"将虚拟头结点指向head\",{\"1\":{\"270\":1}}],[\"将元素添加到集合\",{\"1\":{\"511\":1}}],[\"将元素\",{\"1\":{\"236\":1,\"253\":1}}],[\"将\",{\"1\":{\"199\":1,\"221\":1,\"230\":1,\"247\":1,\"333\":1,\"434\":1}}],[\"将栈顶元素出栈\",{\"1\":{\"189\":1}}],[\"将字符串间多余的空白字符去除\",{\"1\":{\"153\":1}}],[\"将单词添加到结果中\",{\"1\":{\"150\":1}}],[\"将队列去掉\",{\"1\":{\"122\":1}}],[\"将这种情况视为\",{\"1\":{\"463\":1}}],[\"将这一层的上一层串联好\",{\"1\":{\"111\":1}}],[\"将这个二叉树看成是两个\",{\"1\":{\"71\":1}}],[\"将递归逻辑写成迭代的形式\",{\"1\":{\"71\":1}}],[\"迭代遍历统一法\",{\"0\":{\"536\":1}}],[\"迭代遍历\",{\"0\":{\"532\":1}}],[\"迭代写法\",{\"0\":{\"362\":1,\"526\":1}}],[\"迭代\",{\"0\":{\"71\":1,\"387\":1}}],[\"个字符\",{\"1\":{\"367\":3}}],[\"个元素有序的\",{\"1\":{\"401\":1}}],[\"个元素不等于\",{\"1\":{\"285\":1}}],[\"个元素之外留下了什么并不重要\",{\"1\":{\"283\":2}}],[\"个元素包含不等于\",{\"1\":{\"283\":1}}],[\"个元素\",{\"1\":{\"256\":1,\"283\":1,\"527\":1}}],[\"个操作的总时间复杂度为\",{\"1\":{\"253\":1}}],[\"个数字\",{\"1\":{\"200\":1}}],[\"个结点\",{\"0\":{\"166\":1},\"1\":{\"167\":1,\"526\":1}}],[\"个整数组成的数组\",{\"1\":{\"158\":1}}],[\"个环\",{\"1\":{\"132\":2}}],[\"个节点前面插入一个节点\",{\"1\":{\"551\":1}}],[\"个节点的数值\",{\"1\":{\"551\":2}}],[\"个节点的存放\",{\"1\":{\"353\":1}}],[\"个节点之后的\",{\"1\":{\"550\":1}}],[\"个节点组成的第二层\",{\"1\":{\"324\":1}}],[\"个节点位置\",{\"1\":{\"170\":1}}],[\"个节点\",{\"0\":{\"550\":1},\"1\":{\"72\":1,\"83\":1,\"121\":1,\"198\":2,\"248\":1,\"526\":1,\"550\":3,\"553\":1,\"579\":4,\"583\":1}}],[\"个\",{\"1\":{\"70\":1,\"169\":1,\"171\":2,\"239\":1,\"278\":1,\"314\":1,\"367\":2,\"504\":2}}],[\"个或者以上的重复元素\",{\"1\":{\"60\":1}}],[\"则自动取消订单并释放锁定的库存\",{\"1\":{\"574\":1}}],[\"则节点数量为\",{\"1\":{\"519\":1}}],[\"则直接进行\",{\"1\":{\"482\":1}}],[\"则直接将树\",{\"1\":{\"387\":2}}],[\"则删除链表中下标为\",{\"1\":{\"412\":1}}],[\"则还需要属性\",{\"1\":{\"412\":1}}],[\"则进行移动即可\",{\"1\":{\"385\":1}}],[\"则进行拷贝覆盖\",{\"1\":{\"285\":1}}],[\"则反转前\",{\"1\":{\"367\":1}}],[\"则不是正确答案\",{\"1\":{\"313\":2}}],[\"则跳过该数字不进行拷贝覆盖\",{\"1\":{\"285\":1}}],[\"则最终哈希表中所有字符统计数值都应为\",{\"1\":{\"276\":1}}],[\"则\",{\"1\":{\"276\":2,\"480\":1}}],[\"则向上返回\",{\"1\":{\"261\":1}}],[\"则会发生以下情况\",{\"1\":{\"261\":1}}],[\"则称\",{\"1\":{\"261\":2,\"274\":1}}],[\"则说明不是快乐数\",{\"1\":{\"200\":1}}],[\"则就说明没有循环\",{\"1\":{\"198\":1}}],[\"则需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素\",{\"1\":{\"160\":1}}],[\"则认为两个四元组重复\",{\"1\":{\"158\":1}}],[\"则在该链表中没有环\",{\"1\":{\"128\":1}}],[\"则链表中存在环\",{\"1\":{\"128\":1}}],[\"则返回\",{\"1\":{\"128\":1,\"196\":1,\"393\":1,\"412\":1,\"418\":1}}],[\"则可得到树的深度\",{\"1\":{\"82\":1}}],[\"则计数器\",{\"1\":{\"82\":1}}],[\"则为\",{\"1\":{\"68\":3}}],[\"则将节点的值输出\",{\"1\":{\"532\":1,\"536\":1}}],[\"则将其标记为灰色\",{\"1\":{\"532\":1,\"536\":1}}],[\"则将元素设置为\",{\"1\":{\"448\":1}}],[\"则将剩余字符全部反转\",{\"1\":{\"367\":1}}],[\"则将\",{\"1\":{\"60\":1,\"109\":1,\"118\":1}}],[\"内存的解决方案\",{\"1\":{\"579\":1}}],[\"内存地址是连续\",{\"1\":{\"501\":1}}],[\"内容\",{\"1\":{\"486\":1}}],[\"内\",{\"1\":{\"67\":1,\"100\":1,\"118\":1,\"128\":1,\"205\":1,\"244\":1,\"261\":1,\"266\":1,\"339\":1,\"384\":1,\"433\":1}}],[\"内部使用一个\",{\"1\":{\"574\":1}}],[\"内部使用同步代码块\",{\"1\":{\"26\":1}}],[\"内部类\",{\"1\":{\"486\":1}}],[\"内部类才会被加载并且实例化单例类\",{\"1\":{\"27\":1}}],[\"内部排序\",{\"1\":{\"443\":6}}],[\"内部定义一个\",{\"1\":{\"414\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"579\":1}}],[\"给你两个字符串\",{\"1\":{\"311\":1}}],[\"给你两棵二叉树\",{\"1\":{\"384\":1}}],[\"给你四个整数数组\",{\"1\":{\"331\":1}}],[\"给你一棵二叉树的根节点\",{\"1\":{\"244\":1}}],[\"给你一个按\",{\"1\":{\"424\":1}}],[\"给你一个正整数\",{\"1\":{\"376\":1}}],[\"给你一个二叉搜索树的根节点\",{\"1\":{\"358\":1}}],[\"给你一个二叉树的根节点\",{\"1\":{\"67\":1,\"433\":1}}],[\"给你一个含重复值的二叉搜索树\",{\"1\":{\"339\":1}}],[\"给你一个数组\",{\"1\":{\"283\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"205\":1}}],[\"给你一个链表\",{\"1\":{\"167\":1,\"266\":1}}],[\"给你一个由\",{\"1\":{\"158\":1}}],[\"给你一个字符串\",{\"1\":{\"146\":1}}],[\"给你一个整数数组\",{\"1\":{\"137\":1}}],[\"给你单链表的头节点\",{\"1\":{\"216\":1}}],[\"给定二叉搜索树\",{\"1\":{\"393\":1}}],[\"给定二叉树如图\",{\"1\":{\"109\":1,\"118\":1}}],[\"给定一棵二叉树的根节点\",{\"1\":{\"347\":1}}],[\"给定一个字符串\",{\"1\":{\"367\":1}}],[\"给定一个含有\",{\"1\":{\"228\":1}}],[\"给定一个只包括\",{\"1\":{\"187\":1}}],[\"给定一个链表的头节点\",{\"1\":{\"128\":1}}],[\"给定一个\",{\"1\":{\"109\":1,\"320\":1,\"401\":1}}],[\"给定一个二叉树的\",{\"1\":{\"176\":1}}],[\"给定一个二叉树\",{\"1\":{\"77\":1,\"100\":1,\"118\":1,\"261\":1}}],[\"给定一个整数数组\",{\"1\":{\"58\":1}}],[\"给定两个数组\",{\"1\":{\"301\":1}}],[\"给定两个字符串\",{\"1\":{\"274\":1}}],[\"给出由小写字母组成的字符串\",{\"1\":{\"88\":1}}],[\"对书中的每个节点都进行递归调用函数\",{\"1\":{\"527\":1}}],[\"对应正数\",{\"1\":{\"458\":1}}],[\"对应负数\",{\"1\":{\"458\":1}}],[\"对应的值累加起来\",{\"1\":{\"333\":1}}],[\"对每个桶进行排序\",{\"1\":{\"457\":1}}],[\"对每个非空的桶里的数据进行排序\",{\"1\":{\"457\":1}}],[\"对右边的子数组进行快速排序\",{\"1\":{\"454\":1}}],[\"对左边的子数组进行快速排序\",{\"1\":{\"454\":1}}],[\"对数组array从index\",{\"1\":{\"454\":1}}],[\"对象当成链表中的节点\",{\"1\":{\"414\":1}}],[\"对象\",{\"1\":{\"412\":1,\"562\":1}}],[\"对\",{\"1\":{\"198\":1}}],[\"对称二叉树\",{\"0\":{\"65\":1,\"66\":1}}],[\"对于\",{\"1\":{\"523\":1}}],[\"对于每一个未排序的元素\",{\"1\":{\"450\":1}}],[\"对于每个\",{\"1\":{\"60\":1}}],[\"对于未排序数据\",{\"1\":{\"450\":1}}],[\"对于一棵二叉搜索树来说\",{\"1\":{\"394\":1}}],[\"对于一个四位数来说\",{\"1\":{\"200\":1}}],[\"对于一个三位数来说\",{\"1\":{\"200\":1}}],[\"对于一个正整数\",{\"1\":{\"196\":1}}],[\"对于右子树也是一样的\",{\"1\":{\"388\":1}}],[\"对于相同节点位置\",{\"1\":{\"385\":1}}],[\"对于变量的边界怎么定义\",{\"1\":{\"380\":1}}],[\"对于有根树\",{\"1\":{\"261\":1}}],[\"对于有\",{\"1\":{\"256\":1}}],[\"对于其他的一对节点\",{\"1\":{\"71\":1}}],[\"对于根节点而已\",{\"1\":{\"71\":1}}],[\"对于a1\",{\"1\":{\"41\":1}}],[\"对于某个题型\",{\"1\":{\"3\":1}}],[\"令\",{\"1\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"141\":1,\"149\":1,\"151\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"239\":1,\"246\":1,\"248\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"371\":1,\"380\":1,\"386\":1,\"396\":1,\"405\":1,\"416\":1,\"419\":1,\"428\":1,\"436\":1,\"583\":1}}],[\"复制右半部分剩余的元素\",{\"1\":{\"453\":1}}],[\"复制左半部分剩余的元素\",{\"1\":{\"453\":1}}],[\"复杂度分析\",{\"1\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"239\":1,\"246\":1,\"248\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"371\":1,\"380\":1,\"386\":1,\"396\":1,\"405\":1,\"416\":1,\"419\":1,\"428\":1,\"436\":1,\"526\":1,\"527\":1,\"531\":1,\"583\":1}}],[\"复盘总结并不是流水账日记\",{\"1\":{\"5\":1}}],[\"<<\",{\"1\":{\"494\":1}}],[\"<target\",{\"1\":{\"403\":1,\"406\":1}}],[\"<3\",{\"1\":{\"141\":1}}],[\"<0>0=0\",{\"1\":{\"139\":1}}],[\"<\",{\"1\":{\"62\":1,\"121\":1,\"139\":1,\"141\":9,\"153\":3,\"158\":1,\"162\":8,\"171\":1,\"180\":1,\"232\":1,\"278\":2,\"283\":1,\"294\":1,\"296\":1,\"306\":1,\"313\":1,\"315\":1,\"331\":1,\"342\":1,\"371\":2,\"394\":1,\"396\":1,\"405\":2,\"406\":1,\"407\":1,\"419\":1,\"428\":2,\"446\":2,\"448\":1,\"449\":3,\"451\":1,\"452\":1,\"453\":1,\"454\":2,\"455\":2,\"456\":2,\"457\":2,\"458\":3,\"484\":1,\"485\":1,\"491\":3,\"494\":1,\"503\":3,\"504\":3,\"505\":2,\"522\":1,\"526\":1,\"574\":3}}],[\"<=bottom\",{\"1\":{\"380\":1}}],[\"<=\",{\"1\":{\"58\":6,\"67\":2,\"77\":2,\"88\":2,\"93\":1,\"95\":1,\"100\":2,\"109\":2,\"118\":2,\"128\":2,\"137\":4,\"146\":2,\"153\":3,\"158\":7,\"167\":6,\"176\":2,\"187\":2,\"196\":2,\"205\":4,\"216\":2,\"228\":6,\"236\":2,\"244\":2,\"253\":2,\"261\":2,\"266\":2,\"274\":2,\"283\":6,\"292\":2,\"301\":4,\"311\":2,\"315\":1,\"331\":5,\"339\":2,\"347\":2,\"358\":2,\"367\":4,\"376\":2,\"380\":2,\"384\":2,\"393\":4,\"407\":1,\"412\":2,\"416\":1,\"419\":1,\"424\":4,\"433\":2,\"434\":2,\"436\":1,\"437\":1,\"451\":1,\"453\":6,\"454\":1,\"457\":1,\"491\":1,\"503\":1,\"527\":1,\"579\":8}}],[\"hugecapacity\",{\"1\":{\"484\":1,\"485\":1}}],[\"h=n\",{\"1\":{\"351\":1}}],[\"h为树的高度\",{\"1\":{\"326\":1}}],[\"hasharea\",{\"1\":{\"491\":3}}],[\"hashcollisionrate\",{\"1\":{\"491\":2}}],[\"hashcodelist\",{\"1\":{\"491\":14}}],[\"hashcode\",{\"0\":{\"491\":1},\"1\":{\"491\":9,\"493\":2}}],[\"hashmap\",{\"0\":{\"489\":1,\"490\":1,\"492\":1},\"1\":{\"490\":2,\"494\":1},\"2\":{\"498\":1}}],[\"hashmap<integer\",{\"1\":{\"334\":1}}],[\"hashmap<>\",{\"1\":{\"62\":1}}],[\"hash\",{\"1\":{\"462\":1,\"490\":2,\"491\":6,\"493\":1,\"495\":1}}],[\"hash2\",{\"1\":{\"306\":3}}],[\"hash1\",{\"1\":{\"306\":3}}],[\"happy\",{\"1\":{\"195\":1}}],[\"height\",{\"1\":{\"517\":2}}],[\"heaparray\",{\"1\":{\"574\":8}}],[\"heap\",{\"1\":{\"574\":10}}],[\"heaptopmove\",{\"1\":{\"455\":4}}],[\"heapsort\",{\"1\":{\"455\":1}}],[\"headb\",{\"1\":{\"579\":1,\"581\":5,\"583\":4}}],[\"heada\",{\"1\":{\"579\":1,\"581\":5,\"583\":4}}],[\"head\",{\"1\":{\"128\":4,\"132\":6,\"167\":3,\"171\":4,\"205\":4,\"206\":2,\"208\":9,\"211\":1,\"216\":4,\"220\":2,\"221\":2,\"223\":8,\"266\":3,\"270\":5,\"416\":18,\"417\":1,\"419\":9}}],[\"hello\",{\"1\":{\"146\":2,\"462\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2}}],[\"h\",{\"1\":{\"104\":2,\"182\":3,\"292\":6,\"326\":1,\"351\":2,\"491\":6,\"493\":3,\"519\":1}}],[\"hh\",{\"1\":{\"93\":1,\"95\":2}}],[\"https\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"14\":1,\"36\":1,\"41\":1,\"46\":1,\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"358\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2,\"543\":1,\"578\":1}}],[\"语言支持\",{\"1\":{\"62\":1,\"92\":1,\"132\":1,\"141\":1,\"162\":1,\"171\":1,\"191\":1,\"200\":1,\"208\":1,\"220\":1,\"232\":1,\"239\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"334\":1,\"342\":1,\"361\":1,\"371\":1,\"380\":1,\"396\":1,\"416\":1,\"428\":1,\"583\":1}}],[\"语句时\",{\"1\":{\"24\":1}}],[\"语句块创建\",{\"1\":{\"23\":1}}],[\"每移动一次就减小\",{\"1\":{\"418\":1}}],[\"每计数至\",{\"1\":{\"367\":1}}],[\"每组子节点都由\",{\"1\":{\"320\":1}}],[\"每一个节点有两个指针域\",{\"1\":{\"560\":1}}],[\"每一个节点由两部分组成\",{\"1\":{\"557\":1}}],[\"每一层递归的操作都是o\",{\"1\":{\"527\":1}}],[\"每一层从左到右遍历时\",{\"1\":{\"179\":1}}],[\"每一次将该数替换为它每个位置上的数字的平方和\",{\"1\":{\"196\":1}}],[\"每遍历一层\",{\"1\":{\"82\":1}}],[\"每个循环存在不同的参数\",{\"1\":{\"491\":1}}],[\"每个数字的平方\",{\"1\":{\"424\":1}}],[\"每个字符的情况\",{\"1\":{\"313\":1}}],[\"每个右括号都有一个对应的相同类型的左括号\",{\"1\":{\"187\":1}}],[\"每个节点存放着下一个节点的内存地址\",{\"1\":{\"562\":1}}],[\"每个节点值都小于或等于子节点的值\",{\"1\":{\"455\":1}}],[\"每个节点值都大于或等于子节点的值\",{\"1\":{\"455\":1}}],[\"每个节点最多遍历一次\",{\"1\":{\"361\":1}}],[\"每个节点最多出队一次\",{\"1\":{\"324\":1,\"326\":1}}],[\"每个节点最多出队和入队一次\",{\"1\":{\"121\":1,\"123\":1}}],[\"每个节点最多进队列一次\",{\"1\":{\"180\":2,\"182\":1}}],[\"每个节点只访问一次\",{\"1\":{\"113\":1}}],[\"每个节点都会遍历一次\",{\"1\":{\"104\":1}}],[\"每个父节点都有两个子节点\",{\"1\":{\"109\":1}}],[\"每个几点最多进队一次\",{\"1\":{\"72\":1}}],[\"每个二叉树的右子树与另一个树的左子树互为镜像\",{\"1\":{\"69\":1}}],[\"每种输入只会对应一个答案\",{\"1\":{\"61\":1}}],[\"每次循环的\",{\"1\":{\"504\":1}}],[\"每次扩容都需要拷贝数组\",{\"1\":{\"486\":1}}],[\"每次从待排序的数据元素中选出最小\",{\"1\":{\"448\":1}}],[\"每次都要进行交换\",{\"1\":{\"446\":1}}],[\"每次都从\",{\"1\":{\"15\":1}}],[\"每次比较两个指针对应的数\",{\"1\":{\"426\":1}}],[\"每次翻转完\",{\"1\":{\"369\":1}}],[\"每次的\",{\"1\":{\"352\":1}}],[\"每次取出的数字变量为\",{\"1\":{\"285\":1}}],[\"每次调用\",{\"1\":{\"236\":1}}],[\"每次走一步\",{\"1\":{\"130\":1}}],[\"每次走\",{\"1\":{\"130\":1}}],[\"每次走两步\",{\"1\":{\"130\":2}}],[\"每次判断一对节点是否对称\",{\"1\":{\"70\":1,\"72\":1}}],[\"每次只有一个线程进入\",{\"1\":{\"25\":1}}],[\"假定\",{\"1\":{\"339\":1}}],[\"假设一种极端情况\",{\"1\":{\"504\":1}}],[\"假设链表中的所有节点下标从\",{\"1\":{\"412\":1}}],[\"假设由递归产生的隐式调用栈的开销不被计算在内\",{\"1\":{\"339\":1}}],[\"假设\",{\"1\":{\"283\":1}}],[\"假设为\",{\"1\":{\"261\":1}}],[\"假设所有操作都是有效的\",{\"1\":{\"253\":1}}],[\"假设循环中有\",{\"1\":{\"200\":1}}],[\"假设有一个对象\",{\"1\":{\"31\":1}}],[\"假如这个重复元素是解\",{\"1\":{\"60\":1}}],[\"xor\",{\"1\":{\"493\":4}}],[\"x+y+n\",{\"1\":{\"130\":2}}],[\"x+y\",{\"1\":{\"130\":2,\"132\":1}}],[\"x\",{\"1\":{\"60\":5,\"61\":2,\"130\":2,\"132\":2,\"162\":8,\"236\":3,\"239\":2,\"253\":3,\"256\":3,\"261\":3,\"263\":2,\"376\":1,\"450\":1,\"491\":3,\"517\":2,\"562\":2,\"566\":7,\"567\":12,\"583\":2}}],[\"思路是\",{\"1\":{\"533\":1}}],[\"思路改进\",{\"0\":{\"406\":1}}],[\"思路2\",{\"0\":{\"181\":1,\"209\":1,\"221\":1}}],[\"思路1\",{\"0\":{\"178\":1,\"206\":1,\"218\":1,\"230\":1,\"268\":1}}],[\"思路3\",{\"0\":{\"152\":1}}],[\"思路\",{\"0\":{\"60\":1,\"68\":1,\"71\":1,\"79\":1,\"82\":1,\"90\":1,\"93\":1,\"102\":1,\"111\":1,\"119\":1,\"122\":1,\"130\":1,\"139\":1,\"148\":1,\"150\":1,\"160\":1,\"169\":1,\"189\":1,\"198\":1,\"238\":1,\"247\":1,\"255\":1,\"276\":1,\"285\":1,\"294\":1,\"304\":1,\"313\":1,\"322\":1,\"325\":1,\"333\":1,\"340\":1,\"349\":1,\"352\":1,\"359\":1,\"369\":1,\"378\":1,\"385\":1,\"387\":1,\"394\":1,\"403\":1,\"414\":1,\"417\":1,\"426\":1,\"434\":1,\"581\":1},\"1\":{\"244\":1,\"261\":1}}],[\"思考了一下原因\",{\"1\":{\"2\":1}}],[\"前中后属于\",{\"1\":{\"523\":1}}],[\"前面\",{\"1\":{\"443\":2}}],[\"前序遍历的顺序是\",{\"1\":{\"533\":1}}],[\"前序遍历\",{\"0\":{\"385\":1,\"529\":1,\"533\":1,\"537\":1},\"1\":{\"385\":1,\"529\":1,\"543\":1}}],[\"前\",{\"0\":{\"528\":1},\"1\":{\"285\":1,\"528\":1}}],[\"前缀和+二分查找\",{\"1\":{\"229\":1}}],[\"前驱节点\",{\"1\":{\"220\":1,\"417\":1}}],[\"前置知识\",{\"0\":{\"59\":1,\"78\":1,\"89\":1,\"101\":1,\"110\":1,\"129\":1,\"138\":1,\"147\":1,\"159\":1,\"168\":1,\"177\":1,\"188\":1,\"197\":1,\"217\":1,\"229\":1,\"237\":1,\"254\":1,\"267\":1,\"275\":1,\"284\":1,\"293\":1,\"302\":1,\"312\":1,\"321\":1,\"332\":1,\"348\":1,\"368\":1,\"377\":1,\"402\":1,\"413\":1,\"425\":1,\"580\":1},\"1\":{\"118\":1,\"205\":1}}],[\"前者是为了解决\",{\"1\":{\"3\":1}}],[\"进行了数组的拷贝\",{\"1\":{\"486\":1}}],[\"进行收集\",{\"1\":{\"458\":1}}],[\"进行分区操作的函数\",{\"1\":{\"454\":1}}],[\"进行比较\",{\"1\":{\"445\":1}}],[\"进行递归\",{\"1\":{\"385\":1}}],[\"进行值合并\",{\"1\":{\"385\":1}}],[\"进行层序遍历\",{\"1\":{\"352\":1}}],[\"进行\",{\"1\":{\"323\":1}}],[\"进行下一轮的判断并且交换\",{\"1\":{\"268\":1}}],[\"进行遍历\",{\"1\":{\"169\":1}}],[\"进行遍历时\",{\"1\":{\"123\":1}}],[\"进行接触\",{\"1\":{\"15\":1}}],[\"进阶\",{\"1\":{\"58\":1,\"67\":1,\"109\":1,\"118\":1,\"128\":1,\"146\":1,\"167\":1,\"216\":1,\"228\":1,\"236\":1,\"253\":1,\"274\":1,\"339\":1,\"424\":1,\"579\":1}}],[\"只出现在最底层且靠右的位置\",{\"1\":{\"540\":1}}],[\"只不是把上面的\",{\"1\":{\"475\":1}}],[\"只包含\",{\"1\":{\"433\":1}}],[\"只要有一个是\",{\"1\":{\"388\":1}}],[\"只要两颗树的左节点都不为\",{\"1\":{\"387\":1}}],[\"只要是标准的栈操作即可\",{\"1\":{\"253\":1}}],[\"只要是标准的队列操作即可\",{\"1\":{\"236\":1}}],[\"只有遇到空节点的时候\",{\"1\":{\"537\":3}}],[\"只有这样做\",{\"1\":{\"504\":1}}],[\"只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作\",{\"1\":{\"386\":1}}],[\"只有\",{\"1\":{\"278\":1}}],[\"只有根节点时\",{\"1\":{\"102\":1}}],[\"只能进行节点交换\",{\"1\":{\"266\":1}}],[\"只能\",{\"1\":{\"253\":1}}],[\"只能让第三个枚举元素的下标向左移动\",{\"1\":{\"141\":1}}],[\"只会存在一个有效答案\",{\"1\":{\"58\":1}}],[\"只与代理\",{\"1\":{\"15\":2}}],[\"提前将\",{\"1\":{\"247\":1}}],[\"提示\",{\"1\":{\"58\":1,\"67\":1,\"77\":1,\"88\":1,\"100\":1,\"109\":1,\"118\":1,\"128\":1,\"137\":1,\"146\":1,\"158\":1,\"167\":1,\"176\":1,\"187\":1,\"196\":1,\"205\":1,\"216\":1,\"228\":1,\"236\":1,\"244\":1,\"253\":1,\"261\":1,\"266\":1,\"274\":1,\"283\":1,\"292\":1,\"301\":1,\"311\":1,\"320\":1,\"331\":1,\"339\":1,\"347\":1,\"358\":1,\"367\":1,\"376\":1,\"384\":1,\"393\":1,\"401\":1,\"412\":1,\"424\":1,\"433\":1,\"579\":1}}],[\"提供构造过程的不同实现\",{\"1\":{\"47\":1}}],[\"提供一个\",{\"1\":{\"20\":1}}],[\"637\",{\"1\":{\"544\":1}}],[\"67108864\",{\"1\":{\"491\":2}}],[\"617\",{\"0\":{\"382\":1,\"383\":1}}],[\"62\",{\"1\":{\"196\":1}}],[\"68\",{\"1\":{\"196\":1}}],[\"6000\",{\"1\":{\"118\":1}}],[\"6\",{\"1\":{\"58\":2,\"100\":1,\"109\":2,\"205\":3,\"244\":2,\"261\":2,\"320\":4,\"358\":1,\"376\":1,\"433\":1,\"529\":1,\"530\":1,\"531\":1,\"543\":1,\"579\":2}}],[\"404\",{\"1\":{\"586\":1}}],[\"49\",{\"1\":{\"358\":1,\"424\":1}}],[\"48\",{\"1\":{\"358\":1}}],[\"454\",{\"0\":{\"329\":1,\"330\":1}}],[\"429\",{\"0\":{\"318\":1,\"319\":1},\"1\":{\"544\":1}}],[\"4位数只会降到3位数\",{\"1\":{\"200\":1}}],[\"4sum\",{\"1\":{\"157\":1,\"330\":1}}],[\"4\",{\"1\":{\"58\":2,\"67\":2,\"77\":1,\"100\":1,\"109\":2,\"118\":2,\"128\":2,\"137\":3,\"146\":1,\"167\":1,\"176\":2,\"205\":3,\"216\":2,\"228\":5,\"244\":2,\"256\":1,\"261\":4,\"266\":2,\"274\":1,\"283\":3,\"301\":5,\"320\":5,\"339\":1,\"347\":1,\"358\":1,\"367\":2,\"376\":1,\"384\":5,\"393\":2,\"401\":2,\"424\":5,\"433\":3,\"494\":1,\"495\":1,\"579\":13}}],[\"31∗i==\",{\"1\":{\"491\":1}}],[\"31\",{\"0\":{\"491\":1},\"1\":{\"347\":2,\"433\":2,\"491\":2}}],[\"383\",{\"0\":{\"309\":1,\"310\":1}}],[\"349\",{\"0\":{\"299\":1,\"300\":1}}],[\"344\",{\"0\":{\"290\":1,\"291\":1}}],[\"324\",{\"1\":{\"200\":1}}],[\"30\",{\"1\":{\"167\":1,\"494\":1,\"574\":1}}],[\"3000\",{\"1\":{\"137\":1}}],[\"3sum\",{\"1\":{\"136\":1}}],[\"3\",{\"0\":{\"505\":1},\"1\":{\"58\":4,\"60\":1,\"67\":4,\"77\":2,\"100\":2,\"109\":2,\"118\":2,\"128\":2,\"137\":3,\"146\":1,\"162\":3,\"167\":3,\"176\":5,\"187\":1,\"205\":3,\"216\":3,\"228\":4,\"244\":5,\"246\":1,\"256\":1,\"261\":5,\"266\":3,\"283\":6,\"311\":1,\"320\":4,\"347\":5,\"358\":1,\"376\":2,\"378\":1,\"384\":3,\"393\":3,\"401\":2,\"407\":1,\"412\":6,\"424\":3,\"433\":2,\"521\":1,\"529\":1,\"530\":1,\"531\":1,\"543\":1,\"579\":9}}],[\"07\",{\"0\":{\"577\":1,\"578\":1},\"1\":{\"552\":1}}],[\"0x7fffffff\",{\"1\":{\"491\":1}}],[\"0x80000000\",{\"1\":{\"491\":1}}],[\"02\",{\"0\":{\"578\":1},\"1\":{\"196\":2,\"552\":1}}],[\"0\",{\"1\":{\"58\":4,\"62\":2,\"77\":1,\"79\":1,\"81\":1,\"83\":2,\"92\":1,\"95\":3,\"100\":1,\"104\":1,\"109\":1,\"118\":1,\"121\":1,\"128\":5,\"137\":21,\"139\":6,\"141\":14,\"151\":3,\"153\":4,\"158\":8,\"162\":2,\"167\":1,\"171\":1,\"176\":1,\"180\":1,\"182\":1,\"200\":2,\"205\":2,\"216\":1,\"228\":2,\"232\":6,\"239\":2,\"244\":1,\"261\":2,\"266\":2,\"270\":1,\"276\":1,\"278\":3,\"283\":11,\"287\":1,\"296\":1,\"301\":1,\"306\":4,\"313\":1,\"315\":1,\"320\":1,\"324\":1,\"326\":1,\"331\":20,\"334\":2,\"339\":2,\"340\":4,\"342\":3,\"347\":1,\"351\":1,\"353\":1,\"358\":2,\"362\":1,\"371\":1,\"380\":2,\"384\":1,\"401\":2,\"403\":1,\"405\":1,\"406\":1,\"407\":1,\"412\":2,\"416\":4,\"418\":1,\"419\":3,\"424\":4,\"426\":1,\"428\":1,\"446\":3,\"449\":2,\"450\":1,\"451\":1,\"452\":2,\"453\":2,\"455\":4,\"456\":4,\"457\":7,\"458\":9,\"475\":1,\"480\":3,\"482\":2,\"484\":5,\"485\":3,\"486\":1,\"491\":8,\"493\":8,\"494\":1,\"495\":2,\"501\":1,\"503\":2,\"504\":6,\"505\":2,\"517\":1,\"519\":1,\"526\":1,\"527\":1,\"543\":3,\"574\":4,\"579\":12,\"581\":2}}],[\"06\",{\"1\":{\"0\":3}}],[\"输出结果中的每个元素一定是\",{\"1\":{\"301\":1}}],[\"输出一个节点\",{\"1\":{\"221\":1}}],[\"输出的顺序和三元组的顺序并不重要\",{\"1\":{\"137\":1}}],[\"输出\",{\"1\":{\"58\":3,\"67\":2,\"77\":2,\"88\":1,\"100\":2,\"109\":2,\"118\":2,\"128\":3,\"137\":3,\"146\":3,\"158\":2,\"167\":3,\"176\":3,\"187\":3,\"196\":2,\"205\":3,\"216\":3,\"228\":3,\"236\":1,\"244\":3,\"253\":1,\"261\":3,\"266\":3,\"274\":2,\"283\":2,\"292\":2,\"301\":2,\"311\":3,\"320\":2,\"331\":2,\"339\":2,\"347\":2,\"358\":2,\"367\":2,\"376\":2,\"384\":2,\"393\":2,\"401\":2,\"412\":1,\"424\":2,\"433\":2,\"579\":3}}],[\"输入数组\",{\"1\":{\"283\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"292\":1}}],[\"输入字符串\",{\"1\":{\"146\":1}}],[\"输入\",{\"1\":{\"58\":3,\"67\":2,\"77\":2,\"88\":1,\"100\":2,\"109\":2,\"118\":2,\"128\":3,\"137\":3,\"146\":3,\"158\":2,\"167\":3,\"176\":3,\"187\":3,\"196\":2,\"205\":3,\"216\":3,\"228\":3,\"236\":1,\"244\":3,\"253\":1,\"261\":3,\"266\":3,\"274\":2,\"283\":2,\"292\":2,\"301\":2,\"311\":3,\"320\":2,\"331\":2,\"339\":2,\"347\":2,\"358\":2,\"367\":2,\"376\":2,\"384\":2,\"393\":2,\"401\":2,\"412\":1,\"424\":2,\"433\":2,\"579\":3}}],[\"98\",{\"0\":{\"431\":1,\"432\":1}}],[\"977\",{\"0\":{\"422\":1,\"423\":1}}],[\"9999\",{\"1\":{\"401\":2}}],[\"9^2+9^2+9^2\",{\"1\":{\"200\":1}}],[\"92\",{\"1\":{\"196\":1}}],[\"9\",{\"1\":{\"58\":6,\"77\":1,\"100\":1,\"236\":1,\"244\":2,\"253\":1,\"261\":2,\"301\":5,\"320\":2,\"347\":2,\"376\":1,\"401\":4,\"424\":5,\"458\":1,\"579\":2}}],[\"732\",{\"1\":{\"540\":2}}],[\"75\",{\"1\":{\"495\":1}}],[\"75f\",{\"1\":{\"495\":1}}],[\"707\",{\"0\":{\"410\":1,\"411\":1},\"1\":{\"551\":1}}],[\"704\",{\"0\":{\"399\":1,\"400\":1}}],[\"700\",{\"0\":{\"391\":1,\"392\":1}}],[\"783\",{\"1\":{\"358\":1}}],[\"7\",{\"1\":{\"58\":1,\"77\":1,\"100\":1,\"109\":2,\"118\":2,\"205\":5,\"228\":1,\"244\":2,\"261\":2,\"320\":2,\"376\":1,\"384\":2,\"393\":4,\"424\":1,\"490\":1,\"504\":1,\"529\":1,\"530\":1,\"531\":1,\"543\":1}}],[\"2h+1−1\",{\"1\":{\"519\":1}}],[\"25是32\",{\"1\":{\"491\":1}}],[\"2k\",{\"1\":{\"367\":3,\"369\":1}}],[\"28\",{\"1\":{\"331\":2}}],[\"27\",{\"0\":{\"281\":1,\"282\":1}}],[\"26\",{\"1\":{\"278\":3,\"313\":1,\"314\":1,\"315\":2}}],[\"242\",{\"0\":{\"272\":1,\"273\":1},\"1\":{\"314\":1}}],[\"24\",{\"0\":{\"264\":1,\"265\":1}}],[\"243\",{\"1\":{\"200\":1}}],[\"236\",{\"0\":{\"259\":1,\"260\":1}}],[\"232\",{\"0\":{\"251\":1,\"252\":1}}],[\"231\",{\"1\":{\"196\":1}}],[\"2⋅logn\",{\"1\":{\"200\":1}}],[\"226\",{\"0\":{\"242\":1,\"243\":1}}],[\"225\",{\"0\":{\"234\":1,\"235\":1}}],[\"22\",{\"1\":{\"196\":1}}],[\"2n+1\",{\"1\":{\"239\":1}}],[\"2n\",{\"1\":{\"70\":1,\"132\":1}}],[\"2\",{\"0\":{\"71\":1,\"82\":1,\"93\":1,\"122\":1,\"150\":1,\"247\":1,\"325\":1,\"352\":1,\"504\":1},\"1\":{\"58\":6,\"67\":5,\"72\":1,\"77\":3,\"83\":1,\"100\":3,\"109\":4,\"118\":3,\"128\":3,\"130\":1,\"137\":7,\"146\":1,\"158\":16,\"162\":5,\"167\":5,\"171\":2,\"176\":2,\"187\":1,\"191\":2,\"196\":2,\"198\":1,\"205\":3,\"216\":5,\"220\":3,\"228\":4,\"236\":6,\"244\":5,\"246\":1,\"248\":1,\"253\":4,\"256\":1,\"261\":6,\"266\":3,\"274\":1,\"283\":12,\"292\":1,\"296\":1,\"301\":6,\"311\":1,\"320\":5,\"331\":12,\"339\":4,\"340\":4,\"347\":5,\"358\":3,\"367\":3,\"369\":1,\"371\":1,\"376\":3,\"384\":6,\"385\":1,\"386\":1,\"387\":4,\"393\":5,\"401\":3,\"405\":1,\"406\":1,\"407\":2,\"412\":5,\"419\":1,\"424\":2,\"433\":4,\"452\":2,\"453\":1,\"455\":4,\"458\":1,\"494\":1,\"503\":1,\"504\":2,\"505\":1,\"517\":1,\"519\":2,\"526\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":1,\"543\":1,\"574\":8,\"579\":13}}],[\"209\",{\"0\":{\"226\":1,\"227\":1}}],[\"206\",{\"0\":{\"214\":1,\"215\":1},\"1\":{\"549\":1}}],[\"203\",{\"0\":{\"203\":1,\"204\":1},\"1\":{\"548\":1}}],[\"202\",{\"0\":{\"194\":1,\"195\":1}}],[\"2024\",{\"1\":{\"0\":3}}],[\"2000\",{\"1\":{\"384\":1,\"412\":1}}],[\"20000\",{\"1\":{\"88\":1}}],[\"200\",{\"1\":{\"158\":1,\"331\":1}}],[\"20\",{\"0\":{\"185\":1,\"186\":1},\"1\":{\"0\":1,\"77\":1,\"100\":1,\"376\":1}}],[\"示例\",{\"1\":{\"58\":3,\"67\":2,\"77\":2,\"88\":1,\"100\":2,\"109\":2,\"118\":2,\"128\":3,\"137\":3,\"146\":3,\"158\":2,\"167\":3,\"176\":3,\"187\":3,\"196\":2,\"205\":3,\"216\":3,\"228\":3,\"236\":1,\"244\":3,\"253\":1,\"261\":3,\"266\":3,\"274\":2,\"283\":2,\"292\":2,\"301\":2,\"311\":3,\"320\":2,\"331\":2,\"339\":2,\"347\":2,\"358\":2,\"367\":2,\"376\":2,\"384\":2,\"393\":2,\"401\":2,\"412\":1,\"424\":2,\"433\":2,\"579\":3}}],[\"两者背后的思想是一致的\",{\"1\":{\"524\":1}}],[\"两棵树中的节点数目在范围\",{\"1\":{\"384\":1}}],[\"两棵树上的一些节点将会重叠\",{\"1\":{\"384\":1}}],[\"两两交换其中相邻的节点\",{\"1\":{\"266\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"264\":1,\"265\":1}}],[\"两节点都在\",{\"1\":{\"261\":1}}],[\"两对称节点值相同\",{\"1\":{\"69\":1}}],[\"两个元组如下\",{\"1\":{\"331\":1}}],[\"两个存储数组都是固定长度\",{\"1\":{\"306\":1}}],[\"两个数组的交集\",{\"0\":{\"299\":1,\"300\":1}}],[\"两个指针分别指向待反转的范围\",{\"1\":{\"369\":1}}],[\"两个指针\",{\"1\":{\"296\":1}}],[\"两个二叉树同时进行深度优先搜索\",{\"1\":{\"386\":1}}],[\"两个二叉树的根节点的值相等\",{\"1\":{\"69\":1}}],[\"两个二叉树互为镜像的定义\",{\"1\":{\"69\":1}}],[\"两个\",{\"1\":{\"58\":1}}],[\"两数之和思路\",{\"1\":{\"332\":1}}],[\"两数之和\",{\"0\":{\"56\":1,\"57\":1}}],[\"力扣\",{\"0\":{\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"578\":1}}],[\"返回以该节点为根的子树\",{\"1\":{\"393\":1}}],[\"返回合并后的二叉树\",{\"1\":{\"384\":1}}],[\"返回其节点值的\",{\"1\":{\"320\":1}}],[\"返回其最大深度\",{\"1\":{\"77\":1}}],[\"返回队列开头的元素\",{\"1\":{\"253\":1}}],[\"返回栈顶元素\",{\"1\":{\"236\":1}}],[\"返回反转之后的头节点\",{\"1\":{\"221\":1}}],[\"返回从右侧所能看到的节点值\",{\"1\":{\"176\":1}}],[\"返回答案\",{\"1\":{\"158\":1}}],[\"返回的结果字符串中\",{\"1\":{\"146\":1}}],[\"返回索引为\",{\"1\":{\"128\":2}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"128\":1}}],[\"返回左右孩子较小深度的节点值\",{\"1\":{\"102\":1}}],[\"返回不为空的孩子节点的深度\",{\"1\":{\"102\":1}}],[\"返回树的深度\",{\"1\":{\"79\":1}}],[\"返回值是树的节点\",{\"1\":{\"394\":1}}],[\"返回值是根点\",{\"1\":{\"385\":1}}],[\"返回值是对称标志\",{\"1\":{\"68\":1}}],[\"返回值为void\",{\"1\":{\"359\":1}}],[\"返回值\",{\"1\":{\"79\":1,\"244\":1}}],[\"返回\",{\"1\":{\"58\":1,\"128\":1,\"146\":1,\"228\":1,\"236\":5,\"246\":1,\"253\":2,\"261\":2,\"283\":1,\"301\":1,\"311\":1,\"339\":1,\"358\":1,\"412\":2,\"424\":1,\"579\":1}}],[\"返回对应的产品\",{\"1\":{\"54\":1}}],[\"返回新的实例\",{\"1\":{\"31\":1}}],[\"客户端不需要知道有哪些子类\",{\"1\":{\"52\":1}}],[\"客户端代码\",{\"1\":{\"17\":1}}],[\"来存储元素\",{\"1\":{\"574\":1}}],[\"来存储当前节点的上一个节点情况\",{\"1\":{\"359\":1}}],[\"来作为\",{\"1\":{\"574\":1}}],[\"来说是两个关键点\",{\"1\":{\"523\":1}}],[\"来简化操作\",{\"1\":{\"523\":1}}],[\"来实现这一功能\",{\"1\":{\"574\":1}}],[\"来实现\",{\"1\":{\"523\":1,\"524\":1}}],[\"来实现具体的实例化过程\",{\"1\":{\"52\":1}}],[\"来定义左边界\",{\"1\":{\"403\":1}}],[\"来表示当前元素的重复次数\",{\"1\":{\"340\":1}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"128\":1}}],[\"来记录当前节点的上一个节点情况\",{\"1\":{\"340\":1}}],[\"来自题解区\",{\"1\":{\"261\":1}}],[\"来模拟一个栈\",{\"1\":{\"253\":1}}],[\"来模拟一个队列\",{\"1\":{\"236\":1}}],[\"来到大学以后\",{\"1\":{\"2\":1}}],[\"单端队列遵循先进先出\",{\"1\":{\"574\":1}}],[\"单端队列和双端队列\",{\"1\":{\"574\":1}}],[\"单向链表\",{\"1\":{\"416\":1}}],[\"单链表\",{\"0\":{\"559\":1}}],[\"单链表实现\",{\"0\":{\"414\":1}}],[\"单链表中的节点应该具备两个属性\",{\"1\":{\"412\":1}}],[\"单层递归\",{\"1\":{\"385\":1}}],[\"单层递归逻辑\",{\"1\":{\"68\":1,\"79\":1,\"81\":1,\"244\":1,\"246\":1}}],[\"单层的最后一个元素就是最右元素\",{\"1\":{\"180\":1}}],[\"单词间应当仅用单个空格分隔\",{\"1\":{\"146\":1}}],[\"单词\",{\"1\":{\"146\":6}}],[\"单独的类\",{\"1\":{\"52\":1}}],[\"单例模式\",{\"0\":{\"19\":1},\"1\":{\"9\":1}}],[\"可能等于答案\",{\"1\":{\"406\":1}}],[\"可能会\",{\"1\":{\"371\":1}}],[\"可能新的头结点也值相等\",{\"1\":{\"208\":1}}],[\"可以是任意值\",{\"1\":{\"579\":1}}],[\"可以实现流量控制\",{\"1\":{\"574\":1}}],[\"可以很方便进行删除操作\",{\"1\":{\"548\":1}}],[\"可以通过实践\",{\"1\":{\"491\":1}}],[\"可以通过连续跟踪\",{\"1\":{\"128\":1}}],[\"可以提前结束\",{\"1\":{\"446\":1}}],[\"可以按\",{\"1\":{\"339\":1}}],[\"可以看成使用了一个额外的数组存储了数组\",{\"1\":{\"162\":1}}],[\"可以执行重复项删除操作\",{\"1\":{\"88\":1}}],[\"可以创建和复用特定的产品配置\",{\"1\":{\"47\":1}}],[\"可那个人他忘了得先完成作业啊\",{\"1\":{\"2\":1}}],[\"最左的下标为\",{\"1\":{\"504\":1}}],[\"最好情况下是\",{\"1\":{\"476\":1}}],[\"最近的公共祖先\",{\"1\":{\"261\":1}}],[\"最近公共祖先定义\",{\"1\":{\"262\":1}}],[\"最近公共祖先节点\",{\"1\":{\"261\":1}}],[\"最近公共祖先的定义\",{\"1\":{\"261\":1}}],[\"最近公共祖先表示为一个节点\",{\"1\":{\"261\":1}}],[\"最小\",{\"1\":{\"507\":1}}],[\"最小的2进制数值\",{\"1\":{\"494\":1}}],[\"最小窗口长度右移\",{\"1\":{\"232\":1}}],[\"最小深度是从根节点到最近叶子节点的最短路径上的节点数量\",{\"1\":{\"100\":1}}],[\"最多调用\",{\"1\":{\"236\":1,\"253\":1}}],[\"最多为\",{\"1\":{\"223\":1}}],[\"最多是1\",{\"1\":{\"191\":1}}],[\"最大堆\",{\"1\":{\"574\":1}}],[\"最大堆的特点是父节点的优先级总是\",{\"1\":{\"574\":1}}],[\"最大子数组问题\",{\"1\":{\"507\":1}}],[\"最大的平方和为\",{\"1\":{\"200\":2}}],[\"最大深度\",{\"1\":{\"77\":1}}],[\"最后翻转结果\",{\"1\":{\"535\":1}}],[\"最后返回\",{\"1\":{\"504\":1}}],[\"最后返回的结果\",{\"1\":{\"504\":1}}],[\"最后返回的时候是\",{\"1\":{\"210\":1}}],[\"最后循环\",{\"1\":{\"504\":1}}],[\"最后在将元素放进数组中\",{\"1\":{\"484\":1}}],[\"最后再将排序好的数据拼接起来\",{\"1\":{\"457\":1}}],[\"最后再判断栈是不是为空\",{\"1\":{\"189\":1}}],[\"最后一个节点的指针域指向\",{\"1\":{\"557\":1}}],[\"最后一个节点的后驱节点是新节点\",{\"1\":{\"416\":1}}],[\"最后一个元素就是最大的元素\",{\"1\":{\"445\":1}}],[\"最后一次翻转\",{\"1\":{\"370\":1}}],[\"最后\",{\"1\":{\"285\":1}}],[\"最后也会一层一层的往上传结果\",{\"1\":{\"261\":1}}],[\"最后会返回1\",{\"1\":{\"200\":1}}],[\"最后将所有单词拼接起来\",{\"1\":{\"150\":1}}],[\"最后还要通过哈希表进行去重\",{\"1\":{\"139\":1}}],[\"最后两个人在一起了\",{\"1\":{\"15\":1}}],[\"最终会去调用\",{\"1\":{\"485\":1}}],[\"最终是使\",{\"1\":{\"484\":1}}],[\"最终\",{\"1\":{\"130\":1,\"504\":1}}],[\"最终生成的对象\",{\"1\":{\"47\":1}}],[\"最坏情况\",{\"1\":{\"326\":1}}],[\"最坏情况下是\",{\"1\":{\"476\":1}}],[\"最坏情况下递归需要\",{\"1\":{\"396\":1}}],[\"最坏情况下为一条链条\",{\"1\":{\"361\":1}}],[\"最坏情况下\",{\"1\":{\"104\":1,\"182\":1,\"324\":1,\"334\":1,\"351\":1}}],[\"最坏的情况是字符串中不存在相邻重复项\",{\"1\":{\"92\":1,\"95\":1}}],[\"最差情况下\",{\"1\":{\"81\":1,\"83\":1,\"246\":1,\"248\":1,\"583\":1}}],[\"最差情况\",{\"1\":{\"70\":1}}],[\"画一双瘦脚\",{\"1\":{\"48\":1}}],[\"画一双瘦手\",{\"1\":{\"48\":1}}],[\"画一双胖脚\",{\"1\":{\"48\":1}}],[\"画一双胖手\",{\"1\":{\"48\":1}}],[\"画一个瘦身\",{\"1\":{\"48\":1}}],[\"画一个瘦头\",{\"1\":{\"48\":1}}],[\"画一个胖身\",{\"1\":{\"48\":1}}],[\"画一个胖头\",{\"1\":{\"48\":1}}],[\"画手\",{\"1\":{\"46\":1}}],[\"画脚\",{\"1\":{\"46\":2}}],[\"画头\",{\"1\":{\"46\":1}}],[\"脚\",{\"1\":{\"46\":1}}],[\"手写字符串api\",{\"0\":{\"152\":1}}],[\"手\",{\"1\":{\"46\":1}}],[\"手里接过礼物\",{\"1\":{\"15\":1}}],[\"身体\",{\"1\":{\"46\":1}}],[\"身体不舒服之类\",{\"1\":{\"3\":1}}],[\"要求也按\",{\"1\":{\"424\":1}}],[\"要注意\",{\"1\":{\"371\":1}}],[\"要更新\",{\"1\":{\"369\":1}}],[\"要清空\",{\"1\":{\"340\":1}}],[\"要移除的值\",{\"1\":{\"283\":1}}],[\"要通过此题\",{\"1\":{\"283\":1}}],[\"要将\",{\"1\":{\"231\":1}}],[\"要删除一个节点\",{\"1\":{\"210\":1}}],[\"要走\",{\"1\":{\"132\":2}}],[\"要有头\",{\"1\":{\"46\":1}}],[\"要时不时接受市场的检验\",{\"1\":{\"5\":1}}],[\"从各自的表头开始算起\",{\"1\":{\"579\":3}}],[\"从宏观上表现为\",{\"1\":{\"533\":1}}],[\"从顶部到底部逐层遍历二叉树\",{\"1\":{\"524\":1}}],[\"从顶至底递增\",{\"1\":{\"517\":1}}],[\"从距离该节点最远的叶节点到该节点所经过的\",{\"1\":{\"517\":1}}],[\"从根节点到该节点所经过的\",{\"1\":{\"517\":1}}],[\"从根节点到最远叶节点所经过的\",{\"1\":{\"517\":1}}],[\"从根节点开始\",{\"1\":{\"113\":1}}],[\"从而维持系统的稳定运行\",{\"1\":{\"574\":1}}],[\"从而将\",{\"1\":{\"507\":1}}],[\"从而生成不同形式的对象\",{\"1\":{\"46\":1}}],[\"从第二个元素开始遍历\",{\"1\":{\"451\":1}}],[\"从后向前\",{\"1\":{\"450\":1}}],[\"从最小值long\",{\"1\":{\"437\":1}}],[\"从前往后遍历\",{\"1\":{\"418\":1}}],[\"从右向左填充\",{\"1\":{\"380\":2}}],[\"从右到左\",{\"1\":{\"180\":1,\"378\":1}}],[\"从上向下我们可以直接递归访问即可\",{\"1\":{\"533\":1}}],[\"从上向下填充\",{\"1\":{\"380\":2}}],[\"从上到下\",{\"1\":{\"378\":1}}],[\"从左向右填充\",{\"1\":{\"380\":1}}],[\"从左到右填充\",{\"1\":{\"380\":1}}],[\"从左到右\",{\"1\":{\"325\":1,\"378\":1}}],[\"从左到右出队将其串联起来\",{\"1\":{\"119\":1}}],[\"从下向上我们只需要借助栈也可以轻易做到\",{\"1\":{\"533\":1}}],[\"从下向上填充\",{\"1\":{\"380\":2}}],[\"从下到上\",{\"1\":{\"378\":1}}],[\"从下一层的最左边开始遍历\",{\"1\":{\"113\":1}}],[\"从字符串开头算起\",{\"1\":{\"367\":1}}],[\"从底至顶回溯\",{\"1\":{\"261\":1}}],[\"从队列的开头移除并返回元素\",{\"1\":{\"253\":1}}],[\"从当前节点的后驱节点进行遍历\",{\"1\":{\"206\":1}}],[\"从链表头部到入环点的距离\",{\"1\":{\"130\":1}}],[\"从\",{\"1\":{\"130\":1,\"450\":1,\"581\":2}}],[\"从相遇节点\",{\"1\":{\"130\":1}}],[\"从头节点到环形入口节点的节点数为\",{\"1\":{\"130\":1}}],[\"从头节点出发\",{\"1\":{\"130\":1}}],[\"从小到大\",{\"1\":{\"2\":1}}],[\"需要独占访问\",{\"1\":{\"574\":1}}],[\"需要将层次顺序遍历结果存储在一个2d\",{\"1\":{\"527\":1}}],[\"需要将元素从\",{\"1\":{\"255\":1}}],[\"需要一个\",{\"1\":{\"417\":1}}],[\"需要同时更新\",{\"1\":{\"415\":1}}],[\"需要开辟\",{\"1\":{\"246\":1}}],[\"需要遍历树的所有节点\",{\"1\":{\"246\":1,\"248\":1}}],[\"需要使用两个队列存储栈内的元素\",{\"1\":{\"239\":1}}],[\"需要往\",{\"1\":{\"139\":2}}],[\"需要创建一个长度为\",{\"1\":{\"95\":1}}],[\"需要创建一个队列来存储情况\",{\"1\":{\"92\":1}}],[\"需要递归一次\",{\"1\":{\"70\":1,\"72\":1}}],[\"需要用到a类型\",{\"1\":{\"41\":1}}],[\"需要维护某种全局状态时\",{\"1\":{\"21\":1}}],[\"产品接口的不同实现\",{\"1\":{\"36\":1}}],[\"产品接口\",{\"1\":{\"36\":1}}],[\"产品\",{\"1\":{\"36\":1,\"47\":1}}],[\"multipliers\",{\"1\":{\"491\":2}}],[\"multiplier\",{\"1\":{\"491\":9}}],[\"modcount++\",{\"1\":{\"484\":1,\"485\":1}}],[\"modcount\",{\"1\":{\"484\":1}}],[\"mod\",{\"1\":{\"458\":5}}],[\"mode`\",{\"1\":{\"340\":1}}],[\"mode\",{\"1\":{\"338\":1,\"340\":4,\"342\":8}}],[\"m\",{\"1\":{\"443\":1,\"550\":1,\"579\":3}}],[\"mid+\",{\"1\":{\"505\":1}}],[\"mid+1\",{\"1\":{\"503\":1}}],[\"middle\",{\"1\":{\"453\":8}}],[\"mid−1\",{\"1\":{\"403\":1,\"503\":1}}],[\"mid\",{\"1\":{\"403\":6,\"405\":6,\"406\":8,\"407\":6,\"503\":12,\"504\":11,\"505\":10}}],[\"minhash\",{\"1\":{\"491\":2}}],[\"mincapacity\",{\"1\":{\"484\":13,\"485\":9}}],[\"minvalue\",{\"1\":{\"457\":5}}],[\"minindex\",{\"1\":{\"449\":5}}],[\"minimum\",{\"1\":{\"99\":1,\"227\":1,\"357\":1,\"358\":1}}],[\"minsubarraylen\",{\"1\":{\"232\":1}}],[\"min\",{\"1\":{\"104\":2,\"232\":1,\"353\":1,\"361\":1,\"362\":1,\"370\":1,\"371\":1,\"386\":2,\"436\":1,\"437\":5,\"491\":4}}],[\"mindepth\",{\"1\":{\"104\":3}}],[\"mergesort\",{\"1\":{\"453\":3}}],[\"mergetrees\",{\"1\":{\"385\":1,\"386\":3,\"388\":1}}],[\"merge\",{\"1\":{\"383\":1,\"453\":2}}],[\"method\",{\"1\":{\"36\":1}}],[\"m+n\",{\"1\":{\"306\":3}}],[\"m为nums2数组长度\",{\"1\":{\"306\":1}}],[\"mylinkedlist\",{\"1\":{\"412\":13,\"416\":5,\"419\":2}}],[\"myqueue\",{\"1\":{\"253\":10,\"256\":5}}],[\"mystack\",{\"1\":{\"236\":10,\"239\":2}}],[\"matrix\",{\"1\":{\"375\":1,\"376\":1}}],[\"math\",{\"1\":{\"79\":1,\"80\":1,\"81\":1,\"104\":2,\"232\":1,\"351\":1,\"353\":1,\"361\":1,\"362\":1,\"370\":1,\"371\":1,\"428\":6,\"455\":1,\"457\":2,\"484\":1}}],[\"magazine\",{\"1\":{\"311\":8,\"313\":3,\"315\":3}}],[\"map\",{\"1\":{\"62\":4,\"490\":1}}],[\"map<integer\",{\"1\":{\"62\":1,\"334\":1,\"491\":3}}],[\"main\",{\"1\":{\"17\":1,\"33\":1,\"43\":1,\"48\":1}}],[\"maxhash\",{\"1\":{\"491\":2}}],[\"maxdigit\",{\"1\":{\"458\":2}}],[\"maxdepth\",{\"1\":{\"81\":3,\"83\":1}}],[\"maxvalue\",{\"1\":{\"456\":4,\"457\":4,\"458\":6}}],[\"maxcount\",{\"1\":{\"340\":1,\"342\":6}}],[\"maximum\",{\"1\":{\"76\":1,\"494\":3}}],[\"max\",{\"1\":{\"0\":1,\"79\":1,\"80\":1,\"81\":2,\"104\":1,\"232\":2,\"351\":1,\"353\":5,\"359\":1,\"361\":1,\"362\":1,\"437\":5,\"484\":2,\"485\":1,\"491\":3}}],[\"master\",{\"1\":{\"0\":2}}],[\"操作系统的内存栈必然就会溢出\",{\"1\":{\"542\":1}}],[\"操作的场景中\",{\"1\":{\"541\":1}}],[\"操作的情况\",{\"1\":{\"256\":1}}],[\"操作只发生在结构的一端\",{\"1\":{\"511\":1}}],[\"操作时间复杂度\",{\"0\":{\"476\":1}}],[\"操作都是\",{\"1\":{\"256\":1}}],[\"操作\",{\"1\":{\"253\":1,\"485\":1}}],[\"操作是合法的\",{\"1\":{\"253\":1}}],[\"操作为\",{\"1\":{\"239\":4}}],[\"操作视为寻找下一个数\",{\"1\":{\"199\":1}}],[\"操作放到工厂方法中\",{\"1\":{\"36\":1}}],[\"操作实例化对象\",{\"1\":{\"20\":1}}],[\"概念及演示\",{\"0\":{\"445\":1,\"448\":1}}],[\"概念\",{\"0\":{\"36\":1,\"52\":1,\"517\":1}}],[\"克隆方法\",{\"1\":{\"33\":1}}],[\"该列表可以包含多达\",{\"1\":{\"527\":1}}],[\"该结构将键通过哈希计算映射到值\",{\"1\":{\"490\":1}}],[\"该节点将\",{\"1\":{\"412\":1}}],[\"该接口让你能够克隆对象\",{\"1\":{\"32\":1}}],[\"该方法将返回单例类的实例变量\",{\"1\":{\"20\":1}}],[\"声明通用的构建步骤\",{\"1\":{\"47\":1}}],[\"声明一个工厂方法\",{\"1\":{\"36\":1}}],[\"声明一个类的\",{\"1\":{\"20\":1}}],[\"声明克隆方法\",{\"1\":{\"32\":1}}],[\"声明了一个通用接口\",{\"1\":{\"32\":1}}],[\"效率低\",{\"1\":{\"31\":1}}],[\"时就是相交节点\",{\"1\":{\"581\":1}}],[\"时间\",{\"1\":{\"526\":1,\"531\":1}}],[\"时间复杂度是多少\",{\"1\":{\"569\":1}}],[\"时间复杂度保持在\",{\"1\":{\"541\":1}}],[\"时间复杂度直接索引到指定元素\",{\"1\":{\"490\":1}}],[\"时间复杂度的解法\",{\"1\":{\"228\":2}}],[\"时间复杂度为\",{\"1\":{\"139\":1,\"526\":1,\"527\":1,\"531\":1}}],[\"时间复杂度\",{\"1\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"239\":1,\"246\":1,\"248\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"371\":1,\"380\":1,\"386\":1,\"396\":1,\"405\":1,\"416\":1,\"419\":1,\"428\":1,\"436\":1,\"443\":1,\"583\":1}}],[\"时赶紧扩容\",{\"1\":{\"495\":1}}],[\"时返回\",{\"1\":{\"261\":1}}],[\"时叫做叶子节点\",{\"1\":{\"102\":1}}],[\"时说明\",{\"1\":{\"93\":1}}],[\"时\",{\"1\":{\"27\":1,\"141\":2,\"255\":1,\"261\":1,\"285\":1,\"294\":2,\"378\":1,\"406\":1,\"418\":1,\"485\":2,\"505\":1,\"574\":1,\"581\":2}}],[\"✨堆排序\",{\"0\":{\"455\":1}}],[\"✨快速排序\",{\"0\":{\"454\":1}}],[\"✨归并排序\",{\"0\":{\"453\":1}}],[\"✨希尔排序\",{\"0\":{\"452\":1}}],[\"✨私有内部类\",{\"0\":{\"27\":1}}],[\"✨双重锁\",{\"0\":{\"26\":1}}],[\"✨饿汉实例化\",{\"0\":{\"22\":1}}],[\"同理只要两棵树的右节点都不为\",{\"1\":{\"387\":1}}],[\"同理参照左子树\",{\"1\":{\"123\":1}}],[\"同层的节点不会连续被处理\",{\"1\":{\"325\":1}}],[\"同样的题目还有\",{\"1\":{\"314\":1}}],[\"同样的道理\",{\"1\":{\"60\":1}}],[\"同一个父节点下的串联\",{\"1\":{\"113\":1}}],[\"同一个父节点的两个子节点\",{\"1\":{\"111\":1}}],[\"同一层节点由\",{\"1\":{\"109\":1}}],[\"同时指向\",{\"1\":{\"581\":1}}],[\"同时指向第一个相交节点\",{\"1\":{\"581\":1}}],[\"同时更新限制条件\",{\"1\":{\"437\":1}}],[\"同时设置一个下标\",{\"1\":{\"285\":1}}],[\"同时为空\",{\"1\":{\"261\":1}}],[\"同时往中间移动的时候处理相同元素的情况\",{\"1\":{\"139\":1}}],[\"同时还满足\",{\"1\":{\"137\":1}}],[\"同时存储\",{\"1\":{\"83\":1}}],[\"同时又无需将代码和对象所属类耦合\",{\"1\":{\"32\":1}}],[\"同步方法会造成性能降低\",{\"1\":{\"25\":1}}],[\"同班的\",{\"1\":{\"15\":1}}],[\"方法输出\",{\"1\":{\"245\":1}}],[\"方法\",{\"1\":{\"25\":1}}],[\"关键点\",{\"0\":{\"61\":1,\"69\":1,\"80\":1,\"91\":1,\"94\":1,\"103\":1,\"112\":1,\"120\":1,\"131\":1,\"140\":1,\"161\":1,\"170\":1,\"179\":1,\"190\":1,\"199\":1,\"207\":1,\"210\":1,\"219\":1,\"222\":1,\"231\":1,\"245\":1,\"262\":1,\"269\":1,\"277\":1,\"286\":1,\"295\":1,\"305\":1,\"314\":1,\"323\":1,\"341\":1,\"350\":1,\"360\":1,\"370\":1,\"379\":1,\"395\":1,\"404\":1,\"415\":1,\"418\":1,\"427\":1,\"435\":1,\"582\":1},\"1\":{\"82\":1}}],[\"关键字\",{\"0\":{\"25\":1}}],[\"关于本站\",{\"0\":{\"0\":1}}],[\"缺点是\",{\"1\":{\"24\":1}}],[\"缺点是不使用该类时\",{\"1\":{\"22\":1}}],[\"懒汉实例化\",{\"0\":{\"24\":1}}],[\"equals\",{\"1\":{\"567\":1}}],[\"edge\",{\"1\":{\"517\":1}}],[\"e>\",{\"1\":{\"479\":1,\"482\":1}}],[\"empty\",{\"1\":{\"236\":6,\"239\":2,\"253\":6,\"256\":3,\"478\":4,\"480\":2,\"481\":2,\"482\":2,\"484\":2,\"537\":3}}],[\"elementdata\",{\"1\":{\"478\":6,\"480\":6,\"481\":5,\"482\":5,\"483\":2,\"484\":13,\"485\":6}}],[\"element\",{\"1\":{\"282\":1,\"566\":2,\"574\":2}}],[\"elements\",{\"1\":{\"204\":1}}],[\"else\",{\"1\":{\"92\":1,\"95\":1,\"141\":2,\"153\":1,\"162\":2,\"191\":3,\"208\":1,\"211\":1,\"263\":3,\"342\":2,\"351\":1,\"362\":1,\"388\":2,\"396\":2,\"405\":2,\"406\":1,\"407\":2,\"416\":2,\"419\":2,\"428\":2,\"453\":1,\"457\":1,\"480\":2,\"482\":2,\"503\":2,\"504\":2,\"505\":2,\"534\":1,\"537\":3,\"543\":1,\"564\":1,\"565\":1,\"566\":2,\"567\":1}}],[\"each\",{\"1\":{\"108\":1,\"117\":1,\"346\":1}}],[\"eagerinitializedsingleton\",{\"1\":{\"22\":5}}],[\"expectednums\",{\"1\":{\"283\":3}}],[\"example\",{\"1\":{\"146\":2}}],[\"extends\",{\"1\":{\"43\":5,\"48\":2,\"479\":1,\"482\":1}}],[\"exception\",{\"1\":{\"23\":1}}],[\"e\",{\"1\":{\"23\":1,\"33\":2,\"292\":2,\"484\":3,\"485\":2,\"564\":3,\"565\":3,\"566\":2}}],[\"ensureexplicitcapacity\",{\"1\":{\"484\":3,\"485\":2}}],[\"ensurecapacityinternal\",{\"1\":{\"484\":5,\"485\":1}}],[\"ended\",{\"1\":{\"574\":1}}],[\"end++\",{\"1\":{\"232\":1}}],[\"end−start+1\",{\"1\":{\"230\":1}}],[\"end\",{\"1\":{\"153\":5,\"166\":1,\"230\":1,\"232\":6,\"503\":1}}],[\"enumsingleton\",{\"1\":{\"28\":1}}],[\"enum\",{\"1\":{\"28\":1}}],[\"env\",{\"1\":{\"0\":1}}],[\"environment\",{\"1\":{\"0\":1}}],[\"enable\",{\"1\":{\"0\":1}}],[\"控制对共享资源的并发访问\",{\"1\":{\"21\":1}}],[\"适用场景\",{\"0\":{\"21\":1}}],[\"实际上是调用\",{\"1\":{\"484\":1}}],[\"实际就是一个默认初始容量的空数组实例\",{\"1\":{\"481\":1}}],[\"实例在类加载时创建\",{\"1\":{\"22\":1}}],[\"实例\",{\"1\":{\"20\":1}}],[\"实现的\",{\"1\":{\"574\":1}}],[\"实现高效的元素查询\",{\"1\":{\"461\":1}}],[\"实现双向链表\",{\"1\":{\"417\":1}}],[\"实现克隆方法\",{\"1\":{\"32\":1}}],[\"实现克隆操作\",{\"1\":{\"31\":1}}],[\"实现\",{\"0\":{\"17\":1,\"33\":1,\"38\":1,\"43\":1,\"48\":1,\"54\":1},\"1\":{\"82\":1,\"236\":1,\"253\":1,\"412\":1}}],[\"实现了操作逻辑\",{\"1\":{\"16\":1}}],[\"静态代码块实例化\",{\"0\":{\"23\":1}}],[\"静态\",{\"1\":{\"20\":1}}],[\"私有静态内部类\",{\"1\":{\"27\":1}}],[\"私有\",{\"1\":{\"20\":1}}],[\"创建新节点\",{\"1\":{\"564\":1}}],[\"创建一个新树\",{\"1\":{\"386\":1}}],[\"创建一个虚拟头结点\",{\"1\":{\"211\":1}}],[\"创建一个双端队列存放右括号\",{\"1\":{\"191\":1}}],[\"创建一个队列存放每一层的节点\",{\"1\":{\"119\":1}}],[\"创建一个哈希表\",{\"1\":{\"60\":1}}],[\"创建者的不同实现\",{\"1\":{\"36\":1}}],[\"创建者\",{\"1\":{\"36\":1}}],[\"创建对象\",{\"1\":{\"36\":1}}],[\"创建私有构造函数以避免使用\",{\"1\":{\"20\":1}}],[\"创建型模式\",{\"0\":{\"9\":1}}],[\"特征\",{\"0\":{\"20\":1}}],[\"显示图片\",{\"1\":{\"17\":1}}],[\"+s\",{\"1\":{\"491\":2}}],[\"+=\",{\"1\":{\"200\":1,\"232\":1,\"334\":1,\"388\":1,\"491\":1}}],[\"+z\",{\"1\":{\"130\":1}}],[\"++\",{\"1\":{\"278\":1,\"306\":2,\"315\":1,\"456\":1}}],[\"++end\",{\"1\":{\"153\":2}}],[\"++left\",{\"1\":{\"153\":2}}],[\"++tt\",{\"1\":{\"95\":1}}],[\"++i\",{\"1\":{\"62\":1,\"141\":2}}],[\"+1\",{\"1\":{\"81\":1,\"82\":1,\"276\":1,\"405\":1,\"486\":1}}],[\"+\",{\"1\":{\"17\":2,\"33\":2,\"58\":1,\"79\":1,\"80\":1,\"81\":1,\"95\":1,\"104\":1,\"137\":14,\"139\":2,\"141\":3,\"151\":3,\"153\":1,\"158\":3,\"162\":24,\"182\":2,\"196\":5,\"200\":3,\"232\":2,\"326\":1,\"331\":15,\"333\":1,\"334\":3,\"351\":2,\"369\":2,\"371\":2,\"405\":1,\"406\":1,\"407\":2,\"446\":4,\"449\":1,\"451\":2,\"452\":2,\"453\":4,\"454\":4,\"455\":2,\"456\":1,\"457\":2,\"458\":3,\"480\":1,\"484\":2,\"485\":2,\"491\":4,\"494\":1,\"503\":4,\"504\":2,\"505\":5,\"527\":2,\"574\":4,\"579\":2}}],[\"=baseaddr+i∗datatypesize\",{\"1\":{\"475\":1}}],[\"=1\",{\"1\":{\"340\":1}}],[\"=num\",{\"1\":{\"285\":1}}],[\"=null\",{\"1\":{\"113\":2,\"206\":1,\"211\":1,\"388\":4,\"537\":6}}],[\"=val\",{\"1\":{\"206\":1}}],[\"=o\",{\"1\":{\"162\":1,\"200\":1}}],[\"=>\",{\"1\":{\"111\":1,\"112\":1,\"130\":1,\"503\":1}}],[\"===\",{\"1\":{\"543\":3}}],[\"==target\",{\"1\":{\"403\":1,\"406\":1}}],[\"==p\",{\"1\":{\"263\":1}}],[\"==null\",{\"1\":{\"246\":1}}],[\"==\",{\"1\":{\"17\":1,\"24\":1,\"25\":1,\"26\":2,\"58\":1,\"70\":5,\"72\":4,\"81\":1,\"83\":1,\"92\":2,\"93\":1,\"95\":3,\"104\":3,\"113\":1,\"121\":1,\"123\":1,\"132\":5,\"137\":1,\"139\":2,\"141\":7,\"151\":1,\"153\":2,\"158\":1,\"162\":5,\"171\":2,\"180\":2,\"182\":2,\"191\":4,\"200\":2,\"205\":1,\"208\":3,\"223\":2,\"232\":2,\"248\":1,\"263\":4,\"270\":2,\"283\":2,\"294\":1,\"326\":2,\"331\":5,\"342\":5,\"351\":3,\"353\":1,\"361\":1,\"362\":1,\"386\":2,\"406\":1,\"407\":1,\"416\":4,\"419\":4,\"428\":2,\"436\":1,\"437\":1,\"446\":2,\"449\":2,\"451\":1,\"457\":1,\"458\":1,\"478\":1,\"480\":1,\"482\":1,\"484\":1,\"491\":1,\"493\":1,\"503\":6,\"504\":8,\"505\":3,\"526\":1,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"535\":1,\"543\":4,\"564\":1,\"565\":1,\"566\":2,\"567\":2,\"579\":2,\"581\":1,\"583\":4}}],[\"=\",{\"1\":{\"17\":4,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"33\":3,\"43\":3,\"48\":2,\"58\":6,\"62\":4,\"67\":2,\"69\":3,\"70\":5,\"72\":4,\"77\":2,\"79\":1,\"80\":1,\"81\":1,\"83\":6,\"92\":3,\"95\":4,\"100\":2,\"104\":5,\"109\":2,\"111\":1,\"113\":12,\"118\":2,\"120\":3,\"121\":15,\"123\":13,\"128\":6,\"130\":2,\"132\":10,\"137\":12,\"139\":1,\"141\":8,\"146\":3,\"149\":2,\"151\":6,\"153\":13,\"158\":4,\"162\":9,\"167\":6,\"171\":12,\"180\":7,\"182\":1,\"187\":3,\"191\":2,\"196\":6,\"200\":11,\"205\":6,\"208\":9,\"211\":3,\"216\":3,\"220\":12,\"223\":3,\"228\":6,\"232\":8,\"236\":1,\"239\":2,\"244\":3,\"246\":7,\"248\":11,\"253\":1,\"256\":6,\"261\":12,\"263\":7,\"266\":3,\"268\":4,\"270\":14,\"274\":4,\"278\":5,\"283\":13,\"287\":3,\"292\":2,\"296\":5,\"301\":4,\"306\":7,\"311\":6,\"315\":1,\"320\":2,\"324\":6,\"326\":2,\"331\":12,\"334\":2,\"339\":2,\"340\":1,\"342\":17,\"347\":2,\"351\":3,\"353\":9,\"358\":2,\"361\":9,\"362\":11,\"367\":4,\"369\":2,\"371\":9,\"376\":2,\"378\":1,\"380\":15,\"384\":4,\"386\":7,\"388\":5,\"393\":4,\"396\":7,\"401\":4,\"405\":5,\"406\":5,\"407\":5,\"412\":1,\"416\":27,\"419\":32,\"424\":2,\"427\":1,\"428\":8,\"433\":2,\"436\":6,\"443\":2,\"446\":8,\"449\":8,\"450\":1,\"451\":5,\"452\":9,\"453\":12,\"454\":10,\"455\":12,\"456\":7,\"457\":13,\"458\":21,\"462\":1,\"478\":3,\"480\":3,\"481\":1,\"482\":6,\"484\":8,\"485\":7,\"486\":14,\"491\":23,\"493\":5,\"494\":4,\"495\":1,\"503\":9,\"504\":11,\"505\":11,\"517\":1,\"525\":5,\"526\":8,\"527\":1,\"533\":5,\"534\":8,\"535\":5,\"537\":18,\"543\":16,\"562\":1,\"564\":5,\"565\":5,\"566\":10,\"567\":6,\"574\":13,\"579\":15,\"581\":1,\"583\":7}}],[\"t2==null\",{\"1\":{\"388\":1}}],[\"t2\",{\"1\":{\"388\":4}}],[\"t1==null\",{\"1\":{\"388\":2}}],[\"t1\",{\"1\":{\"388\":5}}],[\"tail\",{\"1\":{\"417\":1,\"419\":9}}],[\"tablesizefor\",{\"1\":{\"494\":3}}],[\"table\",{\"1\":{\"278\":4,\"490\":1}}],[\"target\",{\"1\":{\"58\":6,\"60\":3,\"61\":1,\"62\":3,\"158\":5,\"162\":8,\"228\":5,\"232\":2,\"380\":2,\"394\":1,\"401\":4,\"405\":3,\"406\":3,\"407\":3,\"503\":6,\"504\":14,\"505\":8}}],[\"t\",{\"1\":{\"261\":1,\"274\":8,\"276\":3,\"278\":3,\"324\":3}}],[\"temp\",{\"1\":{\"113\":9,\"246\":2,\"248\":2,\"296\":2,\"446\":2,\"449\":2,\"452\":4,\"453\":6,\"454\":4,\"455\":2,\"458\":3}}],[\"test\",{\"1\":{\"17\":1}}],[\"tt\",{\"1\":{\"93\":3,\"95\":6}}],[\"tolist\",{\"1\":{\"486\":1}}],[\"toarray\",{\"1\":{\"482\":1,\"486\":4}}],[\"to\",{\"1\":{\"236\":1,\"253\":1,\"478\":1,\"484\":1,\"485\":1}}],[\"top++\",{\"1\":{\"380\":1}}],[\"top==bottom\",{\"1\":{\"378\":1}}],[\"top\",{\"1\":{\"236\":6,\"239\":2,\"253\":2,\"378\":1,\"380\":6}}],[\"totalsum\",{\"1\":{\"200\":3}}],[\"tostring\",{\"1\":{\"92\":1,\"151\":1,\"153\":1}}],[\"tochararray\",{\"1\":{\"92\":1,\"95\":1,\"191\":1,\"315\":2,\"371\":1}}],[\"tmp\",{\"1\":{\"83\":5,\"153\":2}}],[\"twosum\",{\"1\":{\"62\":1}}],[\"two\",{\"1\":{\"57\":1,\"300\":1,\"383\":1,\"578\":1}}],[\"type\",{\"1\":{\"54\":2}}],[\"throw\",{\"1\":{\"480\":1,\"574\":1}}],[\"threshold\",{\"1\":{\"494\":2}}],[\"threesum\",{\"1\":{\"141\":1}}],[\"threadsafesingleton\",{\"1\":{\"25\":5,\"26\":6}}],[\"the\",{\"1\":{\"146\":2,\"253\":1,\"574\":1}}],[\"this\",{\"1\":{\"17\":2,\"33\":1,\"48\":1,\"70\":4,\"171\":3,\"208\":3,\"211\":3,\"220\":3,\"246\":4,\"248\":4,\"270\":3,\"342\":4,\"361\":4,\"386\":4,\"396\":4,\"416\":1,\"436\":4,\"480\":2,\"481\":1,\"484\":3,\"485\":1,\"494\":2}}],[\"transient\",{\"1\":{\"478\":1}}],[\"traverse\",{\"1\":{\"342\":4,\"359\":1,\"361\":4,\"543\":4}}],[\"traversal\",{\"1\":{\"319\":1,\"524\":1,\"528\":1}}],[\"trimspaces\",{\"1\":{\"152\":1,\"153\":2}}],[\"trim\",{\"1\":{\"149\":1,\"151\":2}}],[\"trees\",{\"1\":{\"383\":1}}],[\"treenode\",{\"1\":{\"70\":11,\"72\":3,\"81\":1,\"83\":2,\"104\":1,\"180\":2,\"182\":2,\"246\":11,\"248\":13,\"263\":10,\"342\":11,\"351\":2,\"353\":2,\"359\":1,\"361\":11,\"362\":3,\"385\":3,\"386\":13,\"388\":5,\"394\":2,\"396\":10,\"436\":9,\"437\":2,\"517\":4,\"525\":2,\"526\":2,\"527\":2,\"529\":1,\"530\":1,\"531\":1,\"533\":2,\"534\":2,\"535\":2,\"537\":6,\"543\":1}}],[\"tree\",{\"1\":{\"66\":1,\"70\":1,\"76\":1,\"99\":1,\"175\":1,\"243\":1,\"246\":1,\"248\":1,\"260\":1,\"263\":1,\"319\":1,\"338\":1,\"342\":1,\"346\":1,\"361\":1,\"386\":1,\"392\":1,\"396\":1,\"432\":1,\"436\":1,\"519\":2,\"520\":2,\"521\":2,\"522\":2,\"539\":2,\"540\":4}}],[\"try\",{\"1\":{\"23\":2,\"33\":1}}],[\"true\",{\"1\":{\"0\":1,\"67\":1,\"68\":1,\"70\":1,\"72\":1,\"132\":1,\"187\":2,\"191\":1,\"196\":2,\"200\":1,\"236\":1,\"253\":1,\"274\":1,\"278\":1,\"311\":2,\"315\":1,\"433\":1,\"434\":1,\"436\":1,\"437\":1,\"446\":1,\"484\":1,\"486\":1,\"567\":2}}],[\"item\",{\"1\":{\"566\":2,\"567\":2}}],[\"i<<5\",{\"1\":{\"491\":1}}],[\"i<levelsize\",{\"1\":{\"353\":1}}],[\"illegalstateexception\",{\"1\":{\"574\":1}}],[\"illegal\",{\"1\":{\"480\":1}}],[\"illegalargumentexception\",{\"1\":{\"480\":1}}],[\"i−1\",{\"1\":{\"475\":1}}],[\"i用来记录比基准值小的区域的最后一个元素的索引\",{\"1\":{\"454\":1}}],[\"i代表行\",{\"1\":{\"380\":1}}],[\"i++\",{\"1\":{\"121\":1,\"171\":1,\"180\":1,\"278\":2,\"283\":1,\"306\":1,\"342\":1,\"353\":1,\"380\":1,\"416\":1,\"446\":1,\"449\":1,\"451\":1,\"452\":1,\"453\":3,\"454\":1,\"457\":1,\"458\":1,\"491\":2,\"526\":1}}],[\"ii\",{\"0\":{\"116\":1,\"117\":1,\"126\":1,\"127\":1,\"329\":1,\"330\":1,\"365\":1,\"366\":1,\"374\":1,\"375\":1},\"1\":{\"117\":1,\"127\":1,\"330\":1,\"366\":1,\"375\":1,\"553\":1}}],[\"isleft\",{\"1\":{\"419\":4}}],[\"isanagram\",{\"1\":{\"278\":1}}],[\"ishappy\",{\"1\":{\"200\":1}}],[\"isvalidbstutil\",{\"1\":{\"437\":4}}],[\"isvalidbst\",{\"1\":{\"436\":3,\"437\":1}}],[\"isvalid\",{\"1\":{\"191\":1}}],[\"is\",{\"1\":{\"146\":2,\"236\":1,\"253\":5,\"484\":2,\"485\":2,\"574\":1}}],[\"isempty\",{\"1\":{\"72\":1,\"83\":1,\"92\":2,\"121\":1,\"180\":1,\"191\":3,\"239\":1,\"248\":1,\"256\":5,\"324\":1,\"353\":1,\"362\":1,\"525\":1,\"526\":1,\"533\":1,\"534\":1,\"535\":1,\"574\":1}}],[\"issymmetric\",{\"1\":{\"70\":1,\"72\":1}}],[\"i\",{\"1\":{\"58\":1,\"62\":7,\"121\":2,\"137\":5,\"139\":8,\"141\":10,\"150\":1,\"151\":10,\"158\":1,\"171\":2,\"180\":3,\"228\":1,\"278\":7,\"283\":5,\"292\":1,\"295\":2,\"301\":2,\"306\":11,\"331\":7,\"342\":4,\"353\":1,\"380\":7,\"416\":2,\"424\":1,\"446\":3,\"449\":8,\"450\":2,\"451\":4,\"452\":4,\"453\":7,\"454\":7,\"455\":15,\"457\":4,\"458\":2,\"475\":2,\"491\":10,\"526\":2}}],[\"ifactory\",{\"1\":{\"38\":3}}],[\"if\",{\"1\":{\"17\":1,\"24\":2,\"25\":1,\"26\":3,\"62\":1,\"70\":2,\"72\":2,\"81\":1,\"83\":3,\"92\":2,\"95\":2,\"104\":4,\"113\":2,\"120\":1,\"121\":4,\"123\":3,\"132\":3,\"141\":6,\"153\":2,\"162\":8,\"171\":1,\"180\":4,\"182\":2,\"191\":6,\"200\":1,\"208\":2,\"211\":1,\"223\":1,\"232\":1,\"246\":1,\"248\":3,\"256\":2,\"263\":5,\"270\":1,\"278\":2,\"287\":1,\"306\":1,\"315\":2,\"324\":1,\"326\":2,\"334\":1,\"342\":7,\"351\":5,\"353\":3,\"361\":2,\"362\":3,\"386\":2,\"388\":5,\"396\":2,\"405\":2,\"406\":2,\"407\":2,\"416\":6,\"419\":6,\"428\":3,\"436\":3,\"437\":2,\"446\":3,\"449\":2,\"451\":1,\"453\":2,\"454\":2,\"455\":3,\"456\":1,\"457\":4,\"458\":2,\"471\":1,\"480\":2,\"482\":2,\"484\":4,\"485\":3,\"491\":1,\"503\":3,\"504\":6,\"505\":4,\"525\":2,\"526\":3,\"527\":2,\"529\":1,\"530\":1,\"531\":1,\"533\":3,\"534\":2,\"535\":3,\"537\":12,\"543\":9,\"564\":1,\"565\":1,\"566\":2,\"567\":3,\"574\":3,\"583\":1}}],[\"implement\",{\"1\":{\"235\":1,\"252\":1}}],[\"implements\",{\"1\":{\"17\":2,\"33\":1,\"38\":4,\"54\":3}}],[\"image\",{\"1\":{\"17\":8}}],[\"inorderiteratorresult\",{\"1\":{\"543\":4}}],[\"inorderresult\",{\"1\":{\"543\":2}}],[\"inordertraversal\",{\"1\":{\"534\":1,\"537\":1,\"543\":2}}],[\"inorder\",{\"1\":{\"530\":3}}],[\"increments\",{\"1\":{\"484\":1}}],[\"initialcapacity\",{\"1\":{\"479\":1,\"480\":6,\"494\":2}}],[\"insert\",{\"1\":{\"574\":1}}],[\"insertsort\",{\"1\":{\"457\":2}}],[\"insertionsort\",{\"1\":{\"451\":1}}],[\"instantiated\",{\"1\":{\"256\":1,\"416\":1}}],[\"instance\",{\"1\":{\"22\":2,\"23\":3,\"24\":4,\"25\":4,\"26\":5,\"27\":2,\"28\":1}}],[\"install\",{\"1\":{\"0\":1}}],[\"indexprenode\",{\"1\":{\"416\":3}}],[\"indexnode\",{\"1\":{\"416\":3}}],[\"index++\",{\"1\":{\"306\":1}}],[\"index\",{\"1\":{\"306\":1,\"412\":9,\"416\":17,\"418\":2,\"419\":16,\"428\":5,\"457\":3,\"462\":1,\"551\":3}}],[\"in2out\",{\"1\":{\"256\":3}}],[\"inverttree\",{\"1\":{\"246\":3,\"248\":1}}],[\"invert\",{\"1\":{\"243\":1}}],[\"in\",{\"1\":{\"87\":1,\"108\":1,\"117\":1,\"145\":1,\"255\":1,\"256\":6,\"265\":1,\"338\":1,\"346\":1,\"357\":1,\"392\":1}}],[\"intersected\",{\"1\":{\"579\":2}}],[\"intersectval\",{\"1\":{\"579\":6}}],[\"intersection\",{\"1\":{\"300\":1,\"306\":1,\"578\":1}}],[\"interface\",{\"1\":{\"17\":1,\"33\":1,\"38\":1,\"54\":1}}],[\"integer\",{\"1\":{\"104\":1,\"232\":2,\"353\":1,\"361\":1,\"362\":1,\"491\":10}}],[\"integer>\",{\"1\":{\"62\":1,\"334\":2,\"491\":3}}],[\"int\",{\"1\":{\"54\":1,\"62\":8,\"70\":3,\"81\":1,\"83\":2,\"95\":1,\"104\":2,\"109\":1,\"113\":3,\"118\":1,\"121\":5,\"132\":2,\"141\":4,\"151\":1,\"153\":5,\"162\":8,\"171\":5,\"180\":2,\"182\":1,\"200\":7,\"208\":4,\"211\":4,\"220\":3,\"232\":7,\"236\":3,\"239\":3,\"246\":3,\"248\":3,\"253\":3,\"256\":5,\"263\":2,\"270\":3,\"278\":4,\"283\":5,\"287\":5,\"296\":2,\"306\":14,\"315\":2,\"324\":1,\"326\":1,\"334\":10,\"342\":9,\"351\":1,\"353\":3,\"361\":5,\"362\":2,\"371\":6,\"380\":10,\"386\":3,\"394\":1,\"396\":4,\"405\":6,\"406\":6,\"407\":6,\"412\":7,\"416\":13,\"419\":11,\"428\":7,\"436\":3,\"446\":5,\"449\":6,\"451\":4,\"452\":5,\"453\":13,\"454\":13,\"455\":16,\"456\":11,\"457\":19,\"458\":24,\"478\":2,\"479\":1,\"480\":1,\"484\":7,\"485\":4,\"491\":12,\"493\":2,\"494\":4,\"503\":6,\"504\":6,\"505\":6,\"517\":2,\"526\":2,\"527\":1,\"562\":2,\"574\":9,\"583\":2}}],[\"并删除旧的数组尾元素\",{\"1\":{\"574\":1}}],[\"并删除它们\",{\"1\":{\"88\":1}}],[\"并在每一层按照从左到右的顺序访问节点\",{\"1\":{\"524\":1}}],[\"并追加数据\",{\"1\":{\"457\":1,\"458\":1}}],[\"并假设初始绝对差为integer\",{\"1\":{\"359\":1}}],[\"并判断是否是众数\",{\"1\":{\"340\":2}}],[\"并交换节点的左右子节点\",{\"1\":{\"247\":1}}],[\"并支持普通栈的全部四种操作\",{\"1\":{\"236\":1}}],[\"并将其加入答案中\",{\"1\":{\"352\":1}}],[\"并将元素添加进去\",{\"1\":{\"340\":1}}],[\"并将该元素放进\",{\"1\":{\"340\":1}}],[\"并将当前元素与栈顶元素判断是否相同\",{\"1\":{\"190\":1}}],[\"并将双指针指向新的单词\",{\"1\":{\"150\":1}}],[\"并且其他请求访问的线程必须等待直到计数器非零\",{\"1\":{\"574\":1}}],[\"并且其实树本身是一种递归的数据结构\",{\"1\":{\"523\":1}}],[\"并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型\",{\"1\":{\"542\":1}}],[\"并且要做好更新的\",{\"1\":{\"435\":1}}],[\"并且左右子树都是二叉搜索树\",{\"1\":{\"395\":1}}],[\"并且\",{\"1\":{\"283\":2}}],[\"并且返回链表的头结点\",{\"1\":{\"167\":1}}],[\"并且有时候原对象的某些属性是私有的\",{\"1\":{\"31\":1}}],[\"并返回交换后链表的头节点\",{\"1\":{\"266\":1}}],[\"并返回其根节点\",{\"1\":{\"244\":1}}],[\"并返回其长度\",{\"1\":{\"228\":1}}],[\"并返回反转后的链表\",{\"1\":{\"216\":1}}],[\"并返回\",{\"1\":{\"205\":1}}],[\"并返回它们的数组下标\",{\"1\":{\"58\":1}}],[\"并返回对应类型的产品对象\",{\"1\":{\"36\":1}}],[\"并通过拷贝这些原型创建新的对象\",{\"1\":{\"31\":1}}],[\"并设置新对象的属性\",{\"1\":{\"31\":1}}],[\"并增加额外一个检查\",{\"1\":{\"26\":1}}],[\"并提供一个与\",{\"1\":{\"16\":1}}],[\"并不是一个东西\",{\"1\":{\"4\":1}}],[\"和array\",{\"1\":{\"454\":1}}],[\"和二分查找的思想很像\",{\"1\":{\"454\":1}}],[\"和目标值\",{\"1\":{\"394\":1}}],[\"和右子节点\",{\"1\":{\"261\":1}}],[\"和节点\",{\"1\":{\"261\":2}}],[\"和一个\",{\"1\":{\"417\":1}}],[\"和一个值\",{\"1\":{\"283\":1}}],[\"和一个整数值\",{\"1\":{\"393\":1}}],[\"和一个整数\",{\"1\":{\"205\":1,\"367\":1}}],[\"和一个整数目标值\",{\"1\":{\"58\":1}}],[\"和一个目标值\",{\"1\":{\"158\":1,\"401\":1}}],[\"和为目标值\",{\"1\":{\"58\":1}}],[\"和\",{\"1\":{\"16\":1,\"61\":1,\"68\":2,\"71\":2,\"123\":1,\"130\":2,\"132\":1,\"137\":1,\"139\":1,\"153\":1,\"158\":1,\"169\":1,\"198\":1,\"230\":1,\"236\":4,\"253\":2,\"256\":2,\"261\":7,\"268\":2,\"274\":4,\"294\":1,\"301\":1,\"311\":2,\"322\":1,\"331\":1,\"333\":1,\"334\":1,\"369\":2,\"371\":2,\"384\":1,\"388\":2,\"406\":1,\"412\":2,\"416\":1,\"417\":1,\"419\":1,\"426\":1,\"445\":1,\"446\":1,\"480\":1,\"490\":1,\"511\":1,\"517\":2,\"523\":1,\"550\":1,\"574\":1,\"579\":4,\"583\":1}}],[\"送礼物功能\",{\"1\":{\"15\":1}}],[\"送礼物\",{\"1\":{\"15\":1}}],[\"所谓的翻转就是将二叉树上的每个节点的\",{\"1\":{\"244\":1}}],[\"所谓的一系列相关的对象指的是你为了完成某个指令\",{\"1\":{\"41\":1}}],[\"所示\",{\"1\":{\"109\":2,\"118\":2}}],[\"所有节点被访问一次\",{\"1\":{\"526\":1,\"531\":1}}],[\"所有左子树和右子树自身必须也是二叉搜索树\",{\"1\":{\"433\":1}}],[\"所有函数单次调用的空间复杂度均为\",{\"1\":{\"419\":1}}],[\"所有函数的单次调用空间复杂度均为\",{\"1\":{\"416\":1}}],[\"所有元素\",{\"1\":{\"376\":1}}],[\"所有和sumab的情况\",{\"1\":{\"333\":1}}],[\"所有满足条件的公共祖先中一定是深度最大的祖先先被访问到\",{\"1\":{\"262\":1}}],[\"所有\",{\"1\":{\"109\":1,\"118\":1,\"261\":1}}],[\"所有可克隆的类都将实现这个接口\",{\"1\":{\"33\":1}}],[\"所以要进行\",{\"1\":{\"505\":1}}],[\"所以才有\",{\"1\":{\"503\":2}}],[\"所以才有使用同样的构建过程可以创建出不同的表示\",{\"1\":{\"46\":1}}],[\"所以上面的代码是\",{\"1\":{\"493\":1}}],[\"所以最终会进入\",{\"1\":{\"484\":1}}],[\"所以最后的字符串为\",{\"1\":{\"88\":1}}],[\"所以这里需要额外的空间且该空间取决于递归的深度\",{\"1\":{\"436\":1}}],[\"所以这里的空间代价为\",{\"1\":{\"180\":1}}],[\"所以\",{\"1\":{\"403\":1,\"481\":1,\"579\":1}}],[\"所以不能通过\",{\"1\":{\"245\":1}}],[\"所以也是\",{\"1\":{\"200\":1}}],[\"所以队列长度最大不不超过\",{\"1\":{\"180\":1}}],[\"所以和肯定\",{\"1\":{\"139\":1}}],[\"所以他们三个人之间的关系是追求者\",{\"1\":{\"15\":1}}],[\"所返给你的一些反作用力\",{\"1\":{\"4\":1}}],[\"被追求者\",{\"1\":{\"15\":2}}],[\"追求者\",{\"1\":{\"15\":1}}],[\"委托\",{\"1\":{\"15\":2}}],[\"买了很多礼物\",{\"1\":{\"15\":1}}],[\"帮助他\",{\"1\":{\"15\":1}}],[\"与值\",{\"1\":{\"461\":1}}],[\"与\",{\"1\":{\"15\":2,\"295\":1}}],[\"拜托\",{\"1\":{\"15\":1}}],[\"女孩\",{\"1\":{\"15\":9}}],[\"喜欢\",{\"1\":{\"15\":1}}],[\"男孩\",{\"1\":{\"15\":15}}],[\"a+b\",{\"1\":{\"583\":3}}],[\"a+\",{\"1\":{\"581\":1}}],[\"a++\",{\"1\":{\"162\":1}}],[\"at\",{\"1\":{\"579\":2}}],[\"avl\",{\"1\":{\"541\":2}}],[\"avl树\",{\"0\":{\"541\":1}}],[\"access\",{\"1\":{\"478\":1}}],[\"actuallength\",{\"1\":{\"283\":1}}],[\"action\",{\"1\":{\"0\":2}}],[\"actions\",{\"1\":{\"0\":2}}],[\"algo\",{\"1\":{\"462\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2,\"543\":1}}],[\"allroot\",{\"1\":{\"543\":5}}],[\"all\",{\"1\":{\"87\":1}}],[\"ascii\",{\"1\":{\"292\":1}}],[\"assert\",{\"1\":{\"283\":2}}],[\"as\",{\"1\":{\"256\":1,\"416\":1}}],[\"aslist\",{\"1\":{\"141\":1,\"149\":1,\"162\":1,\"486\":3}}],[\"api\",{\"0\":{\"148\":1}}],[\"appendbucket\",{\"1\":{\"457\":2,\"458\":2}}],[\"append\",{\"1\":{\"92\":1,\"151\":1,\"153\":2}}],[\"anagram\",{\"1\":{\"273\":1,\"274\":1}}],[\"ancestor\",{\"1\":{\"260\":1}}],[\"ans++\",{\"1\":{\"287\":1}}],[\"ans\",{\"1\":{\"104\":6,\"162\":3,\"182\":8,\"232\":6,\"285\":4,\"287\":3,\"324\":3,\"326\":6,\"334\":3}}],[\"and\",{\"1\":{\"43\":1,\"256\":1,\"416\":1,\"574\":1}}],[\"arrindex++\",{\"1\":{\"457\":1}}],[\"arrindex\",{\"1\":{\"457\":1}}],[\"arr\",{\"1\":{\"456\":4,\"457\":12,\"458\":6}}],[\"arraydeque\",{\"0\":{\"512\":1},\"1\":{\"511\":1,\"512\":1,\"513\":3,\"574\":1}}],[\"arraydeque<integer>\",{\"1\":{\"256\":2}}],[\"arraydeque<>\",{\"1\":{\"92\":1,\"121\":1,\"180\":1,\"191\":1,\"239\":2,\"248\":1,\"324\":1,\"353\":1,\"362\":1}}],[\"arraylist\",{\"0\":{\"474\":1},\"1\":{\"478\":2,\"479\":3,\"480\":1,\"481\":1,\"482\":3,\"486\":3},\"2\":{\"488\":1}}],[\"arraylist<list<integer>>\",{\"1\":{\"527\":1}}],[\"arraylist<integer>\",{\"1\":{\"141\":1}}],[\"arraylist<>\",{\"1\":{\"141\":1,\"162\":1,\"180\":1,\"182\":1,\"306\":1,\"324\":2,\"326\":2,\"342\":1,\"351\":1,\"353\":1,\"482\":1,\"484\":1,\"486\":4,\"491\":3,\"525\":1,\"526\":2,\"527\":1,\"533\":1,\"534\":1,\"535\":1}}],[\"array\",{\"1\":{\"423\":1,\"446\":12,\"449\":10,\"450\":1,\"451\":9,\"452\":7,\"453\":12,\"454\":15,\"455\":21,\"456\":5,\"457\":8,\"458\":15,\"482\":1,\"484\":1,\"485\":1,\"486\":12,\"539\":1,\"540\":2}}],[\"arrays\",{\"1\":{\"141\":2,\"149\":1,\"162\":2,\"300\":1,\"457\":1,\"458\":1,\"482\":1,\"484\":1,\"485\":1,\"486\":6}}],[\"ary\",{\"1\":{\"319\":1}}],[\"args\",{\"1\":{\"17\":1,\"33\":1,\"43\":1,\"48\":1}}],[\"aab\",{\"1\":{\"311\":1}}],[\"aa\",{\"1\":{\"88\":1,\"311\":2}}],[\"aaca\",{\"1\":{\"88\":1}}],[\"about\",{\"0\":{\"587\":1}}],[\"abcd\",{\"1\":{\"367\":1}}],[\"abcdefg\",{\"1\":{\"367\":1}}],[\"abs\",{\"1\":{\"428\":6}}],[\"absolute\",{\"1\":{\"357\":1}}],[\"abstractfactory\",{\"1\":{\"43\":7}}],[\"abstract\",{\"1\":{\"38\":2,\"41\":1,\"43\":3,\"48\":5}}],[\"ab\",{\"1\":{\"311\":1}}],[\"abbaca\",{\"1\":{\"88\":2}}],[\"adjacent\",{\"1\":{\"87\":1}}],[\"addall\",{\"1\":{\"486\":1}}],[\"addatindex\",{\"1\":{\"412\":4,\"416\":3,\"419\":3}}],[\"addattail\",{\"1\":{\"412\":4,\"416\":5,\"419\":4}}],[\"addathead\",{\"1\":{\"412\":4,\"416\":4,\"419\":4}}],[\"addlast\",{\"1\":{\"121\":1,\"324\":2,\"353\":3}}],[\"add\",{\"1\":{\"83\":3,\"121\":2,\"141\":1,\"162\":1,\"180\":1,\"182\":1,\"306\":1,\"324\":2,\"326\":2,\"342\":4,\"351\":1,\"353\":1,\"388\":6,\"484\":2,\"485\":1,\"486\":9,\"491\":3,\"525\":1,\"526\":2,\"527\":2,\"529\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"574\":1}}],[\"a\",{\"1\":{\"15\":6,\"70\":1,\"109\":1,\"113\":1,\"118\":1,\"121\":1,\"145\":1,\"146\":2,\"158\":4,\"162\":10,\"246\":1,\"248\":1,\"260\":1,\"263\":1,\"278\":2,\"292\":4,\"311\":1,\"315\":3,\"333\":1,\"334\":3,\"342\":1,\"361\":1,\"386\":1,\"392\":1,\"396\":1,\"423\":1,\"436\":1,\"443\":6,\"445\":3,\"475\":1,\"482\":4,\"484\":1,\"485\":1,\"486\":7,\"579\":5,\"581\":4,\"583\":5}}],[\"大顶堆\",{\"1\":{\"455\":1}}],[\"大的元素\",{\"1\":{\"445\":1}}],[\"大于\",{\"1\":{\"433\":1}}],[\"大于等于\",{\"1\":{\"339\":1}}],[\"大\",{\"1\":{\"394\":1,\"445\":1}}],[\"大小的额外空间\",{\"1\":{\"149\":1,\"151\":1}}],[\"大话设计模式\",{\"1\":{\"15\":1}}],[\"大多数情况并非如此\",{\"1\":{\"3\":1}}],[\"真实世界\",{\"0\":{\"15\":1}}],[\"真心觉得那真是一个傻小子\",{\"1\":{\"2\":1}}],[\"另外一个类的功能\",{\"1\":{\"14\":1}}],[\"代码模板\",{\"0\":{\"446\":1,\"449\":1,\"451\":1}}],[\"代码2\",{\"0\":{\"437\":1}}],[\"代码1\",{\"0\":{\"436\":1}}],[\"代码随想录\",{\"1\":{\"218\":1}}],[\"代码\",{\"0\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"239\":1,\"246\":1,\"248\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"371\":1,\"380\":1,\"386\":1,\"388\":1,\"396\":1,\"405\":1,\"416\":1,\"419\":1,\"428\":1,\"583\":1}}],[\"代表当前节点已经访问完毕\",{\"1\":{\"531\":1}}],[\"代表当前节点\",{\"1\":{\"268\":1}}],[\"代表这个重复元素不可能是解\",{\"1\":{\"60\":1}}],[\"代表了追求者\",{\"1\":{\"15\":1}}],[\"代理对象直接调用其display方法\",{\"1\":{\"17\":1}}],[\"代理类\",{\"1\":{\"17\":1}}],[\"代理\",{\"1\":{\"15\":2}}],[\"代理模式\",{\"0\":{\"13\":1},\"1\":{\"14\":1}}],[\"代替\",{\"1\":{\"14\":1}}],[\"是双端队列接口\",{\"1\":{\"573\":1}}],[\"是单端队列接口\",{\"1\":{\"573\":1}}],[\"是不同的\",{\"1\":{\"526\":1}}],[\"是不是快乐数\",{\"1\":{\"196\":1}}],[\"是基于什么实现的\",{\"1\":{\"513\":1}}],[\"是一样的\",{\"1\":{\"526\":1}}],[\"是一个奇质数\",{\"1\":{\"491\":1}}],[\"是一种特殊类型的优先队列\",{\"1\":{\"574\":1}}],[\"是一种特殊类型的抽象数据类型或集合\",{\"1\":{\"573\":1}}],[\"是一种允许在其两端进行插入和删除的线性数据结构\",{\"1\":{\"574\":1}}],[\"是一种实现关联数组的抽象数据结构\",{\"1\":{\"490\":1}}],[\"是一种搜索方法\",{\"1\":{\"469\":1}}],[\"是什么\",{\"0\":{\"469\":1}}],[\"是当前节点的值\",{\"1\":{\"412\":1}}],[\"是可以合并起来的\",{\"1\":{\"406\":1}}],[\"是二叉搜索树\",{\"1\":{\"393\":1}}],[\"是二叉树的高度\",{\"1\":{\"182\":1}}],[\"是为了解决当\",{\"1\":{\"378\":1}}],[\"是众数\",{\"1\":{\"342\":1}}],[\"是和\",{\"1\":{\"333\":1}}],[\"是栈内的元素个数\",{\"1\":{\"239\":1}}],[\"是该条件下的长度最小的子数组\",{\"1\":{\"228\":1}}],[\"是快乐数\",{\"1\":{\"198\":1}}],[\"是由非空格字符组成的字符串\",{\"1\":{\"146\":1}}],[\"是下一行的头\",{\"1\":{\"123\":1}}],[\"是某一行的节点\",{\"1\":{\"123\":1}}],[\"是树的高度\",{\"1\":{\"104\":1}}],[\"是指向下一个节点的指针\",{\"1\":{\"412\":1}}],[\"是指从根节点到最远叶子节点的最长路径上的节点数\",{\"1\":{\"77\":1}}],[\"是指实现了一个类\",{\"1\":{\"14\":1}}],[\"是否是\",{\"1\":{\"274\":1}}],[\"是否对称\",{\"1\":{\"68\":2}}],[\"是否存在于哈希表中\",{\"1\":{\"60\":1}}],[\"是\",{\"1\":{\"61\":1,\"128\":1,\"196\":1,\"261\":4,\"485\":1,\"504\":1,\"505\":1}}],[\"是因为我不足够擅长才痛苦\",{\"1\":{\"4\":1}}],[\"是因为就目前而来\",{\"1\":{\"3\":1}}],[\"意图\",{\"0\":{\"14\":1,\"31\":1,\"41\":1,\"46\":1}}],[\"行为模式\",{\"0\":{\"11\":1}}],[\"工厂方法\",{\"0\":{\"35\":1},\"1\":{\"9\":1},\"2\":{\"39\":1}}],[\"工作上也是如此\",{\"1\":{\"3\":1}}],[\"抽象工厂也是一种工厂\",{\"1\":{\"41\":1}}],[\"抽象工厂\",{\"0\":{\"40\":1},\"1\":{\"9\":1}}],[\"r2\",{\"1\":{\"388\":10}}],[\"r1\",{\"1\":{\"388\":13}}],[\"row\",{\"1\":{\"346\":1}}],[\"root2\",{\"1\":{\"384\":3,\"385\":1,\"386\":5}}],[\"root1\",{\"1\":{\"384\":3,\"385\":1,\"386\":6}}],[\"root\",{\"1\":{\"67\":3,\"70\":4,\"72\":3,\"77\":3,\"79\":3,\"81\":4,\"83\":3,\"100\":2,\"104\":8,\"109\":2,\"111\":2,\"112\":2,\"113\":5,\"118\":2,\"121\":5,\"123\":5,\"176\":1,\"180\":3,\"182\":7,\"244\":11,\"246\":11,\"247\":1,\"248\":10,\"261\":28,\"263\":8,\"320\":2,\"322\":2,\"324\":3,\"326\":3,\"339\":3,\"342\":16,\"347\":3,\"351\":11,\"353\":3,\"358\":3,\"359\":3,\"361\":8,\"362\":3,\"386\":4,\"393\":4,\"394\":6,\"396\":9,\"433\":3,\"434\":1,\"436\":6,\"437\":2,\"517\":1,\"525\":2,\"526\":3,\"527\":2,\"529\":5,\"530\":5,\"531\":5,\"533\":3,\"534\":3,\"535\":3,\"537\":9,\"543\":16}}],[\"radixsort\",{\"1\":{\"458\":1}}],[\"ransomnote\",{\"1\":{\"311\":8,\"313\":3,\"315\":3}}],[\"ransom\",{\"1\":{\"310\":1}}],[\"rateinfo\",{\"1\":{\"491\":2}}],[\"rateinfolist\",{\"1\":{\"491\":3}}],[\"rat\",{\"1\":{\"274\":1}}],[\"r\",{\"1\":{\"162\":11,\"294\":4,\"369\":1,\"370\":2,\"371\":10}}],[\"rightchildindex\",{\"1\":{\"574\":5}}],[\"right+1\",{\"1\":{\"503\":1}}],[\"right的部分进行快速排序\",{\"1\":{\"454\":1}}],[\"right时\",{\"1\":{\"428\":1}}],[\"right=mid−1\",{\"1\":{\"403\":1}}],[\"right=mid\",{\"1\":{\"403\":1}}],[\"right==null\",{\"1\":{\"388\":1}}],[\"rightsideview\",{\"1\":{\"180\":1,\"182\":1}}],[\"right\",{\"1\":{\"68\":4,\"69\":7,\"70\":13,\"71\":2,\"72\":2,\"81\":1,\"83\":2,\"104\":3,\"108\":1,\"109\":1,\"111\":2,\"112\":1,\"113\":6,\"117\":1,\"118\":1,\"121\":6,\"123\":2,\"153\":10,\"175\":1,\"180\":2,\"182\":1,\"232\":1,\"246\":6,\"248\":8,\"261\":9,\"263\":7,\"296\":5,\"322\":1,\"342\":5,\"351\":2,\"353\":2,\"361\":5,\"362\":1,\"369\":2,\"378\":1,\"380\":7,\"386\":7,\"387\":3,\"388\":6,\"396\":5,\"403\":2,\"405\":4,\"406\":4,\"407\":4,\"428\":12,\"436\":5,\"437\":1,\"453\":10,\"454\":9,\"455\":8,\"503\":17,\"504\":12,\"505\":5,\"517\":1,\"525\":2,\"526\":2,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":2,\"534\":1,\"535\":2,\"537\":6,\"543\":6}}],[\"representation\",{\"1\":{\"539\":1,\"540\":2}}],[\"replace\",{\"1\":{\"482\":1}}],[\"ret\",{\"1\":{\"416\":3,\"428\":6}}],[\"return\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"33\":2,\"38\":2,\"43\":4,\"62\":2,\"70\":4,\"72\":3,\"81\":2,\"83\":2,\"92\":2,\"95\":2,\"104\":3,\"113\":2,\"121\":2,\"123\":2,\"132\":3,\"141\":2,\"149\":1,\"151\":1,\"153\":2,\"162\":1,\"171\":2,\"180\":2,\"182\":2,\"191\":4,\"200\":3,\"208\":2,\"211\":1,\"220\":1,\"223\":2,\"232\":2,\"239\":3,\"246\":2,\"248\":2,\"253\":3,\"256\":3,\"263\":6,\"270\":2,\"278\":3,\"287\":1,\"306\":1,\"315\":3,\"324\":1,\"326\":2,\"334\":1,\"342\":2,\"351\":3,\"353\":2,\"361\":2,\"362\":2,\"371\":1,\"380\":1,\"386\":3,\"388\":2,\"396\":2,\"405\":2,\"406\":2,\"407\":2,\"416\":6,\"419\":5,\"428\":1,\"436\":4,\"437\":4,\"446\":1,\"449\":1,\"451\":1,\"454\":1,\"455\":1,\"456\":2,\"457\":4,\"458\":7,\"471\":1,\"484\":3,\"491\":6,\"493\":1,\"494\":1,\"503\":3,\"504\":6,\"505\":2,\"525\":1,\"526\":2,\"527\":2,\"529\":1,\"530\":1,\"531\":1,\"533\":2,\"534\":2,\"535\":2,\"537\":3,\"543\":7,\"566\":1,\"567\":3,\"574\":1,\"583\":2}}],[\"reversestr\",{\"1\":{\"371\":1}}],[\"reversestring\",{\"1\":{\"296\":1}}],[\"reverselist\",{\"1\":{\"220\":1,\"223\":2}}],[\"reverseeachword\",{\"1\":{\"152\":1,\"153\":2}}],[\"reversewords\",{\"1\":{\"149\":1,\"151\":1,\"153\":1}}],[\"reverse\",{\"1\":{\"145\":1,\"148\":1,\"149\":1,\"152\":1,\"153\":3,\"215\":1,\"291\":1,\"366\":1,\"371\":2,\"535\":1,\"543\":1}}],[\"removeelement\",{\"1\":{\"283\":1,\"287\":1}}],[\"removeelements\",{\"1\":{\"208\":1,\"211\":1}}],[\"removenthfromend\",{\"1\":{\"171\":1}}],[\"removeduplicates\",{\"1\":{\"92\":1,\"95\":1}}],[\"remove\",{\"1\":{\"87\":1,\"166\":1,\"204\":1,\"282\":1,\"388\":2,\"567\":1,\"574\":1}}],[\"restored\",{\"1\":{\"574\":1}}],[\"result\",{\"1\":{\"362\":4,\"526\":4,\"527\":6,\"533\":4,\"534\":4,\"535\":5,\"537\":9}}],[\"reslist\",{\"1\":{\"306\":4,\"527\":1}}],[\"res++\",{\"1\":{\"83\":1}}],[\"res\",{\"1\":{\"83\":2,\"141\":4,\"151\":3,\"180\":4,\"306\":3,\"342\":4,\"351\":7,\"353\":4,\"361\":4,\"380\":6}}],[\"recur\",{\"1\":{\"70\":4}}],[\"realimage已经被加载\",{\"1\":{\"17\":1}}],[\"realimage\",{\"1\":{\"17\":8}}],[\"refactoringguru\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"14\":1,\"36\":1,\"41\":1,\"46\":1}}],[\"run\",{\"1\":{\"0\":3}}],[\"runs\",{\"1\":{\"0\":1}}],[\"设树的高度为\",{\"1\":{\"519\":1}}],[\"设计时间复杂度为\",{\"1\":{\"424\":1}}],[\"设计并实现自己的链表\",{\"1\":{\"412\":1}}],[\"设计链表\",{\"0\":{\"410\":1,\"411\":1},\"1\":{\"551\":1}}],[\"设计模式\",{\"2\":{\"12\":1,\"18\":1,\"29\":1,\"34\":1,\"44\":1,\"50\":1,\"55\":1}}],[\"设计模式总览\",{\"0\":{\"7\":1}}],[\"设节点\",{\"1\":{\"261\":1}}],[\"设置一个合适长度的数组作为空桶\",{\"1\":{\"457\":1}}],[\"设置一个虚拟头节点\",{\"1\":{\"270\":1}}],[\"设置\",{\"1\":{\"0\":2}}],[\"乱写一通\",{\"2\":{\"6\":1}}],[\"这两个链表不相交\",{\"1\":{\"579\":1}}],[\"这类链表题目一般都是使用双指针法解决的\",{\"1\":{\"553\":1}}],[\"这里扩展一倍队列数\",{\"1\":{\"458\":1}}],[\"这里使用了插入排序\",{\"1\":{\"457\":1}}],[\"这些子序列的元素间隔相同\",{\"1\":{\"452\":1}}],[\"这些操作\",{\"1\":{\"236\":1}}],[\"这道题理解起来很简单\",{\"1\":{\"385\":1}}],[\"这是一种计算的便利\",{\"1\":{\"475\":1}}],[\"这是他们可以开始的最远的距离\",{\"1\":{\"200\":1}}],[\"这是此时唯一可以执行删除操作的重复项\",{\"1\":{\"88\":1}}],[\"这种情况\",{\"1\":{\"189\":1}}],[\"这样出栈的时候才是中左右的顺序\",{\"1\":{\"533\":1}}],[\"这样\",{\"1\":{\"380\":1}}],[\"这样方便后续做删除操作\",{\"1\":{\"270\":1}}],[\"这样就能保证我们每一层循环都可以过滤掉相同的元素\",{\"1\":{\"139\":1}}],[\"这样就完成向下一行的变化\",{\"1\":{\"123\":1}}],[\"这样就可以代替\",{\"1\":{\"16\":1}}],[\"这样你才不会成为温水里的青蛙\",{\"1\":{\"5\":1}}],[\"这个遍历顺序和\",{\"1\":{\"526\":1}}],[\"这个深度首次遇到\",{\"1\":{\"182\":1}}],[\"这个类就是一个\",{\"1\":{\"52\":1}}],[\"这个地球已经存在这么多年\",{\"1\":{\"5\":1}}],[\"这个事情的原理\",{\"1\":{\"4\":1}}],[\"况且你自己瞎捣鼓的方案还不如外面的好用\",{\"1\":{\"5\":1}}],[\"市面有很多解决方案\",{\"1\":{\"5\":1}}],[\"别忘了更新\",{\"1\":{\"342\":1}}],[\"别自己瞎捣鼓\",{\"1\":{\"5\":1}}],[\"别独自在脑子里面深究\",{\"1\":{\"3\":1}}],[\"很多人都遇到过\",{\"1\":{\"5\":1}}],[\"很喜欢\",{\"1\":{\"2\":1}}],[\"莫要时时刻刻把所有事物的原理搞清楚\",{\"1\":{\"5\":1}}],[\"认清自己就不是搞钻研这一块\",{\"1\":{\"5\":1}}],[\"脑子里面的那篇反思也就消失的无影无踪了\",{\"1\":{\"4\":1}}],[\"累了\",{\"1\":{\"4\":1}}],[\"阅读完博客网站美化以后\",{\"1\":{\"4\":1}}],[\"当用户下单后\",{\"1\":{\"574\":1}}],[\"当子节点小于父节点\",{\"1\":{\"574\":1}}],[\"当空间不足时\",{\"1\":{\"512\":1}}],[\"当退出循环时\",{\"1\":{\"503\":1}}],[\"当两个比较的位不相同的时候\",{\"1\":{\"493\":1}}],[\"当两个比较的位相同的时候\",{\"1\":{\"493\":1}}],[\"当执行下面两行代码时\",{\"1\":{\"484\":1}}],[\"当往数组添加第一个元素时\",{\"1\":{\"481\":1}}],[\"当数组内容发生改变时\",{\"1\":{\"486\":1}}],[\"当数组倒序时\",{\"1\":{\"446\":1}}],[\"当数组正序时\",{\"1\":{\"446\":1}}],[\"当第一次添加容量时\",{\"1\":{\"486\":1}}],[\"当第一次递归时\",{\"1\":{\"222\":1}}],[\"当第一轮遍历结束后\",{\"1\":{\"445\":1}}],[\"当成是当前节点遍历的上一个节点值\",{\"1\":{\"434\":1}}],[\"当left\",{\"1\":{\"428\":1}}],[\"当索引小于链表长度的一半时\",{\"1\":{\"418\":1}}],[\"当区间长度为\",{\"1\":{\"406\":1}}],[\"当我们使用数组实现哈希表时\",{\"1\":{\"462\":1}}],[\"当我们选择\",{\"1\":{\"403\":1}}],[\"当我们遇到一个右括号时\",{\"1\":{\"189\":1}}],[\"当我们遇到一个左括号时\",{\"1\":{\"189\":1}}],[\"当你将其中一棵覆盖到另一棵之上时\",{\"1\":{\"384\":1}}],[\"当你有一个复杂的对象需要创建时\",{\"1\":{\"46\":1}}],[\"当链表还剩下两个节点时\",{\"1\":{\"268\":1}}],[\"当树为空时\",{\"1\":{\"340\":1}}],[\"当树为空\",{\"1\":{\"261\":1}}],[\"当树退化为链表时\",{\"1\":{\"81\":1}}],[\"当遇到节点\",{\"1\":{\"261\":1}}],[\"当队列为空时\",{\"1\":{\"247\":1}}],[\"当节点为空时\",{\"1\":{\"246\":1}}],[\"当节点\",{\"1\":{\"244\":1,\"261\":1,\"528\":1}}],[\"当窗口符合条件时\",{\"1\":{\"231\":1}}],[\"当对\",{\"1\":{\"123\":1}}],[\"当遍历到一层时\",{\"1\":{\"119\":1}}],[\"当根节点左右孩子都不为空时\",{\"1\":{\"102\":1}}],[\"当根节点左右孩子有一个为空时\",{\"1\":{\"102\":1}}],[\"当前数组长度\",{\"1\":{\"486\":1}}],[\"当前元素的重复次数\",{\"1\":{\"342\":1}}],[\"当前节点位置\",{\"1\":{\"574\":1}}],[\"当前节点的父节点位置\",{\"1\":{\"574\":1}}],[\"当前节点的数\",{\"1\":{\"433\":2}}],[\"当前节点的值\",{\"1\":{\"339\":2}}],[\"当前节点\",{\"1\":{\"220\":1}}],[\"当前的右括号\",{\"1\":{\"189\":1}}],[\"当前字符与末尾元素不相同时\",{\"1\":{\"95\":1}}],[\"当前字符与队列尾部不同时\",{\"1\":{\"90\":1}}],[\"当前字符与队列尾部相同时\",{\"1\":{\"90\":1}}],[\"当前是相邻重复项\",{\"1\":{\"93\":1}}],[\"当字符串中同时有多组相邻重复项时\",{\"1\":{\"90\":1}}],[\"当调用\",{\"1\":{\"27\":1,\"485\":1}}],[\"当\",{\"1\":{\"27\":1,\"79\":1,\"123\":1,\"169\":1,\"230\":1,\"261\":1,\"294\":2,\"378\":1,\"418\":1,\"485\":1,\"503\":1,\"505\":1,\"581\":2}}],[\"当希望类只能有一个实例时\",{\"1\":{\"21\":1}}],[\"当花费一番经历\",{\"1\":{\"4\":1}}],[\"当时归咎的原因无非就是做题做少了\",{\"1\":{\"3\":1}}],[\"还没把博客搭建起来时\",{\"1\":{\"4\":1}}],[\"还是从后往前遍历来优化查找效率\",{\"1\":{\"418\":1}}],[\"还是会在索引范围内\",{\"1\":{\"371\":1}}],[\"还是会先查攻略\",{\"1\":{\"4\":1}}],[\"还是本身就不合适\",{\"1\":{\"4\":1}}],[\"还是你走偏了\",{\"0\":{\"4\":1}}],[\"那就是都+1\",{\"1\":{\"517\":1}}],[\"那就出现一种情况\",{\"1\":{\"505\":1}}],[\"那问题就直接转换为\",{\"1\":{\"198\":1}}],[\"那么现在头节点和尾节点都是\",{\"1\":{\"564\":1}}],[\"那么就在递归函数里加上这个参数\",{\"1\":{\"542\":1}}],[\"那么就交换\",{\"1\":{\"445\":1}}],[\"那么迭代遍历\",{\"1\":{\"536\":1}}],[\"那么\",{\"1\":{\"491\":1}}],[\"那么该节点会被追加到链表的末尾\",{\"1\":{\"412\":1}}],[\"那么将这两个节点的值相加作为合并后节点的新值\",{\"1\":{\"384\":1}}],[\"那么快跑者需要\",{\"1\":{\"200\":1}}],[\"那么fast将先到达\",{\"1\":{\"200\":1}}],[\"那么存在一个环使得算法无限循环\",{\"1\":{\"200\":1}}],[\"那么这个数就是快乐数\",{\"1\":{\"196\":1}}],[\"那么字符串就是无效的\",{\"1\":{\"189\":1}}],[\"那么求右子树的最小深度\",{\"1\":{\"104\":1}}],[\"那么最小深度就是1\",{\"1\":{\"104\":1}}],[\"那么最小深度就是0\",{\"1\":{\"104\":1}}],[\"那么必定是两个重复元素的和等于\",{\"1\":{\"60\":1}}],[\"那你打开一个游戏\",{\"1\":{\"4\":1}}],[\"那为了让自己不要那么纠结\",{\"1\":{\"2\":1}}],[\"懂或者不懂\",{\"1\":{\"4\":1}}],[\"它通过维护一个\",{\"1\":{\"574\":1}}],[\"它基于优先队列\",{\"1\":{\"574\":1}}],[\"它根据元素的延迟时间来决定元素的优先级\",{\"1\":{\"574\":1}}],[\"它会自动进行扩容操作\",{\"1\":{\"512\":1}}],[\"它可以被用作栈\",{\"1\":{\"574\":1}}],[\"它可以用作栈\",{\"1\":{\"512\":1}}],[\"它可以决定应用什么子类来实例化\",{\"1\":{\"52\":1}}],[\"它利用特定函数的映射关系\",{\"1\":{\"457\":1}}],[\"它们的\",{\"1\":{\"301\":1}}],[\"它们都可以实现相同的支付功能\",{\"1\":{\"15\":1}}],[\"它以不等于\",{\"1\":{\"283\":1}}],[\"它能控制对于原对象的访问\",{\"1\":{\"14\":1}}],[\"它并不以你的主观感受为主\",{\"1\":{\"4\":1}}],[\"它并非是你给予事物一定的作用力之后\",{\"1\":{\"4\":1}}],[\"它更像一种客观存在\",{\"1\":{\"4\":1}}],[\"它与问题中的\",{\"1\":{\"4\":1}}],[\"痛苦它只是一种感觉\",{\"1\":{\"4\":1}}],[\"痛苦\",{\"1\":{\"4\":1}}],[\"依然还有这个疑问\",{\"1\":{\"4\":1}}],[\"我该怎么办\",{\"1\":{\"503\":1}}],[\"我们才能不断地\",{\"1\":{\"504\":1}}],[\"我们将其与\",{\"1\":{\"478\":1}}],[\"我们的目标是刷穿leetcode\",{\"0\":{\"441\":1}}],[\"我们只需要维护常量空间\",{\"1\":{\"428\":1}}],[\"我们只需要遍历该字符串一次\",{\"1\":{\"92\":1,\"95\":1}}],[\"我们应往左边的区间找\",{\"1\":{\"403\":1}}],[\"我们应往右边的区间继续寻找\",{\"1\":{\"403\":1}}],[\"我们应该使用一个循环进行处理\",{\"1\":{\"322\":1}}],[\"我们是单独处理\",{\"1\":{\"322\":1}}],[\"我们先要排序\",{\"1\":{\"139\":1}}],[\"我们可以直接用\",{\"1\":{\"526\":1}}],[\"我们可以用一个标识位来表式当前层的结束\",{\"1\":{\"523\":1}}],[\"我们可以\",{\"1\":{\"301\":1,\"403\":1}}],[\"我们可以把它看做是每一层的链表\",{\"1\":{\"123\":1}}],[\"我们可以删除\",{\"1\":{\"88\":1}}],[\"我们无论是先删除哪一个\",{\"1\":{\"90\":1}}],[\"我们都会使用这四个相同的步骤\",{\"1\":{\"46\":1}}],[\"我就先跑去查看博客的美化功能了\",{\"1\":{\"4\":1}}],[\"我能想到的一些解决方式是寻找正确的反馈\",{\"1\":{\"4\":1}}],[\"我现在做事很痛苦\",{\"1\":{\"4\":1}}],[\"我这里说的不是粘贴复制\",{\"1\":{\"3\":1}}],[\"而常用的实现类是\",{\"1\":{\"574\":1}}],[\"而广度优先遍历则遵循\",{\"1\":{\"524\":1}}],[\"而这个区间就是我们的\",{\"1\":{\"503\":1}}],[\"而触发\",{\"1\":{\"485\":1}}],[\"而根据排序的方向又分为大顶堆和小顶堆\",{\"1\":{\"455\":1}}],[\"而右开所指向的位置本身就不在我们的候选区间里\",{\"1\":{\"403\":1}}],[\"而以数组的长度来定义右边界\",{\"1\":{\"403\":1}}],[\"而树\",{\"1\":{\"387\":2}}],[\"而另一些不会\",{\"1\":{\"384\":1}}],[\"而对于\",{\"1\":{\"322\":1}}],[\"而不会无穷大\",{\"1\":{\"200\":1}}],[\"而不是\",{\"1\":{\"378\":1,\"403\":1}}],[\"而不是单纯的输出树节点\",{\"1\":{\"245\":1}}],[\"而不是要钻研这个工具\",{\"1\":{\"4\":1}}],[\"而不是从头到尾\",{\"1\":{\"3\":1}}],[\"而\",{\"1\":{\"139\":1,\"141\":2,\"261\":1,\"371\":1,\"403\":1,\"504\":1,\"526\":1,\"579\":1}}],[\"而两个元素的交替移动也能达到这个效果\",{\"1\":{\"139\":1}}],[\"而每个部分也跟其他部分有不一样的参数\",{\"1\":{\"46\":1}}],[\"而a1\",{\"1\":{\"41\":1}}],[\"而简单工厂只是决定用什么子类来实例化出的一个对象\",{\"1\":{\"41\":1}}],[\"而无需指定具体的类\",{\"1\":{\"41\":1}}],[\"而银行账户则是一大捆现金的代理\",{\"1\":{\"15\":1}}],[\"而被追求者\",{\"1\":{\"15\":1}}],[\"而且能快速做出剪枝\",{\"1\":{\"139\":1}}],[\"而且\",{\"1\":{\"15\":1}}],[\"而你又学到了什么\",{\"1\":{\"5\":1}}],[\"而并非痛苦或者不痛苦\",{\"1\":{\"4\":1}}],[\"而是在用户操作后的几分钟或更长时间后再发送\",{\"1\":{\"574\":1}}],[\"而是\",{\"1\":{\"505\":1}}],[\"而是从具体的某件事中\",{\"1\":{\"5\":1}}],[\"而是因为人家解决问题的方式跟钻研的方式是不一样的\",{\"1\":{\"3\":1}}],[\"而是采取先\",{\"1\":{\"3\":1}}],[\"突然让你使用它来完成甲方需求\",{\"1\":{\"3\":1}}],[\"一部分是\",{\"1\":{\"557\":2}}],[\"一定出现在层序遍历序列的末尾\",{\"1\":{\"540\":1}}],[\"一定不等于\",{\"1\":{\"505\":1}}],[\"一定会在循环中\",{\"1\":{\"198\":1}}],[\"一定会在环中相遇\",{\"1\":{\"130\":1}}],[\"一直进行到已发现从源节点可达的所有节点为止\",{\"1\":{\"528\":1}}],[\"一直向左边靠近\",{\"1\":{\"504\":1}}],[\"一直保持不变\",{\"1\":{\"504\":1}}],[\"一样\",{\"1\":{\"480\":1}}],[\"一般可以解决如下几种问题\",{\"1\":{\"470\":1}}],[\"一共执行了\",{\"1\":{\"296\":1}}],[\"一个\",{\"1\":{\"573\":1}}],[\"一个指向上一个节点\",{\"1\":{\"560\":1}}],[\"一个指向下一个节点\",{\"1\":{\"560\":1}}],[\"一个算边的数量\",{\"1\":{\"517\":1}}],[\"一个哈希表\",{\"1\":{\"490\":1}}],[\"一个n个数的集合里有多少符合条件的子集\",{\"1\":{\"470\":1}}],[\"一个字符串按一定规则有几种切割方式\",{\"1\":{\"470\":1}}],[\"一个棵不为空\",{\"1\":{\"385\":1}}],[\"一个二叉搜索树的中序遍历是一个非递减的有序序列\",{\"1\":{\"340\":1}}],[\"一个节点也可以是它自己的祖先\",{\"1\":{\"261\":1}}],[\"一个空的队列不会调用\",{\"1\":{\"253\":1}}],[\"一个辅助备份\",{\"1\":{\"238\":1}}],[\"一个当成主要的\",{\"1\":{\"238\":1}}],[\"一个从来没使用过的技术\",{\"1\":{\"3\":1}}],[\"一旦两个指针都在循环中\",{\"1\":{\"200\":1}}],[\"一起走\",{\"1\":{\"169\":1}}],[\"一起同时\",{\"1\":{\"132\":1}}],[\"一颗自以为是\",{\"1\":{\"2\":1}}],[\"为数组的元素个数\",{\"1\":{\"476\":1}}],[\"为数组长度\",{\"1\":{\"62\":1,\"141\":1,\"162\":1,\"171\":1,\"208\":1,\"211\":1,\"232\":1,\"278\":1,\"287\":1,\"296\":1,\"334\":1,\"380\":1,\"405\":1,\"428\":1}}],[\"为二叉树的节点个数\",{\"1\":{\"436\":1}}],[\"为二叉树节点个数\",{\"1\":{\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"180\":1,\"182\":1,\"246\":1,\"248\":1,\"263\":1,\"342\":1,\"351\":2,\"353\":2,\"361\":1}}],[\"为树\",{\"1\":{\"386\":2}}],[\"为树的节点个数\",{\"1\":{\"324\":1,\"326\":1}}],[\"为奇数时\",{\"1\":{\"378\":1}}],[\"为\",{\"1\":{\"359\":1,\"416\":1,\"418\":1,\"419\":1,\"564\":1,\"579\":7,\"583\":2}}],[\"为当前节点\",{\"1\":{\"340\":1}}],[\"为单位构建答案\",{\"1\":{\"323\":1}}],[\"为nums1数组长度\",{\"1\":{\"306\":1}}],[\"为节点数量\",{\"1\":{\"526\":1}}],[\"为节点个数\",{\"1\":{\"396\":1}}],[\"为节点\",{\"1\":{\"261\":1}}],[\"为均摊\",{\"1\":{\"256\":1}}],[\"为操作数\",{\"1\":{\"256\":1}}],[\"为栈内元素个数\",{\"1\":{\"239\":1}}],[\"为起点的链表进行反转\",{\"1\":{\"221\":1}}],[\"为链表长度\",{\"1\":{\"220\":1,\"223\":1,\"270\":1,\"416\":1,\"419\":1}}],[\"为输入字符串的长度\",{\"1\":{\"153\":1}}],[\"为走过的环的圈数\",{\"1\":{\"130\":1}}],[\"为了支持优先级的比较\",{\"1\":{\"574\":1}}],[\"为了避免枚举到重复四元组\",{\"1\":{\"160\":1}}],[\"为了更有效的找到有效解\",{\"1\":{\"140\":1}}],[\"为了\",{\"1\":{\"139\":1,\"140\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"128\":1}}],[\"为了得分\",{\"1\":{\"3\":1}}],[\"为空\",{\"1\":{\"261\":1}}],[\"为空为止\",{\"1\":{\"123\":1}}],[\"为空就表示\",{\"1\":{\"120\":1,\"121\":1}}],[\"为空时\",{\"1\":{\"79\":1,\"244\":1}}],[\"为下一层的节点更新\",{\"1\":{\"113\":1}}],[\"为字符串长度\",{\"1\":{\"92\":1,\"95\":1,\"149\":1,\"151\":1,\"191\":1,\"315\":1,\"371\":1}}],[\"为什么要初始化2的n次幂个长度\",{\"1\":{\"513\":1}}],[\"为什么不是用\",{\"1\":{\"513\":1}}],[\"为什么不是从\",{\"1\":{\"475\":1}}],[\"为什么使用\",{\"0\":{\"491\":1}}],[\"为什么数组索引从\",{\"1\":{\"475\":1}}],[\"为什么成绩比我好的那么多\",{\"1\":{\"3\":1}}],[\"为什么我说它是固执的\",{\"1\":{\"2\":1}}],[\"明明看这个人木的很\",{\"1\":{\"3\":1}}],[\"就会发生扩容\",{\"1\":{\"486\":1}}],[\"就会直接扩容到默认初始容量\",{\"1\":{\"481\":1}}],[\"就会导致退出循环\",{\"1\":{\"378\":1}}],[\"就像每一个人的身份证对应一个人一样\",{\"1\":{\"461\":1}}],[\"就像我们要画一个人\",{\"1\":{\"46\":1}}],[\"就将未排序元素插入到\",{\"1\":{\"450\":1}}],[\"就将同层节点与最大值进行比较\",{\"1\":{\"349\":1}}],[\"就把\",{\"1\":{\"388\":1}}],[\"就把将他们放入队列中\",{\"1\":{\"387\":1}}],[\"就放入对应的索引中\",{\"1\":{\"465\":1}}],[\"就放入一个对应的右括号\",{\"1\":{\"189\":1}}],[\"就放到队列中\",{\"1\":{\"388\":1}}],[\"就反转这\",{\"1\":{\"367\":1}}],[\"就要进行比较绝对差\",{\"1\":{\"359\":1}}],[\"就说明存在一个元素比\",{\"1\":{\"340\":1}}],[\"就说明括号右效\",{\"1\":{\"189\":1}}],[\"就添加进\",{\"1\":{\"340\":1}}],[\"就表示反转结束\",{\"1\":{\"294\":1}}],[\"就可以很容易区分出来变化的量应该放在\",{\"1\":{\"380\":1}}],[\"就可以进行更改链表节点的交换\",{\"1\":{\"268\":1}}],[\"就可以通过父节点的\",{\"1\":{\"111\":1}}],[\"就返回\",{\"1\":{\"196\":1}}],[\"就是相交点\",{\"1\":{\"582\":1}}],[\"就是链表首尾相连\",{\"1\":{\"561\":1}}],[\"就是单纯的模拟\",{\"1\":{\"508\":1}}],[\"就是说当阀值容量占了3\",{\"1\":{\"495\":1}}],[\"就是我们要得到的结果\",{\"1\":{\"403\":1}}],[\"就是答案\",{\"1\":{\"333\":1}}],[\"就是最近公共祖先\",{\"1\":{\"261\":1}}],[\"就是根节点的左子树\",{\"1\":{\"246\":1}}],[\"就是当前答案\",{\"1\":{\"141\":1}}],[\"就是直接用这种方式\",{\"1\":{\"3\":1}}],[\"就下一层的虚拟头节点指向它\",{\"1\":{\"123\":1}}],[\"就\",{\"1\":{\"15\":1}}],[\"就够了\",{\"1\":{\"5\":1}}],[\"就算自己瞎玩\",{\"1\":{\"2\":1}}],[\"的任务\",{\"1\":{\"574\":1}}],[\"的底层实现是一个二叉堆\",{\"1\":{\"574\":1}}],[\"的实现模拟单端队列行为\",{\"1\":{\"574\":1}}],[\"的实现原理\",{\"1\":{\"490\":1}}],[\"的实现原理是什么\",{\"1\":{\"486\":1}}],[\"的头节点\",{\"1\":{\"564\":1}}],[\"的步骤\",{\"1\":{\"533\":1}}],[\"的步速大于\",{\"1\":{\"130\":1}}],[\"的所在边都己被探寻过\",{\"1\":{\"528\":1}}],[\"的所有满足\",{\"1\":{\"139\":1}}],[\"的遍历结果是一个一维数组\",{\"1\":{\"526\":1}}],[\"的遍历顺序\",{\"1\":{\"434\":1}}],[\"的规则\",{\"1\":{\"524\":2}}],[\"的关键点在于如何记录每一层次是否遍历完成\",{\"1\":{\"523\":1}}],[\"的线性的数据结构\",{\"1\":{\"511\":1}}],[\"的暴力解法降为\",{\"1\":{\"507\":1}}],[\"的操作发生\",{\"1\":{\"505\":1}}],[\"的下界\",{\"1\":{\"505\":1}}],[\"的下标就是答案\",{\"1\":{\"60\":1}}],[\"的下标与\",{\"1\":{\"60\":1}}],[\"的上界right\",{\"1\":{\"504\":1}}],[\"的集合\",{\"1\":{\"500\":1}}],[\"的容量变成原来的\",{\"1\":{\"485\":1}}],[\"的容量就是这个数组缓冲区的长度\",{\"1\":{\"478\":1}}],[\"的空数组列表将在添加第一个元素时扩展为\",{\"1\":{\"478\":1}}],[\"的空间来存储字符串\",{\"1\":{\"153\":1}}],[\"的一个元素\",{\"1\":{\"448\":1}}],[\"的一个引用可以使得代理可以访问\",{\"1\":{\"16\":1}}],[\"的算法解决本问题\",{\"1\":{\"424\":1}}],[\"的算法吗\",{\"1\":{\"58\":1}}],[\"的次数不超过\",{\"1\":{\"412\":1}}],[\"的时候\",{\"1\":{\"403\":1}}],[\"的时间\",{\"1\":{\"306\":1}}],[\"的每个元素都将在\",{\"1\":{\"401\":1}}],[\"的右子树搜索\",{\"1\":{\"394\":1}}],[\"的右子节点\",{\"1\":{\"244\":1}}],[\"的右子节点与\",{\"1\":{\"69\":1}}],[\"的右子节点相同\",{\"1\":{\"69\":1}}],[\"的第一个还是第二个\",{\"1\":{\"380\":1}}],[\"的情况\",{\"1\":{\"371\":1,\"463\":1}}],[\"的范围\",{\"1\":{\"369\":1}}],[\"的过程中\",{\"1\":{\"349\":1}}],[\"的根节点\",{\"1\":{\"339\":1,\"393\":1}}],[\"的数组存放\",{\"1\":{\"313\":1}}],[\"的数组来存储情况\",{\"1\":{\"95\":1}}],[\"的额外空间解决这一问题\",{\"1\":{\"292\":1}}],[\"的形式给出\",{\"1\":{\"292\":1}}],[\"的值都在target的右侧\",{\"1\":{\"504\":1}}],[\"的值\",{\"1\":{\"418\":1,\"504\":1}}],[\"的值排序\",{\"1\":{\"283\":1}}],[\"的值为\",{\"1\":{\"128\":1}}],[\"的大小并不重要\",{\"1\":{\"283\":1}}],[\"的其余元素和\",{\"1\":{\"283\":1}}],[\"的前驱节点为\",{\"1\":{\"564\":1}}],[\"的前\",{\"1\":{\"283\":2}}],[\"的元素有\",{\"1\":{\"504\":2}}],[\"的元素数量为\",{\"1\":{\"283\":1}}],[\"的元素\",{\"1\":{\"283\":2}}],[\"的字母异位词\",{\"1\":{\"274\":1}}],[\"的字符串\",{\"1\":{\"187\":1}}],[\"的异侧\",{\"1\":{\"261\":1}}],[\"的异侧时\",{\"1\":{\"261\":1}}],[\"的子树中\",{\"1\":{\"261\":1}}],[\"的最近公共祖先\",{\"1\":{\"261\":1}}],[\"的最近公共祖先是节点\",{\"1\":{\"261\":2}}],[\"的公共祖先\",{\"1\":{\"261\":1}}],[\"的某公共祖先\",{\"1\":{\"261\":1}}],[\"的祖先\",{\"1\":{\"261\":1}}],[\"的祖先且\",{\"1\":{\"261\":1}}],[\"的深度尽可能大\",{\"1\":{\"261\":1}}],[\"的两个节点\",{\"1\":{\"261\":1}}],[\"的队列\",{\"1\":{\"253\":1}}],[\"的左子树搜索\",{\"1\":{\"394\":1}}],[\"的左子树上\",{\"1\":{\"388\":1}}],[\"的左子树挂到\",{\"1\":{\"388\":1}}],[\"的左子树为空\",{\"1\":{\"388\":1}}],[\"的左子树都不为空\",{\"1\":{\"388\":1}}],[\"的左子树中\",{\"1\":{\"261\":1}}],[\"的左子节点\",{\"1\":{\"244\":2}}],[\"的左子节点相同\",{\"1\":{\"69\":1}}],[\"的左子节点与\",{\"1\":{\"69\":1}}],[\"的左或右子树中\",{\"1\":{\"261\":2}}],[\"的左\",{\"1\":{\"261\":1}}],[\"的左右子节点\",{\"1\":{\"247\":1}}],[\"的左右节点进行入队\",{\"1\":{\"247\":1}}],[\"的新右子节点\",{\"1\":{\"244\":1}}],[\"的新左子节点\",{\"1\":{\"244\":1}}],[\"的栈\",{\"1\":{\"236\":1}}],[\"的栈空间来递归\",{\"1\":{\"246\":1}}],[\"的栈空间\",{\"1\":{\"182\":2,\"396\":1}}],[\"的节点之前\",{\"1\":{\"412\":1}}],[\"的节点插入到链表中下标为\",{\"1\":{\"412\":1}}],[\"的节点插入到链表中第一个元素之前\",{\"1\":{\"412\":1}}],[\"的节点追加到链表中作为链表的最后一个元素\",{\"1\":{\"412\":1}}],[\"的节点的值\",{\"1\":{\"412\":1}}],[\"的节点个数\",{\"1\":{\"386\":2}}],[\"的节点为\",{\"1\":{\"385\":2}}],[\"的节点将直接作为新二叉树的节点\",{\"1\":{\"384\":1}}],[\"的节点\",{\"1\":{\"205\":1,\"385\":1,\"393\":1,\"412\":1}}],[\"的位置开始\",{\"1\":{\"450\":1}}],[\"的位置正好是答案\",{\"1\":{\"403\":1}}],[\"的位置明显不是答案\",{\"1\":{\"403\":1}}],[\"的位置我们是可以取到的\",{\"1\":{\"403\":1}}],[\"的位置\",{\"1\":{\"200\":1,\"406\":1,\"445\":1}}],[\"的副本并排序\",{\"1\":{\"162\":1}}],[\"的顺序\",{\"1\":{\"146\":1}}],[\"的方式一致\",{\"1\":{\"482\":1}}],[\"的方式\",{\"1\":{\"139\":1}}],[\"的方法需要\",{\"1\":{\"153\":1}}],[\"的方法\",{\"1\":{\"36\":1}}],[\"的链表节点\",{\"1\":{\"128\":2}}],[\"的那条边的起始节点\",{\"1\":{\"528\":1}}],[\"的那\",{\"1\":{\"58\":1}}],[\"的接口相同的接口\",{\"1\":{\"16\":1}}],[\"的共用操作\",{\"1\":{\"16\":1}}],[\"的\",{\"1\":{\"15\":1,\"79\":2,\"139\":1,\"261\":3,\"301\":1,\"387\":6,\"485\":1,\"490\":1}}],[\"的行动策略\",{\"1\":{\"3\":1}}],[\"的种子就这么埋下了\",{\"1\":{\"2\":1}}],[\"后都属于深度优先遍历\",{\"1\":{\"528\":1}}],[\"后序遍历顺序\",{\"1\":{\"535\":1}}],[\"后序遍历\",{\"0\":{\"528\":1,\"531\":1,\"535\":1},\"1\":{\"531\":1,\"543\":1}}],[\"后进先出\",{\"1\":{\"511\":1,\"512\":1}}],[\"后处理检查\",{\"1\":{\"505\":1}}],[\"后面\",{\"1\":{\"443\":2}}],[\"后继节点\",{\"1\":{\"417\":1}}],[\"后驱节点是f\",{\"1\":{\"564\":1}}],[\"后驱节点\",{\"1\":{\"220\":1}}],[\"后续继续循环\",{\"1\":{\"123\":1}}],[\"后者则是为了深挖\",{\"1\":{\"3\":1}}],[\"后\",{\"1\":{\"3\":1,\"484\":1,\"486\":1}}],[\"运行\",{\"1\":{\"3\":1}}],[\"却未曾去寻找那对应的模板\",{\"1\":{\"3\":1}}],[\"却跑到了推导泰勒公式的道上来\",{\"1\":{\"2\":1}}],[\"形成一种模板\",{\"1\":{\"3\":1}}],[\"也称深度优先搜索\",{\"1\":{\"528\":1}}],[\"也提前返回\",{\"1\":{\"434\":1}}],[\"也就意味着\",{\"1\":{\"403\":1}}],[\"也就是这一层的结点数量\",{\"1\":{\"526\":1}}],[\"也就是返回一个二维数组\",{\"1\":{\"526\":1}}],[\"也就是只有\",{\"1\":{\"253\":1}}],[\"也就是\",{\"1\":{\"236\":1,\"484\":1}}],[\"也就是下一行的头\",{\"1\":{\"123\":1}}],[\"也就是说代理\",{\"1\":{\"15\":1}}],[\"也就是说某种情况对应某个答案\",{\"1\":{\"3\":1}}],[\"也返回\",{\"1\":{\"394\":1}}],[\"也将他们放入队列中\",{\"1\":{\"387\":1}}],[\"也不是正确答案\",{\"1\":{\"313\":1}}],[\"也不是长篇大论\",{\"1\":{\"5\":1}}],[\"也是可通过的\",{\"1\":{\"301\":1}}],[\"也可以用作队列\",{\"1\":{\"574\":1}}],[\"也可以称为边\",{\"1\":{\"517\":1}}],[\"也可以表示\",{\"1\":{\"504\":1}}],[\"也可以使用长度固定的数组记录不同字母出现的次数\",{\"1\":{\"277\":1}}],[\"也可能是\",{\"1\":{\"196\":1}}],[\"也有可能\",{\"1\":{\"141\":1}}],[\"也会创建实例对象\",{\"1\":{\"22\":1}}],[\"也能考得比那些埋头苦读的人的成绩好\",{\"1\":{\"2\":1}}],[\"铺天盖地都是成熟方案\",{\"1\":{\"3\":1}}],[\"以避免即时发送失败或对用户体验造成干扰\",{\"1\":{\"574\":1}}],[\"以及\",{\"1\":{\"486\":1}}],[\"以便知道添加第一个元素时要膨胀多少\",{\"1\":{\"478\":1}}],[\"以指示链表中的上一个节点\",{\"1\":{\"412\":1}}],[\"以指向其下一个右侧节点\",{\"1\":{\"109\":1,\"118\":1}}],[\"以\",{\"1\":{\"323\":1}}],[\"以一个数组来记录\",{\"1\":{\"278\":1}}],[\"以空格进行分割\",{\"1\":{\"148\":1}}],[\"以前我特别希望有一片小天地\",{\"1\":{\"4\":1}}],[\"以前脑海中总有一个疑问\",{\"1\":{\"4\":1}}],[\"以往听到的解释是人家在你睡着的时候偷偷卷了\",{\"1\":{\"3\":1}}],[\"以结果导向的方式去做事带来的收益会大一些\",{\"1\":{\"3\":1}}],[\"以我现在工作几年的经历\",{\"1\":{\"2\":1}}],[\"哪天没睡好\",{\"1\":{\"3\":1}}],[\"心理上很受打击\",{\"1\":{\"3\":1}}],[\"你必须\",{\"1\":{\"292\":1}}],[\"你必须在不修改节点内部的值的情况下完成本题\",{\"1\":{\"266\":1}}],[\"你在返回的\",{\"1\":{\"283\":2}}],[\"你需要在\",{\"1\":{\"393\":1}}],[\"你需要将这两棵树合并成一棵新二叉树\",{\"1\":{\"384\":1}}],[\"你需要\",{\"1\":{\"283\":1}}],[\"你所使用的语言也许不支持栈\",{\"1\":{\"253\":1}}],[\"你所使用的语言也许不支持队列\",{\"1\":{\"236\":1}}],[\"你\",{\"1\":{\"253\":1}}],[\"你只能使用队列的标准操作\",{\"1\":{\"236\":1}}],[\"你只能使用常量级额外空间\",{\"1\":{\"109\":1,\"118\":1}}],[\"你能否设计一个时间复杂度\",{\"1\":{\"579\":1}}],[\"你能否调整你的解法来应对这种情况\",{\"1\":{\"274\":1}}],[\"你能否实现每个操作均摊时间复杂度为\",{\"1\":{\"253\":1}}],[\"你能否仅用一个队列来实现栈\",{\"1\":{\"236\":1}}],[\"你能否用两种方法解决这道题\",{\"1\":{\"216\":1}}],[\"你能尝试使用一趟扫描实现吗\",{\"1\":{\"167\":1}}],[\"你返回所有和为\",{\"1\":{\"137\":1}}],[\"你的函数应该返回\",{\"1\":{\"283\":1}}],[\"你的函数应该填充它的每个\",{\"1\":{\"109\":1,\"118\":1}}],[\"你的函数函数应该返回\",{\"1\":{\"283\":1}}],[\"你的解决方案将会\",{\"1\":{\"283\":1}}],[\"你的成熟方案呢\",{\"0\":{\"3\":1}}],[\"你可以选择使用单链表或者双链表\",{\"1\":{\"412\":1}}],[\"你可以假设\",{\"1\":{\"401\":1}}],[\"你可以假设每种输入只会对应一个答案\",{\"1\":{\"58\":1}}],[\"你可以不使用额外的空间吗\",{\"1\":{\"339\":1}}],[\"你可以使用\",{\"1\":{\"236\":1,\"253\":1}}],[\"你可以按\",{\"1\":{\"158\":1}}],[\"你可以按任意顺序返回答案\",{\"1\":{\"58\":1}}],[\"你可以运用递归和迭代两种方法解决这个问题吗\",{\"1\":{\"67\":1}}],[\"你可以想出一个时间复杂度小于\",{\"1\":{\"58\":1}}],[\"你可不可以用上一些工具就能把这个事情做好\",{\"1\":{\"4\":1}}],[\"你也可以用实际的类来接收产品\",{\"1\":{\"48\":1}}],[\"你希望生成与其完全相同的一个对象\",{\"1\":{\"31\":1}}],[\"你看到了什么\",{\"1\":{\"5\":1}}],[\"你遇到的问题\",{\"1\":{\"5\":1}}],[\"你是否可以使用\",{\"1\":{\"128\":1}}],[\"你是会先玩\",{\"1\":{\"4\":1}}],[\"你是不是也有过那种\",{\"1\":{\"3\":1}}],[\"你不够擅长\",{\"0\":{\"4\":1}}],[\"你应该是找市面上存在的成熟方案\",{\"1\":{\"3\":1}}],[\"你到底有没有认真学\",{\"0\":{\"2\":1}}],[\"😗\",{\"1\":{\"2\":1}}],[\"规律掌握\",{\"1\":{\"2\":1}}],[\"自顶向下依次访问左侧链\",{\"1\":{\"533\":1}}],[\"自身\",{\"1\":{\"532\":1,\"536\":1}}],[\"自增\",{\"1\":{\"285\":1}}],[\"自底向上从叶子节点开始更新的\",{\"1\":{\"262\":1}}],[\"自以为自己是科研人才\",{\"1\":{\"2\":1}}],[\"自以为自己能把这原理\",{\"1\":{\"2\":1}}],[\"自己的升学历程很顺利\",{\"1\":{\"2\":1}}],[\"总体空间复杂度为\",{\"1\":{\"416\":1,\"419\":1}}],[\"总体是线性复杂度\",{\"1\":{\"132\":1}}],[\"总览\",{\"0\":{\"8\":1,\"443\":1}}],[\"总结\",{\"0\":{\"5\":1,\"483\":1,\"486\":1}}],[\"总喜欢往细处扣\",{\"1\":{\"2\":1}}],[\"总是喜欢扎进去深究\",{\"1\":{\"2\":1}}],[\"于是就可以研究起了博客\",{\"1\":{\"4\":1}}],[\"于是就变成了无脑乐观派\",{\"1\":{\"2\":1}}],[\"于是就容易陷于死胡同\",{\"1\":{\"2\":1}}],[\"于是\",{\"1\":{\"2\":1,\"15\":1}}],[\"学习成绩也都是属一属二的程度\",{\"1\":{\"2\":1}}],[\"学习的时候\",{\"1\":{\"2\":1}}],[\"老师夸夸神童的程度\",{\"1\":{\"2\":1}}],[\"父母\",{\"1\":{\"2\":1}}],[\"属于当时被家长\",{\"1\":{\"2\":1}}],[\"不过一个是算节点的数量\",{\"1\":{\"517\":1}}],[\"不涉及到什么算法\",{\"1\":{\"508\":1}}],[\"不断调节子序列的起始位置\",{\"1\":{\"507\":1}}],[\"不断的从队列中取出节点\",{\"1\":{\"387\":1}}],[\"不在数组中\",{\"1\":{\"504\":1}}],[\"不能被2整除的最小素数\",{\"1\":{\"491\":1}}],[\"不能使用\",{\"1\":{\"246\":1}}],[\"不稳定\",{\"1\":{\"443\":4}}],[\"不稳定排序\",{\"1\":{\"443\":1}}],[\"不满足二叉搜索树条件\",{\"1\":{\"436\":1}}],[\"不会插入\",{\"1\":{\"412\":1}}],[\"不会被加载到内存中\",{\"1\":{\"27\":1}}],[\"不为\",{\"1\":{\"384\":1}}],[\"不为空\",{\"1\":{\"261\":1,\"359\":1}}],[\"不足\",{\"1\":{\"371\":1}}],[\"不考虑输出结果的顺序\",{\"1\":{\"301\":1}}],[\"不要立即返回\",{\"1\":{\"505\":1}}],[\"不要给另外的数组分配额外的空间\",{\"1\":{\"292\":1}}],[\"不要用\",{\"1\":{\"245\":1}}],[\"不相同的节点\",{\"1\":{\"340\":1}}],[\"不相同\",{\"1\":{\"285\":1}}],[\"不是快乐数\",{\"1\":{\"198\":1,\"200\":1}}],[\"不是\",{\"1\":{\"196\":1}}],[\"不一样时\",{\"1\":{\"189\":1}}],[\"不判断相同答案的元素\",{\"1\":{\"141\":2}}],[\"不判断相同元素\",{\"1\":{\"141\":2}}],[\"不可以包含重复的三元组\",{\"1\":{\"140\":1}}],[\"不重复的情况\",{\"1\":{\"342\":1}}],[\"不重复则需要\",{\"1\":{\"141\":1}}],[\"不重复\",{\"1\":{\"139\":1}}],[\"不同字母的个数\",{\"1\":{\"313\":1}}],[\"不同的元素的数量\",{\"1\":{\"283\":1}}],[\"不同的三元组是\",{\"1\":{\"137\":1}}],[\"不同父节点的子节点\",{\"1\":{\"111\":1}}],[\"不允许修改\",{\"1\":{\"128\":1}}],[\"不作为参数进行传递\",{\"1\":{\"128\":1}}],[\"不需要存储额外的节点\",{\"1\":{\"113\":1}}],[\"不存在\",{\"1\":{\"60\":1,\"401\":1,\"503\":1}}],[\"不管是因为什么原因导致的\",{\"1\":{\"503\":1}}],[\"不管是什么类型的人\",{\"1\":{\"46\":1}}],[\"不管是工作上还是学习上遇到的障碍\",{\"1\":{\"3\":1}}],[\"不管是工作还是学习\",{\"1\":{\"3\":1}}],[\"不管是学习还是做事\",{\"1\":{\"2\":1}}],[\"不然不还得扣你分嘛\",{\"1\":{\"2\":1}}],[\"不知变通\",{\"1\":{\"2\":1}}],[\"琢磨也没问题\",{\"1\":{\"2\":1}}],[\"瞎琢磨\",{\"1\":{\"2\":1}}],[\"觉得自己能搞懂\",{\"1\":{\"2\":1}}],[\"但回溯却可以解决问题\",{\"1\":{\"470\":1}}],[\"但跟之前不同的是要操作两棵树\",{\"1\":{\"385\":1}}],[\"但大于或等于\",{\"1\":{\"367\":1}}],[\"但在处理的时候依然遵循\",{\"1\":{\"325\":1}}],[\"但始终变不到\",{\"1\":{\"196\":1}}],[\"但是还没有处理\",{\"1\":{\"537\":3}}],[\"但是右子节点的值是\",{\"1\":{\"433\":1}}],[\"但是我们选择的是左闭右开区间\",{\"1\":{\"403\":1}}],[\"但是\",{\"1\":{\"58\":1}}],[\"但是为了保持风格的一致\",{\"1\":{\"41\":1}}],[\"但是由于羞耻不敢于表达\",{\"1\":{\"15\":1}}],[\"但是在做题时\",{\"1\":{\"2\":1}}],[\"但我们容易把后者误当成前者\",{\"1\":{\"4\":1}}],[\"但唯独没归咎到自身的问题上\",{\"1\":{\"3\":1}}],[\"但其实差了十万八千里的思维方式\",{\"1\":{\"2\":1}}],[\"但这东西可是前人花了好大力气才得出来\",{\"1\":{\"2\":1}}],[\"但你说实在的话\",{\"1\":{\"2\":1}}],[\"但却偏离了最初学习的目的\",{\"1\":{\"2\":1}}],[\"举个简单的例子就是高数课程上\",{\"1\":{\"2\":1}}],[\"在用户注册\",{\"1\":{\"574\":1}}],[\"在线购物平台中\",{\"1\":{\"574\":1}}],[\"在链表第\",{\"1\":{\"551\":1}}],[\"在链表的最后面插入一个节点\",{\"1\":{\"551\":1}}],[\"在链表的最前面插入一个节点\",{\"1\":{\"551\":1}}],[\"在这里也就会重复调用自己来实现递归的过程\",{\"1\":{\"542\":1}}],[\"在这里它表示是贬义的\",{\"1\":{\"2\":1}}],[\"在需要频繁进行\",{\"1\":{\"541\":1}}],[\"在需要的时候\",{\"1\":{\"24\":1}}],[\"在最差情况下\",{\"1\":{\"526\":1,\"531\":1}}],[\"在leetcode中\",{\"1\":{\"517\":1}}],[\"在循环过程中\",{\"1\":{\"504\":1}}],[\"在数组中\",{\"1\":{\"504\":1}}],[\"在数据内部进行排序\",{\"1\":{\"446\":1}}],[\"在区间\",{\"1\":{\"504\":1}}],[\"在上面的\",{\"1\":{\"503\":1}}],[\"在左边进行填充0\",{\"1\":{\"493\":1}}],[\"在左闭右开的情况是找不到这个位置的\",{\"1\":{\"403\":1}}],[\"在左闭右开的情况\",{\"1\":{\"403\":1}}],[\"在二叉树中\",{\"1\":{\"517\":1}}],[\"在二叉树的时候\",{\"1\":{\"322\":1}}],[\"在二进制中\",{\"1\":{\"491\":1}}],[\"在底层里\",{\"1\":{\"486\":1}}],[\"在添加数据的时候\",{\"1\":{\"486\":1}}],[\"在调用\",{\"1\":{\"484\":1}}],[\"在一些问题上通过for循环暴力枚举是不可行的\",{\"1\":{\"470\":1}}],[\"在冲突的地方继续往前查询\",{\"1\":{\"465\":1}}],[\"在堆排序中用做降序排序\",{\"1\":{\"455\":1}}],[\"在堆排序中用做升序排序\",{\"1\":{\"455\":1}}],[\"在子序列进行插入排序\",{\"1\":{\"452\":1}}],[\"在已排序序列中从后向前扫描\",{\"1\":{\"450\":1}}],[\"在递归调用的时候二叉树的每个节点最多被访问一次\",{\"1\":{\"436\":1}}],[\"在递归左子树\",{\"1\":{\"181\":1}}],[\"在负数\",{\"1\":{\"428\":1}}],[\"在正数\",{\"1\":{\"428\":1}}],[\"在插入完成后\",{\"1\":{\"412\":1}}],[\"在出队的时候\",{\"1\":{\"352\":1}}],[\"在进行扩容的时候\",{\"1\":{\"486\":1}}],[\"在进行\",{\"1\":{\"349\":1}}],[\"在进行实例化\",{\"1\":{\"24\":1}}],[\"在每一层遍历开始前\",{\"1\":{\"526\":1}}],[\"在每一次移动过程中\",{\"1\":{\"218\":1}}],[\"在每个树行中找最大值\",{\"0\":{\"345\":1,\"346\":1},\"1\":{\"544\":1}}],[\"在深度优先搜索过程中\",{\"1\":{\"325\":1}}],[\"在遍历对方的链表\",{\"1\":{\"582\":1}}],[\"在遍历过程过程\",{\"1\":{\"418\":1}}],[\"在遍历过程中如果出现数字与需要移除的值\",{\"1\":{\"285\":1}}],[\"在遍历每一层节点时\",{\"1\":{\"178\":1}}],[\"在节点\",{\"1\":{\"261\":2}}],[\"在翻转后子节点会发生变化\",{\"1\":{\"245\":1}}],[\"在加入元素时先将\",{\"1\":{\"239\":1}}],[\"在虚拟头节点下\",{\"1\":{\"210\":1}}],[\"在环中它们由于步速不一致\",{\"1\":{\"200\":1}}],[\"在继续往下后\",{\"1\":{\"200\":1}}],[\"在固定两重循环元素的情况\",{\"1\":{\"141\":1}}],[\"在固定两个元素的情况下\",{\"1\":{\"139\":1}}],[\"在次相遇就是环入口\",{\"1\":{\"132\":1}}],[\"在完成所有重复项删除操作后返回最终的字符串\",{\"1\":{\"88\":1}}],[\"在父类中提供一个\",{\"1\":{\"36\":1}}],[\"在\",{\"1\":{\"15\":1,\"88\":2,\"255\":1,\"261\":4,\"406\":1,\"434\":1,\"511\":1,\"573\":2,\"579\":4}}],[\"在今天来看\",{\"1\":{\"3\":1}}],[\"在回头看那时的自己\",{\"1\":{\"2\":1}}],[\"东西\",{\"1\":{\"2\":1}}],[\"钻研\",{\"1\":{\"2\":1}}],[\">>>\",{\"1\":{\"493\":1,\"494\":5}}],[\">>\",{\"1\":{\"484\":1,\"485\":1}}],[\">target\",{\"1\":{\"403\":1}}],[\">0\",{\"1\":{\"388\":1}}],[\">2\",{\"1\":{\"220\":1}}],[\">=\",{\"1\":{\"151\":3,\"232\":1,\"380\":2,\"416\":2,\"437\":1,\"450\":1,\"451\":1,\"452\":1,\"455\":1,\"491\":1,\"494\":1,\"574\":1}}],[\">\",{\"1\":{\"0\":1,\"139\":3,\"141\":6,\"162\":5,\"200\":1,\"239\":2,\"306\":2,\"315\":1,\"324\":1,\"331\":2,\"342\":1,\"371\":1,\"394\":1,\"396\":1,\"405\":1,\"406\":1,\"412\":3,\"416\":1,\"419\":1,\"428\":1,\"434\":1,\"446\":1,\"450\":1,\"451\":1,\"452\":2,\"455\":3,\"456\":1,\"457\":1,\"480\":1,\"484\":2,\"485\":2,\"486\":1,\"490\":3,\"491\":2,\"503\":3,\"504\":2,\"505\":1,\"522\":1,\"529\":2,\"530\":2,\"531\":2,\"543\":3,\"574\":3,\"581\":1}}],[\"b+a\",{\"1\":{\"583\":1}}],[\"b+\",{\"1\":{\"581\":1}}],[\"b++\",{\"1\":{\"162\":1}}],[\"baseaddr\",{\"1\":{\"475\":1}}],[\"bacd\",{\"1\":{\"367\":1}}],[\"bacdfeg\",{\"1\":{\"367\":1}}],[\"backtracking\",{\"1\":{\"471\":2}}],[\"backtracing\",{\"1\":{\"469\":1}}],[\"back\",{\"1\":{\"236\":1}}],[\"bugstack\",{\"1\":{\"564\":1,\"565\":1,\"566\":1,\"567\":1}}],[\"bucketcount\",{\"1\":{\"457\":2}}],[\"buckets\",{\"1\":{\"457\":4}}],[\"bucketsort\",{\"1\":{\"457\":1}}],[\"bucketsize\",{\"1\":{\"457\":4}}],[\"bucket\",{\"1\":{\"456\":4,\"457\":4,\"458\":6}}],[\"bucketlen\",{\"1\":{\"456\":3}}],[\"bubblesort\",{\"1\":{\"446\":1}}],[\"buildleg\",{\"1\":{\"48\":4}}],[\"buildarm\",{\"1\":{\"48\":4}}],[\"buildbody\",{\"1\":{\"48\":4}}],[\"buildhead\",{\"1\":{\"48\":4}}],[\"buildermain\",{\"1\":{\"48\":1}}],[\"builder\",{\"1\":{\"46\":1}}],[\"build\",{\"1\":{\"0\":1}}],[\"bound\",{\"1\":{\"504\":1}}],[\"bootom\",{\"1\":{\"380\":1}}],[\"boolean\",{\"1\":{\"70\":2,\"72\":2,\"191\":1,\"200\":1,\"236\":1,\"239\":1,\"253\":1,\"256\":2,\"278\":1,\"315\":1,\"419\":1,\"436\":1,\"437\":2,\"446\":1,\"484\":1,\"567\":1}}],[\"bottom\",{\"1\":{\"378\":1,\"380\":5}}],[\"bst\",{\"1\":{\"339\":3,\"357\":1,\"358\":1,\"393\":2}}],[\"between\",{\"1\":{\"358\":1}}],[\"be\",{\"1\":{\"256\":1,\"416\":1}}],[\"behavioral\",{\"1\":{\"11\":1}}],[\"blue\",{\"1\":{\"146\":2}}],[\"break\",{\"1\":{\"132\":1,\"141\":1,\"162\":2,\"446\":1,\"574\":1}}],[\"branch\",{\"1\":{\"0\":1,\"517\":1}}],[\"branches\",{\"1\":{\"0\":1}}],[\"bb\",{\"1\":{\"88\":1}}],[\"bfs遍历的副产物\",{\"0\":{\"526\":1,\"527\":1}}],[\"bfs遍历\",{\"0\":{\"525\":1}}],[\"bfs\",{\"0\":{\"82\":1,\"322\":1,\"352\":1},\"1\":{\"78\":1,\"110\":1,\"321\":1,\"323\":1,\"348\":1,\"352\":2,\"523\":2,\"526\":5},\"2\":{\"125\":1,\"184\":1,\"328\":1,\"355\":1}}],[\"binarysearch\",{\"1\":{\"503\":1}}],[\"binary\",{\"1\":{\"70\":1,\"76\":1,\"99\":1,\"175\":1,\"243\":1,\"246\":1,\"248\":1,\"260\":1,\"263\":1,\"338\":1,\"342\":1,\"361\":1,\"383\":1,\"386\":1,\"392\":1,\"396\":1,\"400\":1,\"432\":1,\"436\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1}}],[\"billpughsingleton\",{\"1\":{\"27\":6}}],[\"b2\",{\"1\":{\"41\":1}}],[\"b1\",{\"1\":{\"41\":1}}],[\"b类型\",{\"1\":{\"41\":1}}],[\"b\",{\"1\":{\"15\":9,\"109\":1,\"118\":1,\"158\":4,\"162\":8,\"311\":1,\"333\":1,\"334\":3,\"443\":6,\"445\":3,\"486\":7,\"579\":5,\"581\":4,\"583\":5}}],[\"opens\",{\"1\":{\"544\":9}}],[\"options\",{\"1\":{\"0\":1}}],[\"overflow\",{\"1\":{\"485\":2,\"503\":1}}],[\"override\",{\"1\":{\"17\":2,\"33\":1}}],[\"order\",{\"1\":{\"319\":1,\"524\":1}}],[\"obj\",{\"1\":{\"256\":5,\"416\":6}}],[\"object\",{\"1\":{\"256\":1,\"416\":1,\"478\":3,\"480\":1,\"482\":2,\"484\":1,\"486\":1,\"493\":1,\"567\":1}}],[\"of\",{\"1\":{\"76\":1,\"99\":1,\"166\":1,\"253\":1,\"260\":1,\"300\":1,\"423\":1,\"539\":1,\"540\":2,\"578\":1}}],[\"offerfirst\",{\"1\":{\"362\":1}}],[\"offerlast\",{\"1\":{\"248\":3}}],[\"offer\",{\"1\":{\"72\":6,\"92\":1,\"180\":3,\"191\":3,\"239\":3,\"525\":3,\"526\":3}}],[\"o\",{\"1\":{\"58\":1,\"62\":2,\"70\":2,\"72\":2,\"81\":2,\"83\":2,\"92\":2,\"95\":2,\"104\":3,\"113\":2,\"121\":2,\"123\":2,\"128\":1,\"132\":2,\"139\":2,\"141\":4,\"146\":1,\"149\":3,\"151\":3,\"153\":2,\"162\":6,\"171\":2,\"180\":3,\"182\":4,\"191\":2,\"200\":4,\"208\":2,\"211\":2,\"220\":2,\"223\":2,\"228\":1,\"232\":2,\"239\":5,\"246\":3,\"248\":3,\"253\":2,\"256\":5,\"263\":4,\"270\":2,\"278\":2,\"285\":1,\"287\":2,\"292\":3,\"296\":3,\"306\":3,\"315\":2,\"324\":3,\"326\":2,\"334\":3,\"342\":2,\"351\":2,\"353\":2,\"361\":2,\"371\":2,\"380\":2,\"386\":2,\"396\":3,\"405\":2,\"416\":6,\"419\":7,\"424\":1,\"428\":2,\"436\":3,\"443\":20,\"461\":9,\"476\":4,\"490\":1,\"501\":2,\"507\":2,\"526\":4,\"527\":2,\"531\":4,\"541\":1,\"567\":3,\"568\":1,\"579\":2,\"583\":2}}],[\"out\",{\"1\":{\"17\":2,\"33\":2,\"255\":1,\"256\":8}}],[\"oldcapacity\",{\"1\":{\"484\":3,\"485\":4}}],[\"old\",{\"1\":{\"0\":1}}],[\"online\",{\"1\":{\"543\":1}}],[\"on\",{\"1\":{\"0\":2}}],[\"lcci\",{\"1\":{\"578\":1}}],[\"l<r∣∣t<b\",{\"1\":{\"378\":1}}],[\"l++\",{\"1\":{\"162\":3,\"371\":1}}],[\"l\",{\"1\":{\"162\":8,\"292\":4,\"294\":4,\"331\":3,\"369\":3,\"371\":14,\"406\":2,\"565\":4}}],[\"linklast\",{\"1\":{\"565\":1}}],[\"linkfirst\",{\"1\":{\"564\":1}}],[\"linkedhashmap<>\",{\"1\":{\"491\":1}}],[\"linkedlist\",{\"1\":{\"412\":1,\"569\":1,\"574\":2}}],[\"linkedlist<>\",{\"1\":{\"83\":2,\"525\":1,\"526\":1,\"537\":3}}],[\"linkedlist<treenode>\",{\"1\":{\"72\":1,\"388\":2}}],[\"linked\",{\"1\":{\"127\":1,\"132\":1,\"171\":1,\"204\":1,\"208\":1,\"211\":1,\"215\":1,\"220\":1,\"270\":1,\"411\":1,\"578\":1,\"583\":1}}],[\"lifo\",{\"1\":{\"236\":1,\"511\":1,\"512\":1}}],[\"listb\",{\"1\":{\"579\":7,\"581\":3,\"583\":1}}],[\"lista\",{\"1\":{\"579\":7,\"581\":3,\"583\":1}}],[\"lists\",{\"1\":{\"578\":1}}],[\"list会受到影响\",{\"1\":{\"486\":1}}],[\"list<rateinfo>\",{\"1\":{\"491\":2}}],[\"list<integer>\",{\"1\":{\"180\":2,\"182\":3,\"306\":1,\"324\":1,\"326\":1,\"342\":1,\"351\":2,\"353\":2,\"484\":1,\"491\":4,\"525\":2,\"526\":1,\"533\":2,\"534\":2,\"535\":2,\"537\":6}}],[\"list<string>\",{\"1\":{\"149\":1,\"486\":7}}],[\"list<list<integer>>\",{\"1\":{\"141\":2,\"162\":2,\"324\":2,\"326\":2,\"526\":2,\"527\":2}}],[\"list<treenode>\",{\"1\":{\"83\":1}}],[\"listnode\",{\"1\":{\"132\":6,\"171\":12,\"208\":9,\"211\":11,\"220\":11,\"223\":3,\"270\":13,\"562\":3,\"583\":8}}],[\"list\",{\"1\":{\"127\":1,\"132\":1,\"149\":1,\"166\":1,\"171\":1,\"204\":1,\"208\":1,\"211\":1,\"215\":1,\"220\":1,\"236\":1,\"253\":1,\"270\":1,\"324\":3,\"326\":2,\"411\":1,\"484\":2,\"486\":27,\"525\":3,\"529\":1,\"530\":1,\"531\":1,\"583\":1}}],[\"let\",{\"1\":{\"543\":8}}],[\"leaf\",{\"1\":{\"517\":1}}],[\"lenght++\",{\"1\":{\"458\":1}}],[\"lenght\",{\"1\":{\"458\":2}}],[\"length\",{\"1\":{\"58\":1,\"62\":1,\"88\":1,\"92\":1,\"95\":2,\"137\":1,\"139\":1,\"141\":3,\"146\":1,\"151\":1,\"153\":4,\"158\":1,\"162\":1,\"187\":1,\"191\":1,\"228\":1,\"232\":1,\"274\":2,\"278\":3,\"283\":2,\"292\":1,\"296\":1,\"301\":2,\"311\":2,\"315\":2,\"331\":4,\"342\":1,\"367\":1,\"371\":1,\"405\":1,\"406\":1,\"407\":1,\"424\":1,\"428\":2,\"446\":2,\"449\":2,\"451\":2,\"452\":1,\"455\":1,\"457\":5,\"458\":3,\"482\":1,\"484\":2,\"485\":3,\"491\":3,\"503\":2,\"504\":6,\"505\":1,\"543\":3}}],[\"len\",{\"1\":{\"452\":3}}],[\"levelordertraversalhelper\",{\"1\":{\"527\":4}}],[\"levelordertraversal\",{\"1\":{\"526\":1,\"527\":1}}],[\"levelorder\",{\"1\":{\"324\":1,\"326\":1,\"525\":1}}],[\"level\",{\"1\":{\"319\":1,\"517\":1,\"524\":1,\"526\":3,\"527\":5}}],[\"levelsize\",{\"1\":{\"121\":2,\"180\":3,\"353\":1,\"526\":2}}],[\"leftchildindex\",{\"1\":{\"574\":5}}],[\"left到index\",{\"1\":{\"454\":1}}],[\"left=mid+1\",{\"1\":{\"403\":1}}],[\"left==null\",{\"1\":{\"388\":1}}],[\"leftmost\",{\"1\":{\"253\":1}}],[\"left++\",{\"1\":{\"153\":1,\"296\":1,\"380\":1,\"428\":1}}],[\"left\",{\"1\":{\"68\":4,\"69\":7,\"70\":13,\"71\":2,\"72\":2,\"81\":1,\"83\":2,\"104\":3,\"109\":1,\"111\":2,\"112\":1,\"113\":8,\"118\":1,\"121\":6,\"123\":2,\"153\":9,\"180\":2,\"182\":1,\"232\":1,\"246\":7,\"248\":8,\"261\":6,\"263\":7,\"296\":4,\"322\":1,\"342\":5,\"351\":2,\"353\":2,\"361\":5,\"362\":1,\"369\":2,\"378\":1,\"380\":6,\"386\":7,\"387\":3,\"388\":6,\"396\":5,\"403\":2,\"405\":4,\"406\":4,\"407\":4,\"428\":9,\"436\":5,\"437\":1,\"453\":10,\"454\":7,\"455\":8,\"503\":19,\"504\":26,\"505\":16,\"517\":1,\"525\":2,\"526\":2,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":2,\"534\":1,\"535\":2,\"537\":6,\"543\":6}}],[\"leetcode\",{\"0\":{\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"440\":1,\"578\":1},\"1\":{\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"358\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"578\":1},\"2\":{\"63\":1,\"73\":1,\"84\":1,\"96\":1,\"105\":1,\"114\":1,\"124\":1,\"133\":1,\"142\":1,\"154\":1,\"163\":1,\"172\":1,\"183\":1,\"192\":1,\"201\":1,\"212\":1,\"224\":1,\"233\":1,\"240\":1,\"249\":1,\"257\":1,\"271\":1,\"279\":1,\"288\":1,\"297\":1,\"307\":1,\"316\":1,\"327\":1,\"335\":1,\"343\":1,\"354\":1,\"363\":1,\"372\":1,\"381\":1,\"389\":1,\"397\":1,\"408\":1,\"420\":1,\"429\":1,\"438\":1,\"466\":1,\"472\":1,\"509\":1,\"514\":1,\"545\":1,\"554\":1,\"570\":1,\"575\":1,\"584\":1}}],[\"largerchildindex\",{\"1\":{\"574\":5}}],[\"largestvalues\",{\"1\":{\"351\":1,\"353\":1}}],[\"largest\",{\"1\":{\"346\":1,\"455\":8}}],[\"labuladong\",{\"1\":{\"543\":1}}],[\"last\",{\"1\":{\"223\":2,\"564\":1,\"565\":2,\"566\":1}}],[\"lang\",{\"1\":{\"49\":1}}],[\"lazyinitializedsingleton\",{\"1\":{\"24\":5}}],[\"latest\",{\"1\":{\"0\":1}}],[\"lowestcommonancestor\",{\"1\":{\"263\":3}}],[\"lowest\",{\"1\":{\"260\":1}}],[\"log\",{\"1\":{\"228\":1}}],[\"logn\",{\"1\":{\"200\":2,\"405\":1}}],[\"longn\",{\"1\":{\"541\":1}}],[\"long\",{\"1\":{\"162\":3,\"436\":2,\"437\":4,\"458\":2,\"491\":3}}],[\"load\",{\"1\":{\"495\":1}}],[\"loadfactor\",{\"1\":{\"494\":3}}],[\"loadfromdisk\",{\"1\":{\"17\":2}}],[\"loading\",{\"1\":{\"17\":1}}],[\"lockfile\",{\"1\":{\"0\":1}}],[\"f\",{\"1\":{\"564\":4}}],[\"function\",{\"1\":{\"543\":4}}],[\"float\",{\"1\":{\"494\":1,\"495\":1}}],[\"floor\",{\"1\":{\"455\":1,\"457\":2}}],[\"front\",{\"1\":{\"236\":1,\"253\":1}}],[\"from\",{\"1\":{\"166\":1,\"236\":1,\"253\":1}}],[\"frozen\",{\"1\":{\"0\":1}}],[\"factor\",{\"1\":{\"495\":1}}],[\"factorymethod\",{\"1\":{\"38\":3}}],[\"factory\",{\"1\":{\"36\":1,\"41\":1}}],[\"fastrunner\",{\"1\":{\"200\":8}}],[\"fast在链表前进\",{\"1\":{\"198\":1}}],[\"fast\",{\"1\":{\"130\":8,\"132\":12,\"198\":2,\"200\":1}}],[\"false\",{\"1\":{\"67\":1,\"68\":2,\"70\":1,\"72\":1,\"187\":1,\"191\":2,\"196\":2,\"236\":3,\"253\":3,\"274\":1,\"278\":2,\"311\":3,\"315\":2,\"433\":1,\"434\":2,\"436\":2,\"437\":1,\"446\":1,\"567\":1}}],[\"found\",{\"1\":{\"586\":1}}],[\"foursumcount\",{\"1\":{\"334\":1}}],[\"foursum\",{\"1\":{\"162\":1}}],[\"for循环中变量定义成i或j的细节\",{\"1\":{\"380\":1}}],[\"for\",{\"1\":{\"62\":1,\"70\":1,\"83\":1,\"92\":1,\"95\":1,\"113\":1,\"121\":2,\"132\":1,\"141\":1,\"162\":2,\"171\":2,\"180\":1,\"191\":1,\"208\":1,\"211\":1,\"220\":1,\"246\":1,\"248\":1,\"263\":1,\"270\":1,\"278\":2,\"283\":1,\"287\":1,\"306\":4,\"315\":2,\"324\":1,\"326\":1,\"334\":4,\"342\":2,\"353\":1,\"361\":1,\"371\":1,\"380\":4,\"386\":1,\"396\":1,\"416\":1,\"419\":1,\"436\":1,\"446\":2,\"449\":2,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"455\":2,\"456\":3,\"457\":4,\"458\":6,\"471\":1,\"491\":6,\"506\":2,\"526\":1,\"567\":2,\"583\":1}}],[\"folder\",{\"1\":{\"0\":1}}],[\"fifo\",{\"1\":{\"574\":1}}],[\"filter\",{\"1\":{\"491\":1}}],[\"filename\",{\"1\":{\"17\":13}}],[\"findmode\",{\"1\":{\"342\":1}}],[\"find\",{\"1\":{\"338\":1,\"346\":1}}],[\"final\",{\"1\":{\"22\":1,\"27\":1,\"478\":3,\"493\":1,\"494\":1,\"495\":1,\"564\":2,\"565\":2,\"566\":3}}],[\"first=cur\",{\"1\":{\"268\":1}}],[\"firstindex\",{\"1\":{\"62\":2}}],[\"first\",{\"1\":{\"62\":2,\"169\":4,\"171\":8,\"268\":4,\"270\":4,\"528\":2,\"564\":2,\"565\":1,\"566\":1,\"567\":2,\"583\":6}}],[\"fetch\",{\"1\":{\"0\":1}}],[\"|=\",{\"1\":{\"494\":5}}],[\"|s|\",{\"1\":{\"315\":1}}],[\"||\",{\"1\":{\"70\":3,\"72\":2,\"92\":2,\"95\":1,\"132\":2,\"141\":1,\"191\":1,\"223\":1,\"263\":1,\"270\":1,\"362\":1,\"388\":1,\"437\":1,\"446\":1,\"449\":1,\"451\":1,\"534\":1,\"543\":1,\"583\":1}}],[\"|\",{\"1\":{\"0\":2}}],[\"安装依赖\",{\"1\":{\"0\":1}}],[\"visualize\",{\"1\":{\"543\":1}}],[\"view\",{\"1\":{\"175\":1}}],[\"v\",{\"1\":{\"71\":3,\"72\":8,\"334\":6,\"528\":2}}],[\"val+root2\",{\"1\":{\"386\":1}}],[\"val==val\",{\"1\":{\"211\":1}}],[\"validate\",{\"1\":{\"432\":1}}],[\"valid\",{\"1\":{\"186\":1,\"273\":1}}],[\"value开始递归\",{\"1\":{\"437\":1}}],[\"value到最大值long\",{\"1\":{\"437\":1}}],[\"valueof\",{\"1\":{\"371\":1}}],[\"value是和出现的次数\",{\"1\":{\"333\":1}}],[\"value\",{\"1\":{\"104\":1,\"232\":2,\"346\":1,\"353\":1,\"359\":1,\"361\":1,\"362\":1,\"436\":1,\"437\":2,\"456\":5,\"457\":10,\"458\":8,\"461\":1,\"462\":1,\"491\":3}}],[\"val\",{\"1\":{\"67\":1,\"69\":6,\"70\":9,\"72\":2,\"77\":1,\"100\":1,\"109\":2,\"113\":7,\"118\":2,\"121\":7,\"128\":1,\"132\":2,\"167\":1,\"171\":7,\"176\":1,\"180\":1,\"182\":1,\"205\":8,\"206\":1,\"208\":12,\"211\":9,\"216\":1,\"220\":7,\"244\":1,\"246\":7,\"248\":7,\"261\":2,\"263\":2,\"266\":1,\"270\":7,\"283\":11,\"285\":1,\"287\":2,\"324\":1,\"326\":1,\"339\":1,\"342\":18,\"347\":1,\"351\":2,\"353\":1,\"358\":1,\"361\":9,\"362\":2,\"384\":1,\"386\":8,\"388\":2,\"393\":6,\"394\":7,\"396\":12,\"412\":9,\"416\":15,\"419\":13,\"433\":1,\"434\":2,\"436\":9,\"437\":4,\"491\":2,\"517\":2,\"525\":1,\"526\":1,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"543\":6,\"562\":2,\"579\":1,\"583\":2}}],[\"void\",{\"1\":{\"17\":6,\"28\":1,\"33\":1,\"43\":1,\"48\":14,\"153\":2,\"182\":1,\"236\":1,\"239\":1,\"248\":1,\"253\":1,\"256\":2,\"296\":1,\"326\":1,\"342\":1,\"351\":1,\"359\":1,\"361\":1,\"371\":1,\"412\":4,\"416\":4,\"419\":4,\"446\":1,\"449\":1,\"451\":1,\"452\":1,\"453\":2,\"454\":1,\"455\":2,\"456\":1,\"458\":1,\"471\":1,\"484\":3,\"485\":2,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"564\":1,\"565\":1,\"574\":1}}],[\"vuepress\",{\"1\":{\"0\":2}}],[\"version\",{\"1\":{\"0\":1}}],[\"v4\",{\"1\":{\"0\":4}}],[\"j+1\",{\"1\":{\"450\":1}}],[\"j++\",{\"1\":{\"380\":1,\"446\":1,\"449\":1,\"453\":2,\"454\":1,\"456\":1,\"458\":1}}],[\"j代表列\",{\"1\":{\"380\":1}}],[\"j\",{\"1\":{\"137\":4,\"139\":8,\"141\":12,\"150\":1,\"151\":5,\"331\":3,\"380\":7,\"446\":10,\"449\":4,\"450\":3,\"451\":7,\"453\":4,\"454\":6,\"456\":5,\"458\":4}}],[\"java\",{\"1\":{\"49\":1,\"62\":2,\"92\":2,\"132\":2,\"141\":2,\"149\":1,\"151\":2,\"153\":1,\"162\":2,\"171\":2,\"191\":2,\"200\":2,\"208\":2,\"220\":2,\"232\":2,\"239\":2,\"256\":2,\"263\":2,\"270\":2,\"278\":2,\"287\":2,\"296\":2,\"306\":2,\"315\":2,\"334\":2,\"342\":2,\"361\":2,\"371\":2,\"380\":2,\"388\":2,\"396\":2,\"405\":1,\"416\":2,\"428\":2,\"486\":1,\"511\":1,\"569\":1,\"573\":2,\"574\":6,\"583\":2},\"2\":{\"488\":1,\"498\":1}}],[\"jamesives\",{\"1\":{\"0\":1}}],[\"jdk1\",{\"1\":{\"490\":2}}],[\"jdk\",{\"0\":{\"49\":1}}],[\"join\",{\"1\":{\"149\":1}}],[\"journaldev\",{\"1\":{\"26\":1}}],[\"jobs\",{\"1\":{\"0\":1}}],[\"js\",{\"1\":{\"0\":1}}],[\"n叉树的层序遍历\",{\"1\":{\"544\":1}}],[\"n−2\",{\"1\":{\"491\":1}}],[\"n−1\",{\"1\":{\"130\":1,\"426\":1,\"491\":2}}],[\"n皇后\",{\"1\":{\"470\":1}}],[\"n+m\",{\"1\":{\"443\":5}}],[\"n+1\",{\"1\":{\"111\":1,\"169\":1,\"170\":1,\"248\":1,\"526\":1}}],[\"n^2\",{\"1\":{\"443\":3}}],[\"n1\",{\"1\":{\"386\":3}}],[\"nagaram\",{\"1\":{\"274\":1}}],[\"name\",{\"1\":{\"0\":7,\"33\":4}}],[\"n个数按一定规则全排列\",{\"1\":{\"470\":1}}],[\"n个数里面按一定规则找出k个数的集合\",{\"1\":{\"470\":1}}],[\"n个正整数的数组和一个正整数\",{\"1\":{\"228\":1}}],[\"n个\",{\"1\":{\"191\":1}}],[\"nth\",{\"1\":{\"166\":1}}],[\"n2\",{\"1\":{\"141\":2,\"334\":2,\"380\":1,\"386\":3,\"507\":1}}],[\"nlogn\",{\"1\":{\"139\":1,\"141\":1,\"162\":1,\"443\":6}}],[\"n3+nlogn\",{\"1\":{\"162\":1}}],[\"n3\",{\"1\":{\"139\":1,\"162\":3}}],[\"nested\",{\"1\":{\"478\":1}}],[\"next=pre\",{\"1\":{\"219\":1}}],[\"next=prev\",{\"1\":{\"211\":1}}],[\"next=head\",{\"1\":{\"211\":1}}],[\"next=cur\",{\"1\":{\"207\":1,\"219\":1}}],[\"next\",{\"1\":{\"108\":1,\"109\":6,\"111\":7,\"112\":2,\"113\":10,\"117\":1,\"118\":6,\"120\":1,\"121\":5,\"123\":7,\"128\":1,\"132\":9,\"171\":12,\"207\":2,\"208\":11,\"210\":1,\"211\":10,\"219\":2,\"220\":8,\"223\":5,\"268\":7,\"270\":17,\"412\":2,\"416\":21,\"419\":15,\"562\":1,\"564\":1,\"565\":1,\"566\":8,\"567\":2,\"583\":4}}],[\"newcapacity\",{\"1\":{\"484\":6,\"485\":7}}],[\"newnode\",{\"1\":{\"416\":10,\"564\":4,\"565\":4}}],[\"new\",{\"1\":{\"17\":2,\"20\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"33\":1,\"36\":1,\"38\":2,\"43\":4,\"48\":2,\"62\":3,\"72\":1,\"83\":2,\"92\":2,\"95\":2,\"121\":1,\"123\":1,\"141\":2,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":2,\"182\":1,\"191\":1,\"236\":1,\"239\":2,\"248\":1,\"253\":1,\"256\":3,\"270\":1,\"278\":1,\"306\":4,\"315\":1,\"324\":3,\"326\":2,\"334\":1,\"342\":2,\"351\":1,\"353\":2,\"362\":1,\"380\":1,\"386\":1,\"388\":1,\"412\":1,\"416\":5,\"419\":5,\"428\":1,\"453\":1,\"456\":1,\"457\":1,\"458\":1,\"480\":2,\"484\":1,\"486\":5,\"491\":5,\"525\":2,\"526\":3,\"527\":2,\"533\":2,\"534\":2,\"535\":2,\"537\":6,\"544\":9,\"564\":1,\"565\":1,\"574\":1}}],[\"n\",{\"0\":{\"166\":1,\"318\":1,\"319\":1,\"550\":1},\"1\":{\"58\":1,\"62\":3,\"70\":3,\"72\":4,\"81\":4,\"83\":4,\"92\":3,\"95\":4,\"104\":3,\"111\":1,\"113\":2,\"121\":4,\"123\":2,\"130\":2,\"132\":2,\"141\":1,\"149\":4,\"151\":4,\"153\":6,\"158\":2,\"162\":12,\"167\":5,\"169\":1,\"171\":7,\"180\":5,\"182\":3,\"191\":3,\"196\":5,\"198\":4,\"200\":10,\"208\":2,\"211\":2,\"220\":2,\"223\":4,\"228\":3,\"232\":5,\"239\":4,\"246\":4,\"248\":4,\"253\":2,\"256\":5,\"263\":6,\"270\":2,\"278\":2,\"287\":2,\"292\":4,\"295\":1,\"296\":3,\"306\":1,\"315\":2,\"319\":1,\"320\":1,\"322\":2,\"324\":5,\"326\":2,\"331\":7,\"334\":1,\"342\":3,\"351\":3,\"353\":5,\"361\":3,\"370\":1,\"371\":8,\"376\":7,\"378\":2,\"380\":8,\"396\":4,\"401\":2,\"405\":1,\"416\":4,\"419\":3,\"424\":1,\"428\":2,\"436\":4,\"443\":1,\"445\":1,\"446\":3,\"449\":4,\"461\":3,\"476\":3,\"494\":14,\"501\":1,\"507\":1,\"526\":7,\"527\":3,\"531\":5,\"550\":3,\"568\":1,\"579\":4}}],[\"num<=tar\",{\"1\":{\"378\":1}}],[\"num\",{\"1\":{\"285\":1,\"287\":3,\"458\":4,\"491\":2}}],[\"number\",{\"1\":{\"195\":1}}],[\"nums4\",{\"1\":{\"331\":8}}],[\"nums3\",{\"1\":{\"331\":8}}],[\"nums2\",{\"1\":{\"301\":5,\"306\":2,\"331\":8}}],[\"nums1\",{\"1\":{\"301\":5,\"306\":2,\"331\":8}}],[\"numsr\",{\"1\":{\"228\":2}}],[\"numsl+1\",{\"1\":{\"228\":1}}],[\"numsl\",{\"1\":{\"228\":1}}],[\"nums\",{\"1\":{\"58\":8,\"62\":5,\"137\":21,\"139\":8,\"141\":23,\"158\":13,\"162\":26,\"228\":5,\"232\":4,\"283\":20,\"285\":2,\"287\":3,\"401\":8,\"403\":3,\"405\":4,\"406\":7,\"407\":4,\"424\":6,\"428\":17,\"503\":9,\"504\":15,\"505\":9}}],[\"null\",{\"1\":{\"17\":1,\"24\":1,\"25\":1,\"26\":2,\"33\":1,\"43\":1,\"67\":2,\"70\":5,\"72\":4,\"77\":3,\"81\":1,\"83\":3,\"92\":1,\"95\":1,\"100\":6,\"102\":1,\"104\":5,\"109\":2,\"113\":2,\"118\":3,\"120\":1,\"121\":5,\"123\":5,\"128\":2,\"130\":1,\"132\":7,\"141\":1,\"171\":3,\"176\":3,\"180\":3,\"182\":1,\"208\":3,\"220\":3,\"223\":3,\"236\":3,\"244\":1,\"246\":1,\"248\":3,\"253\":3,\"261\":6,\"263\":9,\"270\":4,\"320\":14,\"324\":1,\"326\":1,\"339\":1,\"342\":3,\"347\":1,\"351\":4,\"353\":3,\"358\":2,\"361\":3,\"362\":4,\"384\":4,\"385\":2,\"386\":2,\"387\":6,\"388\":1,\"393\":1,\"394\":2,\"396\":2,\"412\":5,\"416\":5,\"418\":1,\"419\":3,\"433\":2,\"436\":1,\"437\":1,\"446\":1,\"449\":1,\"451\":1,\"493\":1,\"525\":2,\"526\":3,\"527\":1,\"529\":1,\"530\":1,\"531\":1,\"533\":3,\"534\":3,\"535\":3,\"537\":9,\"543\":8,\"557\":1,\"564\":2,\"565\":2,\"566\":5,\"567\":4,\"579\":3,\"581\":1,\"582\":1,\"583\":6}}],[\"not\",{\"1\":{\"586\":1}}],[\"note\",{\"1\":{\"310\":1}}],[\"none\",{\"1\":{\"540\":2}}],[\"non\",{\"1\":{\"478\":1}}],[\"nojekyll\",{\"1\":{\"0\":1}}],[\"node<>\",{\"1\":{\"564\":1,\"565\":1}}],[\"node<e>\",{\"1\":{\"564\":2,\"565\":2,\"566\":3,\"567\":2}}],[\"nodes\",{\"1\":{\"265\":1,\"358\":1}}],[\"node\",{\"1\":{\"0\":4,\"67\":1,\"70\":1,\"77\":1,\"83\":5,\"100\":1,\"108\":1,\"109\":5,\"111\":2,\"113\":15,\"117\":1,\"118\":5,\"120\":4,\"121\":23,\"123\":6,\"128\":1,\"166\":1,\"167\":1,\"176\":1,\"180\":6,\"205\":2,\"216\":1,\"244\":1,\"246\":1,\"247\":3,\"248\":7,\"261\":2,\"263\":1,\"266\":1,\"324\":5,\"326\":5,\"339\":1,\"342\":1,\"347\":1,\"353\":6,\"358\":1,\"361\":1,\"384\":1,\"386\":1,\"393\":1,\"396\":1,\"414\":1,\"416\":17,\"419\":34,\"433\":1,\"436\":1,\"437\":8,\"525\":6,\"526\":6,\"527\":5,\"533\":6,\"535\":6,\"537\":27,\"543\":12,\"562\":1,\"579\":1}}],[\"skipb\",{\"1\":{\"579\":6}}],[\"skipa\",{\"1\":{\"579\":6}}],[\"sky\",{\"1\":{\"146\":2}}],[\"shellsort\",{\"1\":{\"452\":1}}],[\"sheep2\",{\"1\":{\"33\":3}}],[\"sheep1\",{\"1\":{\"33\":5}}],[\"sheep\",{\"1\":{\"33\":6}}],[\"squares\",{\"1\":{\"423\":1}}],[\"swapnum\",{\"1\":{\"455\":3}}],[\"swapped\",{\"1\":{\"446\":4}}],[\"swappairs\",{\"1\":{\"270\":1}}],[\"swap\",{\"1\":{\"265\":1,\"574\":3}}],[\"swapleftright\",{\"1\":{\"248\":2}}],[\"sz\",{\"1\":{\"167\":3,\"419\":2}}],[\"s+\",{\"1\":{\"149\":1}}],[\"spiral\",{\"1\":{\"375\":1}}],[\"split\",{\"1\":{\"148\":1,\"149\":1}}],[\"space\",{\"1\":{\"0\":1}}],[\"slow将到达链表中的一半\",{\"1\":{\"200\":1}}],[\"slowrunner\",{\"1\":{\"200\":4}}],[\"slow在链表中前进\",{\"1\":{\"198\":1}}],[\"slow\",{\"1\":{\"130\":8,\"132\":12,\"198\":1,\"200\":1}}],[\"sb\",{\"1\":{\"92\":3,\"153\":20}}],[\"s\",{\"1\":{\"88\":4,\"92\":5,\"95\":6,\"146\":9,\"149\":4,\"150\":1,\"151\":7,\"153\":7,\"187\":6,\"191\":4,\"274\":8,\"276\":3,\"278\":4,\"292\":5,\"295\":2,\"296\":6,\"315\":1,\"367\":5,\"371\":3,\"491\":1}}],[\"so\",{\"1\":{\"484\":1,\"485\":1}}],[\"sortedindex++\",{\"1\":{\"456\":1}}],[\"sortedindex\",{\"1\":{\"456\":1}}],[\"sortedsquares\",{\"1\":{\"428\":1}}],[\"sorted\",{\"1\":{\"423\":1}}],[\"sort\",{\"1\":{\"141\":1,\"162\":1,\"283\":1}}],[\"solution\",{\"1\":{\"62\":1,\"70\":1,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":1,\"121\":1,\"123\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":1,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":1,\"211\":1,\"220\":1,\"223\":1,\"232\":1,\"246\":1,\"248\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"353\":1,\"361\":1,\"362\":1,\"371\":1,\"380\":1,\"386\":1,\"388\":1,\"396\":1,\"405\":1,\"428\":1,\"436\":1,\"437\":1,\"526\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"583\":1}}],[\"something\",{\"1\":{\"28\":1,\"43\":1}}],[\"such\",{\"1\":{\"256\":1,\"416\":1}}],[\"subarray\",{\"1\":{\"227\":1}}],[\"substring\",{\"1\":{\"151\":1}}],[\"submissions\",{\"1\":{\"76\":1,\"145\":1,\"392\":1}}],[\"submodules\",{\"1\":{\"0\":1}}],[\"sumcd\",{\"1\":{\"333\":2}}],[\"sum\",{\"1\":{\"57\":1,\"141\":4,\"162\":4,\"227\":1,\"230\":2,\"232\":4}}],[\"super\",{\"1\":{\"33\":1}}],[\"simplify\",{\"1\":{\"478\":1}}],[\"simplefactory\",{\"1\":{\"54\":1}}],[\"side\",{\"1\":{\"175\":1}}],[\"singly\",{\"1\":{\"132\":1,\"171\":1,\"208\":1,\"211\":1,\"220\":1,\"270\":1,\"583\":1}}],[\"singletonhelper\",{\"1\":{\"27\":3}}],[\"singleton\",{\"1\":{\"26\":1}}],[\"size+1\",{\"1\":{\"484\":1,\"485\":1}}],[\"size++\",{\"1\":{\"416\":3,\"419\":3,\"484\":1,\"564\":1,\"565\":1}}],[\"size\",{\"1\":{\"121\":1,\"180\":1,\"182\":1,\"227\":1,\"236\":1,\"239\":2,\"253\":1,\"306\":1,\"324\":3,\"326\":1,\"342\":1,\"351\":1,\"353\":1,\"388\":1,\"415\":1,\"416\":7,\"419\":4,\"455\":11,\"478\":1,\"482\":2,\"484\":3,\"485\":3,\"486\":3,\"491\":2,\"526\":1,\"527\":1,\"566\":1,\"574\":5}}],[\"size=8192\",{\"1\":{\"0\":1}}],[\"symmetric\",{\"1\":{\"66\":1}}],[\"synchronized\",{\"0\":{\"25\":1},\"1\":{\"25\":1,\"26\":1}}],[\"system\",{\"1\":{\"17\":2,\"33\":2}}],[\"selectionsort\",{\"1\":{\"449\":1}}],[\"searchbst\",{\"1\":{\"394\":1,\"396\":1}}],[\"search\",{\"1\":{\"338\":1,\"392\":2,\"400\":1,\"405\":1,\"406\":1,\"407\":1,\"432\":1,\"505\":1,\"522\":1,\"528\":1}}],[\"secod\",{\"1\":{\"268\":1}}],[\"second=cur\",{\"1\":{\"268\":1}}],[\"second\",{\"1\":{\"169\":3,\"171\":6,\"268\":3,\"270\":4,\"583\":5}}],[\"set<string>\",{\"1\":{\"491\":2}}],[\"set\",{\"1\":{\"351\":1,\"574\":1}}],[\"setcharat\",{\"1\":{\"153\":2}}],[\"setup\",{\"1\":{\"0\":2}}],[\"service\",{\"1\":{\"16\":6}}],[\"serviceinterface\",{\"1\":{\"16\":1}}],[\"st\",{\"1\":{\"537\":36}}],[\"statistics\",{\"1\":{\"491\":3}}],[\"staticblocksingleton\",{\"1\":{\"23\":5}}],[\"static\",{\"1\":{\"17\":1,\"22\":2,\"23\":3,\"24\":2,\"25\":2,\"26\":2,\"27\":3,\"28\":1,\"33\":1,\"43\":1,\"48\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":3,\"456\":2,\"457\":2,\"458\":5,\"478\":3,\"484\":1,\"491\":5,\"493\":1,\"494\":1,\"495\":1}}],[\"stack<>\",{\"1\":{\"533\":1,\"534\":1,\"535\":1,\"537\":3}}],[\"stack<treenode>\",{\"1\":{\"533\":1,\"534\":1,\"535\":1,\"537\":3}}],[\"stacks\",{\"1\":{\"252\":1}}],[\"stack\",{\"1\":{\"235\":1,\"511\":1,\"513\":1,\"533\":6,\"534\":4,\"535\":6,\"543\":14}}],[\"start++\",{\"1\":{\"232\":1,\"491\":1}}],[\"start\",{\"1\":{\"153\":4,\"230\":2,\"231\":1,\"232\":5,\"491\":1}}],[\"strlist\",{\"1\":{\"491\":4}}],[\"str\",{\"1\":{\"491\":7}}],[\"stream\",{\"1\":{\"486\":2,\"491\":3}}],[\"struct\",{\"1\":{\"109\":1,\"118\":1}}],[\"structural\",{\"1\":{\"10\":1}}],[\"stringbuilder\",{\"1\":{\"49\":1,\"92\":2,\"151\":3,\"153\":6}}],[\"string\",{\"1\":{\"17\":6,\"33\":3,\"43\":1,\"48\":1,\"87\":1,\"92\":2,\"95\":3,\"145\":1,\"149\":3,\"151\":2,\"153\":3,\"191\":1,\"278\":2,\"291\":1,\"315\":2,\"366\":1,\"371\":3,\"486\":8,\"491\":3}}],[\"steps\",{\"1\":{\"0\":1}}],[\"src\",{\"1\":{\"0\":2}}],[\"white\",{\"1\":{\"532\":1}}],[\"while\",{\"1\":{\"72\":1,\"83\":1,\"92\":1,\"113\":2,\"121\":1,\"123\":2,\"132\":2,\"141\":5,\"151\":3,\"153\":6,\"162\":3,\"171\":1,\"180\":1,\"200\":2,\"208\":2,\"211\":1,\"220\":1,\"232\":2,\"239\":2,\"248\":1,\"256\":1,\"270\":1,\"296\":1,\"324\":2,\"353\":1,\"362\":1,\"371\":1,\"380\":1,\"388\":1,\"396\":1,\"405\":1,\"406\":1,\"407\":1,\"416\":1,\"428\":1,\"451\":1,\"452\":2,\"453\":3,\"456\":1,\"503\":3,\"504\":2,\"505\":1,\"525\":1,\"526\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"543\":3,\"574\":2,\"583\":1}}],[\"www\",{\"1\":{\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2}}],[\"wordlist\",{\"1\":{\"149\":3}}],[\"words\",{\"1\":{\"145\":1}}],[\"world\",{\"1\":{\"146\":2}}],[\"window\",{\"1\":{\"544\":9}}],[\"windows里的快捷方式\",{\"1\":{\"15\":1}}],[\"win\",{\"1\":{\"484\":1,\"485\":1}}],[\"will\",{\"1\":{\"256\":1,\"416\":1}}],[\"with\",{\"1\":{\"0\":3,\"43\":1,\"482\":1,\"574\":1}}],[\"write\",{\"1\":{\"0\":1}}],[\"until\",{\"1\":{\"574\":1}}],[\"unlink\",{\"1\":{\"566\":1,\"567\":2}}],[\"unicode\",{\"1\":{\"274\":1}}],[\"util\",{\"1\":{\"388\":2,\"486\":1,\"574\":6}}],[\"usually\",{\"1\":{\"484\":1,\"485\":1}}],[\"using\",{\"1\":{\"235\":1,\"252\":1}}],[\"uses\",{\"1\":{\"0\":4}}],[\"u\",{\"1\":{\"71\":3,\"72\":8,\"326\":3,\"334\":6}}],[\"uml\",{\"0\":{\"16\":1,\"32\":1,\"37\":1,\"42\":1,\"47\":1,\"53\":1}}],[\"ubuntu\",{\"1\":{\"0\":1}}],[\"c=0\",{\"1\":{\"583\":1}}],[\"cs\",{\"1\":{\"371\":8}}],[\"cycle\",{\"1\":{\"127\":1}}],[\"curcount++\",{\"1\":{\"342\":1}}],[\"curcount\",{\"1\":{\"340\":2,\"342\":7}}],[\"cur=dummy\",{\"1\":{\"268\":1}}],[\"cur=next\",{\"1\":{\"219\":1}}],[\"currentindex\",{\"1\":{\"574\":15}}],[\"current\",{\"1\":{\"450\":1,\"451\":3}}],[\"curr\",{\"1\":{\"220\":7}}],[\"cur\",{\"1\":{\"123\":17,\"207\":1,\"218\":1,\"219\":1,\"268\":3,\"270\":7,\"362\":11,\"419\":18,\"534\":10,\"543\":10}}],[\"chapter\",{\"1\":{\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2}}],[\"charat\",{\"1\":{\"151\":2,\"153\":7,\"278\":2,\"491\":1}}],[\"char\",{\"1\":{\"92\":1,\"95\":3,\"153\":2,\"191\":1,\"296\":2,\"315\":2,\"371\":3,\"491\":1}}],[\"child\",{\"1\":{\"517\":1}}],[\"children\",{\"1\":{\"324\":1,\"326\":1}}],[\"check\",{\"1\":{\"72\":2}}],[\"checkandload\",{\"1\":{\"17\":2}}],[\"checkout\",{\"1\":{\"0\":2}}],[\"create\",{\"1\":{\"543\":1}}],[\"createperson\",{\"1\":{\"48\":2}}],[\"createproduct\",{\"1\":{\"54\":1}}],[\"createproductb\",{\"1\":{\"43\":4}}],[\"createproducta\",{\"1\":{\"43\":4}}],[\"creational\",{\"1\":{\"9\":1}}],[\"c1\",{\"1\":{\"579\":1}}],[\"c1会导致风格会不一致\",{\"1\":{\"41\":1}}],[\"c1是一种风格\",{\"1\":{\"41\":1}}],[\"c类型对象\",{\"1\":{\"41\":1}}],[\"close\",{\"1\":{\"484\":1,\"485\":1}}],[\"clonenotsupportedexception\",{\"1\":{\"33\":1}}],[\"cloneable\",{\"1\":{\"33\":1}}],[\"cloneable接口\",{\"1\":{\"31\":1}}],[\"clone\",{\"1\":{\"33\":4}}],[\"clear\",{\"1\":{\"342\":1}}],[\"client\",{\"1\":{\"43\":1}}],[\"class\",{\"1\":{\"17\":3,\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"26\":2,\"27\":2,\"33\":2,\"38\":2,\"43\":9,\"48\":5,\"54\":4,\"62\":1,\"70\":2,\"72\":1,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":2,\"121\":2,\"123\":1,\"132\":2,\"141\":1,\"149\":1,\"151\":1,\"153\":1,\"162\":1,\"171\":2,\"180\":1,\"182\":1,\"191\":1,\"200\":1,\"208\":2,\"211\":2,\"220\":2,\"223\":1,\"232\":1,\"239\":1,\"246\":2,\"248\":2,\"256\":1,\"263\":2,\"270\":2,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":2,\"351\":1,\"353\":1,\"361\":2,\"362\":1,\"371\":1,\"380\":1,\"386\":2,\"388\":1,\"396\":2,\"405\":1,\"416\":2,\"419\":2,\"428\":1,\"436\":2,\"437\":1,\"478\":1,\"482\":2,\"486\":1,\"517\":1,\"526\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"562\":1,\"583\":2}}],[\"c\",{\"1\":{\"15\":9,\"92\":3,\"93\":1,\"95\":3,\"153\":4,\"158\":4,\"191\":5,\"315\":5,\"333\":1,\"334\":2,\"371\":2,\"479\":1,\"482\":3,\"486\":7,\"581\":5,\"583\":3}}],[\"calculatecapacity\",{\"1\":{\"484\":3}}],[\"called\",{\"1\":{\"256\":1,\"416\":1}}],[\"capacity\",{\"1\":{\"478\":2,\"480\":1,\"481\":1,\"484\":3,\"494\":3}}],[\"cap\",{\"1\":{\"462\":1,\"494\":2}}],[\"canconstruct\",{\"1\":{\"315\":1}}],[\"car\",{\"1\":{\"274\":1}}],[\"ca\",{\"1\":{\"88\":2}}],[\"catch\",{\"1\":{\"23\":2,\"33\":1}}],[\"catalog\",{\"1\":{\"8\":1}}],[\"cache\",{\"1\":{\"0\":1}}],[\"collisionrate\",{\"1\":{\"491\":2}}],[\"collisionratelist\",{\"1\":{\"491\":1}}],[\"collisioncount\",{\"1\":{\"491\":3}}],[\"collectors\",{\"1\":{\"486\":1}}],[\"collect\",{\"1\":{\"486\":1}}],[\"collection\",{\"2\":{\"487\":1,\"497\":1}}],[\"collection<\",{\"1\":{\"479\":1,\"482\":1}}],[\"collections\",{\"1\":{\"149\":1,\"486\":1,\"535\":1}}],[\"copyof\",{\"1\":{\"457\":1,\"458\":1,\"482\":1,\"484\":1,\"485\":1,\"486\":1}}],[\"counter\",{\"1\":{\"458\":4}}],[\"countsort\",{\"1\":{\"456\":1}}],[\"count++\",{\"1\":{\"380\":4}}],[\"count\",{\"1\":{\"380\":2,\"491\":2}}],[\"countab\",{\"1\":{\"334\":5}}],[\"code\",{\"1\":{\"62\":1,\"92\":1,\"132\":1,\"141\":1,\"149\":1,\"151\":1,\"162\":1,\"171\":1,\"191\":1,\"200\":1,\"208\":1,\"220\":1,\"232\":1,\"239\":1,\"256\":1,\"263\":1,\"270\":1,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"334\":1,\"342\":1,\"361\":1,\"371\":1,\"380\":1,\"396\":1,\"405\":1,\"416\":1,\"428\":1,\"485\":2,\"583\":1}}],[\"concurrent\",{\"1\":{\"574\":1}}],[\"concretefactory2\",{\"1\":{\"38\":1,\"43\":1}}],[\"concretefactory1\",{\"1\":{\"38\":1,\"43\":2}}],[\"concreteproduct2\",{\"1\":{\"38\":2}}],[\"concreteproduct1\",{\"1\":{\"38\":2}}],[\"concrete\",{\"1\":{\"32\":1}}],[\"const\",{\"1\":{\"543\":5}}],[\"conscious\",{\"1\":{\"485\":2}}],[\"condition\",{\"1\":{\"503\":1}}],[\"connect\",{\"1\":{\"113\":1,\"121\":1,\"123\":1}}],[\"continue\",{\"1\":{\"72\":1,\"141\":1,\"162\":4,\"457\":1}}],[\"containskey\",{\"1\":{\"62\":1,\"334\":1}}],[\"contents\",{\"1\":{\"0\":1}}],[\"compare\",{\"1\":{\"574\":1}}],[\"compareto\",{\"1\":{\"491\":2}}],[\"comparator\",{\"1\":{\"574\":1}}],[\"comparable\",{\"1\":{\"574\":1}}],[\"common\",{\"1\":{\"260\":1}}],[\"com\",{\"1\":{\"26\":1,\"358\":1,\"519\":1,\"520\":1,\"521\":1,\"522\":1,\"539\":1,\"540\":2}}],[\"corepack\",{\"1\":{\"0\":1}}],[\"cnt\",{\"1\":{\"315\":4}}],[\"cn\",{\"1\":{\"0\":1,\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"14\":1,\"36\":1,\"41\":1,\"46\":1,\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"358\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"564\":1,\"565\":1,\"566\":1,\"567\":1,\"578\":1}}],[\"pivot\",{\"1\":{\"454\":3}}],[\"p=root\",{\"1\":{\"261\":1}}],[\"p\",{\"1\":{\"261\":25,\"263\":3}}],[\"python\",{\"1\":{\"153\":1}}],[\"poppedelement\",{\"1\":{\"574\":2}}],[\"pop\",{\"1\":{\"236\":7,\"239\":2,\"253\":7,\"255\":2,\"256\":5,\"511\":2,\"533\":1,\"534\":1,\"535\":1,\"537\":9,\"543\":3,\"574\":1}}],[\"populating\",{\"1\":{\"108\":1,\"117\":1}}],[\"postorderiteratorresult\",{\"1\":{\"543\":4}}],[\"postorderresult\",{\"1\":{\"543\":2}}],[\"postordertraversal\",{\"1\":{\"535\":1,\"537\":1,\"543\":2}}],[\"postorder\",{\"1\":{\"531\":3}}],[\"pos++\",{\"1\":{\"458\":1}}],[\"pos\",{\"1\":{\"128\":7,\"458\":1}}],[\"pointers\",{\"1\":{\"108\":1,\"117\":1}}],[\"pollfirst\",{\"1\":{\"121\":1,\"248\":1,\"324\":1,\"353\":1,\"362\":1}}],[\"polllast\",{\"1\":{\"92\":1,\"191\":1}}],[\"poll\",{\"1\":{\"72\":2,\"92\":1,\"120\":1,\"180\":1,\"239\":3,\"525\":1,\"526\":1}}],[\"peek\",{\"1\":{\"236\":1,\"239\":1,\"253\":7,\"255\":1,\"256\":4,\"537\":6}}],[\"peeklast\",{\"1\":{\"92\":1}}],[\"persondirector\",{\"1\":{\"48\":6}}],[\"personthinbuilder\",{\"1\":{\"48\":2}}],[\"personfatbuilder\",{\"1\":{\"48\":1}}],[\"personbuilder\",{\"1\":{\"48\":5}}],[\"permissions\",{\"1\":{\"0\":1}}],[\"pb\",{\"1\":{\"48\":8}}],[\"png\",{\"1\":{\"17\":1}}],[\"pnpm\",{\"1\":{\"0\":5}}],[\"put\",{\"1\":{\"62\":1,\"334\":1,\"491\":1}}],[\"public\",{\"1\":{\"17\":6,\"22\":2,\"23\":2,\"24\":2,\"25\":2,\"26\":2,\"27\":2,\"28\":2,\"33\":4,\"38\":9,\"43\":10,\"48\":20,\"54\":6,\"62\":1,\"70\":3,\"72\":2,\"81\":1,\"83\":1,\"92\":1,\"95\":1,\"104\":1,\"113\":8,\"121\":8,\"123\":1,\"132\":2,\"141\":1,\"149\":1,\"151\":1,\"153\":4,\"162\":1,\"171\":2,\"180\":1,\"182\":1,\"191\":1,\"200\":2,\"208\":2,\"211\":2,\"220\":2,\"223\":1,\"232\":1,\"239\":5,\"246\":2,\"248\":3,\"256\":5,\"263\":2,\"270\":2,\"278\":1,\"287\":1,\"296\":1,\"306\":1,\"315\":1,\"324\":1,\"326\":1,\"334\":1,\"342\":3,\"351\":2,\"353\":1,\"359\":1,\"361\":3,\"362\":1,\"371\":1,\"380\":1,\"385\":1,\"386\":2,\"388\":1,\"394\":1,\"396\":2,\"405\":1,\"406\":1,\"407\":1,\"416\":7,\"419\":6,\"428\":1,\"436\":2,\"437\":1,\"446\":1,\"449\":1,\"451\":1,\"452\":1,\"453\":1,\"454\":1,\"455\":3,\"456\":1,\"458\":1,\"479\":3,\"480\":1,\"481\":1,\"482\":1,\"484\":1,\"491\":5,\"494\":1,\"503\":1,\"505\":1,\"526\":2,\"527\":2,\"533\":1,\"534\":1,\"535\":1,\"537\":3,\"567\":1,\"574\":2,\"583\":3}}],[\"push\",{\"1\":{\"0\":1,\"236\":8,\"239\":2,\"253\":8,\"255\":1,\"256\":6,\"511\":2,\"533\":3,\"534\":1,\"535\":3,\"537\":15,\"543\":11}}],[\"preorderiteratorresult\",{\"1\":{\"543\":4}}],[\"preorderresult\",{\"1\":{\"543\":2}}],[\"preordertraversal\",{\"1\":{\"533\":1,\"537\":1,\"543\":2}}],[\"preorder\",{\"1\":{\"529\":3}}],[\"preindex\",{\"1\":{\"452\":7}}],[\"pre=cur\",{\"1\":{\"219\":1}}],[\"prevent\",{\"1\":{\"503\":1}}],[\"prev的\",{\"1\":{\"434\":1}}],[\"prev=prev\",{\"1\":{\"211\":1}}],[\"prev=dummynode\",{\"1\":{\"211\":1}}],[\"prev\",{\"1\":{\"208\":7,\"211\":3,\"220\":5,\"340\":4,\"342\":6,\"359\":3,\"361\":4,\"412\":1,\"419\":17,\"434\":4,\"436\":3,\"564\":1,\"566\":8}}],[\"pre\",{\"1\":{\"113\":5,\"120\":3,\"121\":5,\"123\":10,\"218\":1,\"362\":4}}],[\"property\",{\"1\":{\"574\":1}}],[\"protected\",{\"1\":{\"458\":1}}],[\"prototypepatterndemo\",{\"1\":{\"33\":1}}],[\"prototype\",{\"1\":{\"32\":2,\"33\":4}}],[\"problems\",{\"1\":{\"57\":1,\"66\":1,\"76\":1,\"87\":1,\"99\":1,\"108\":1,\"117\":1,\"127\":1,\"136\":1,\"145\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"195\":1,\"204\":1,\"215\":1,\"227\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"282\":1,\"291\":1,\"300\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"358\":1,\"366\":1,\"375\":1,\"383\":1,\"392\":1,\"400\":1,\"411\":1,\"423\":1,\"432\":1,\"578\":1}}],[\"product3\",{\"1\":{\"54\":1}}],[\"product2\",{\"1\":{\"54\":1}}],[\"product1\",{\"1\":{\"54\":1}}],[\"productb1\",{\"1\":{\"43\":2}}],[\"productb\",{\"1\":{\"43\":8}}],[\"producta2\",{\"1\":{\"43\":2}}],[\"producta1\",{\"1\":{\"43\":2}}],[\"producta\",{\"1\":{\"43\":9}}],[\"product\",{\"1\":{\"38\":6,\"54\":5}}],[\"proxypatterndemo\",{\"1\":{\"17\":1}}],[\"proxyimage\",{\"1\":{\"17\":3}}],[\"proxy\",{\"1\":{\"14\":2,\"16\":2}}],[\"priorityqueue\",{\"1\":{\"574\":3}}],[\"printstacktrace\",{\"1\":{\"33\":1}}],[\"println\",{\"1\":{\"17\":2,\"33\":2}}],[\"private\",{\"1\":{\"17\":5,\"22\":2,\"23\":2,\"24\":2,\"25\":2,\"26\":2,\"27\":3,\"33\":1,\"48\":1,\"182\":1,\"256\":1,\"436\":1,\"437\":1,\"453\":1,\"454\":1,\"456\":1,\"457\":2,\"458\":3,\"478\":5,\"484\":4,\"485\":2,\"491\":1,\"527\":1}}],[\"pairs\",{\"1\":{\"265\":1}}],[\"parent\",{\"1\":{\"574\":1}}],[\"parentindex\",{\"1\":{\"574\":5}}],[\"parentheses\",{\"1\":{\"186\":1}}],[\"parallelstream\",{\"1\":{\"491\":1}}],[\"param\",{\"1\":{\"256\":3,\"416\":1,\"455\":7,\"456\":2,\"457\":4,\"458\":5}}],[\"partition\",{\"1\":{\"454\":2}}],[\"partitionindex\",{\"1\":{\"454\":3}}],[\"package\",{\"1\":{\"26\":1}}],[\"patterns\",{\"1\":{\"8\":1,\"9\":2,\"10\":2,\"11\":2,\"14\":1,\"36\":1,\"41\":1,\"46\":1}}],[\"pages\",{\"1\":{\"0\":4}}],[\"page\",{\"1\":{\"0\":1}}],[\"部署文档\",{\"1\":{\"0\":3}}],[\"部署到\",{\"1\":{\"0\":1}}],[\"部署到ssh\",{\"1\":{\"0\":1}}],[\"gray\",{\"1\":{\"532\":1}}],[\"grow\",{\"1\":{\"484\":3,\"485\":4}}],[\"gap\",{\"1\":{\"452\":8}}],[\"generatematrix\",{\"1\":{\"380\":1}}],[\"getintersectionnode\",{\"1\":{\"583\":1}}],[\"getinstanceusingdoublelocking\",{\"1\":{\"26\":1}}],[\"getinstance\",{\"1\":{\"22\":1,\"23\":1,\"24\":1,\"25\":2,\"27\":2}}],[\"getclass\",{\"1\":{\"482\":1}}],[\"getmaxdigit\",{\"1\":{\"458\":2}}],[\"getmaxvalue\",{\"1\":{\"456\":2,\"458\":2}}],[\"getminimumdifference\",{\"1\":{\"361\":1,\"362\":1}}],[\"getnumlength\",{\"1\":{\"458\":2}}],[\"getnode\",{\"1\":{\"414\":1,\"416\":4,\"419\":4}}],[\"getnext\",{\"1\":{\"198\":2,\"200\":5}}],[\"getordefault\",{\"1\":{\"334\":1}}],[\"get\",{\"1\":{\"62\":1,\"326\":1,\"334\":1,\"342\":1,\"351\":1,\"412\":6,\"416\":3,\"419\":2,\"491\":2,\"527\":1,\"574\":8}}],[\"getter和setter方法\",{\"1\":{\"33\":1}}],[\"good\",{\"1\":{\"146\":2}}],[\"git\",{\"1\":{\"0\":1}}],[\"github\",{\"1\":{\"0\":2}}],[\"gh\",{\"1\":{\"0\":3}}],[\"文件\",{\"1\":{\"0\":1}}],[\"14\",{\"1\":{\"320\":2}}],[\"142\",{\"0\":{\"126\":1,\"127\":1},\"1\":{\"553\":1}}],[\"13\",{\"1\":{\"320\":2}}],[\"1<\",{\"1\":{\"220\":1}}],[\"199\",{\"0\":{\"174\":1,\"175\":1},\"1\":{\"544\":1}}],[\"19\",{\"0\":{\"165\":1,\"166\":1},\"1\":{\"196\":1,\"458\":1,\"550\":1}}],[\"18\",{\"0\":{\"156\":1,\"157\":1}}],[\"121\",{\"1\":{\"424\":1}}],[\"12\",{\"1\":{\"109\":1,\"196\":2,\"320\":2,\"358\":1,\"401\":2}}],[\"107\",{\"1\":{\"544\":1}}],[\"102\",{\"1\":{\"544\":1}}],[\"109\",{\"1\":{\"158\":4,\"228\":1}}],[\"105\",{\"1\":{\"100\":1,\"228\":2,\"358\":1}}],[\"1047\",{\"0\":{\"86\":1,\"87\":1}}],[\"104\",{\"0\":{\"75\":1,\"76\":1},\"1\":{\"187\":1,\"358\":1,\"517\":1,\"544\":1}}],[\"1002\",{\"1\":{\"306\":3}}],[\"100\",{\"1\":{\"67\":2,\"77\":2,\"118\":2,\"167\":1,\"176\":3,\"196\":1,\"236\":1,\"244\":3,\"253\":1,\"266\":2,\"283\":2,\"424\":3}}],[\"10000\",{\"1\":{\"401\":1}}],[\"1000\",{\"1\":{\"67\":1,\"100\":2,\"109\":2,\"301\":2,\"320\":1,\"412\":1}}],[\"101\",{\"0\":{\"65\":1,\"66\":1}}],[\"10\",{\"1\":{\"58\":5,\"77\":1,\"128\":3,\"137\":2,\"146\":1,\"200\":2,\"205\":1,\"261\":3,\"274\":1,\"292\":1,\"311\":1,\"320\":3,\"339\":3,\"347\":1,\"367\":2,\"384\":2,\"393\":2,\"424\":4,\"433\":1,\"458\":6,\"478\":1,\"484\":3,\"485\":1,\"486\":1,\"579\":2}}],[\"117\",{\"0\":{\"116\":1,\"117\":1},\"1\":{\"544\":1}}],[\"116\",{\"0\":{\"107\":1,\"108\":1},\"1\":{\"544\":1}}],[\"111\",{\"0\":{\"98\":1,\"99\":1},\"1\":{\"517\":1,\"544\":1}}],[\"11\",{\"1\":{\"58\":1,\"228\":1,\"320\":2,\"424\":1,\"485\":1}}],[\"151\",{\"0\":{\"144\":1,\"145\":1}}],[\"15\",{\"0\":{\"135\":1,\"136\":1},\"1\":{\"0\":1,\"58\":1,\"77\":1,\"100\":1,\"160\":1}}],[\"1\",{\"0\":{\"56\":1,\"57\":1,\"68\":1,\"79\":1,\"90\":1,\"119\":1,\"148\":1,\"169\":1,\"285\":1,\"322\":1,\"324\":1,\"349\":1,\"503\":1},\"1\":{\"0\":1,\"58\":6,\"67\":4,\"70\":1,\"72\":1,\"77\":2,\"79\":1,\"80\":1,\"81\":1,\"88\":1,\"95\":2,\"100\":1,\"104\":2,\"109\":4,\"113\":1,\"118\":3,\"123\":2,\"128\":9,\"130\":2,\"132\":2,\"137\":22,\"139\":1,\"141\":4,\"146\":3,\"151\":3,\"153\":5,\"158\":8,\"162\":12,\"167\":10,\"171\":3,\"176\":5,\"180\":1,\"182\":2,\"187\":2,\"191\":1,\"196\":7,\"198\":2,\"200\":3,\"205\":5,\"208\":1,\"211\":2,\"216\":5,\"220\":4,\"228\":16,\"232\":3,\"236\":3,\"239\":3,\"244\":6,\"246\":1,\"253\":11,\"256\":3,\"261\":8,\"266\":5,\"270\":1,\"274\":2,\"278\":1,\"283\":4,\"285\":2,\"287\":1,\"292\":3,\"295\":1,\"296\":3,\"301\":4,\"311\":2,\"320\":5,\"324\":1,\"326\":1,\"331\":17,\"334\":2,\"339\":3,\"340\":4,\"342\":3,\"347\":6,\"351\":2,\"358\":5,\"367\":3,\"369\":1,\"370\":1,\"371\":4,\"376\":6,\"380\":4,\"384\":5,\"385\":2,\"386\":1,\"387\":4,\"393\":7,\"401\":7,\"405\":2,\"406\":2,\"407\":5,\"412\":13,\"416\":8,\"419\":8,\"424\":6,\"428\":2,\"433\":5,\"443\":4,\"446\":6,\"449\":3,\"450\":1,\"451\":5,\"453\":3,\"454\":6,\"455\":2,\"456\":1,\"457\":3,\"458\":4,\"461\":6,\"475\":1,\"476\":2,\"484\":5,\"485\":5,\"486\":1,\"490\":1,\"491\":2,\"493\":7,\"494\":5,\"501\":1,\"503\":9,\"504\":7,\"505\":9,\"517\":2,\"520\":2,\"527\":3,\"529\":1,\"530\":1,\"531\":1,\"543\":1,\"568\":1,\"574\":8,\"579\":15,\"583\":1}}],[\"16\",{\"1\":{\"0\":1,\"424\":3,\"493\":1,\"494\":1}}],[\"17\",{\"1\":{\"0\":1}}],[\"datatypesize\",{\"1\":{\"475\":1}}],[\"difference\",{\"1\":{\"357\":1}}],[\"displaying\",{\"1\":{\"17\":1}}],[\"display\",{\"1\":{\"17\":6}}],[\"distinct\",{\"1\":{\"491\":1}}],[\"distance\",{\"1\":{\"358\":1}}],[\"dist\",{\"1\":{\"0\":2}}],[\"d互不相同\",{\"1\":{\"158\":1}}],[\"dummynode=new\",{\"1\":{\"211\":1}}],[\"dummynode\",{\"1\":{\"210\":1,\"211\":2}}],[\"dummyhead\",{\"1\":{\"169\":1,\"171\":3}}],[\"dummy\",{\"1\":{\"123\":5,\"270\":4}}],[\"duplicates\",{\"1\":{\"87\":1}}],[\"d\",{\"1\":{\"93\":1,\"95\":4,\"158\":3,\"200\":3,\"324\":6,\"333\":1,\"334\":2}}],[\"dfs\",{\"0\":{\"79\":1,\"325\":1,\"349\":1},\"1\":{\"78\":1,\"101\":1,\"182\":4,\"321\":1,\"326\":3,\"348\":1,\"349\":2,\"351\":4,\"523\":4,\"528\":1},\"2\":{\"106\":1,\"184\":1,\"328\":1,\"355\":1}}],[\"delayed\",{\"1\":{\"574\":1}}],[\"delay\",{\"1\":{\"574\":2}}],[\"deleteatindex\",{\"1\":{\"412\":4,\"416\":2,\"419\":1}}],[\"degree\",{\"1\":{\"517\":1}}],[\"defaultcapacity\",{\"1\":{\"478\":2,\"481\":2,\"484\":2}}],[\"default\",{\"1\":{\"478\":2,\"481\":1,\"484\":3,\"495\":1}}],[\"definition\",{\"1\":{\"70\":1,\"113\":1,\"121\":1,\"132\":1,\"171\":1,\"208\":1,\"211\":1,\"220\":1,\"246\":1,\"248\":1,\"263\":1,\"270\":1,\"342\":1,\"361\":1,\"386\":1,\"396\":1,\"436\":1,\"583\":1}}],[\"dev\",{\"1\":{\"458\":3}}],[\"deque\",{\"1\":{\"236\":1,\"248\":6,\"253\":1,\"573\":1,\"574\":2}}],[\"deque<integer>\",{\"1\":{\"256\":1}}],[\"deque<treenode>\",{\"1\":{\"180\":1,\"248\":1,\"353\":1,\"362\":1}}],[\"deque<node>\",{\"1\":{\"121\":1,\"324\":1}}],[\"deque<character>\",{\"1\":{\"92\":1,\"191\":1}}],[\"detectcycle\",{\"1\":{\"132\":1}}],[\"description\",{\"1\":{\"66\":1,\"87\":1,\"99\":1,\"108\":1,\"127\":1,\"136\":1,\"157\":1,\"166\":1,\"175\":1,\"186\":1,\"204\":1,\"235\":1,\"243\":1,\"252\":1,\"260\":1,\"265\":1,\"273\":1,\"310\":1,\"319\":1,\"330\":1,\"338\":1,\"346\":1,\"357\":1,\"366\":1,\"383\":1,\"411\":1,\"423\":1,\"432\":1,\"578\":1}}],[\"design\",{\"1\":{\"8\":1,\"9\":1,\"10\":1,\"11\":1,\"14\":1,\"36\":1,\"41\":1,\"46\":1,\"411\":1}}],[\"depth\",{\"1\":{\"0\":1,\"76\":1,\"99\":1,\"182\":4,\"326\":4,\"351\":6,\"517\":1,\"528\":2}}],[\"deploy\",{\"1\":{\"0\":4}}],[\"double\",{\"1\":{\"491\":1,\"574\":1}}],[\"doublew2w\",{\"1\":{\"0\":1}}],[\"do\",{\"1\":{\"28\":1,\"43\":1}}],[\"dosomething\",{\"1\":{\"28\":1}}],[\"docs\",{\"1\":{\"0\":1}}],[\"域名解析\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
