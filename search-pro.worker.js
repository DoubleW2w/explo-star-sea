const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":315,\"nextId\":315,\"documentIds\":{\"0\":\"2\",\"1\":\"2#介绍\",\"2\":\"3\",\"3\":\"3#关于我\",\"4\":\"4\",\"5\":\"5\",\"6\":\"5@0\",\"7\":\"6\",\"8\":\"6@0\",\"9\":\"6@1\",\"10\":\"7\",\"11\":\"7@0\",\"12\":\"7@1\",\"13\":\"8\",\"14\":\"8#markdown-介绍\",\"15\":\"8#markdown-配置\",\"16\":\"8#markdown-扩展\",\"17\":\"8#vuepress-扩展\",\"18\":\"8#主题扩展\",\"19\":\"8#选项卡\",\"20\":\"8#脚注\",\"21\":\"8#导入文件\",\"22\":\"8#tex-语法\",\"23\":\"8#任务列表\",\"24\":\"8#图片增强\",\"25\":\"8#上下角标\",\"26\":\"8#组件\",\"27\":\"8@0\",\"28\":\"8@1\",\"29\":\"9\",\"30\":\"9#页面标题\",\"31\":\"9#页面信息\",\"32\":\"9#页面内容\",\"33\":\"9#组件\",\"34\":\"9@0\",\"35\":\"9@1\",\"36\":\"10\",\"37\":\"10#题目地址-1-两数之和-力扣-leetcode\",\"38\":\"10#题目描述\",\"39\":\"10#前置知识\",\"40\":\"10#思路\",\"41\":\"10#关键点\",\"42\":\"10#代码\",\"43\":\"10@1\",\"44\":\"11\",\"45\":\"11#题目地址-1047-删除字符串中的所有相邻重复项-力扣-leetcode\",\"46\":\"11#题目描述\",\"47\":\"11#前置知识\",\"48\":\"11#思路-1-双端队列\",\"49\":\"11#关键点\",\"50\":\"11#代码\",\"51\":\"11#思路-2-数组\",\"52\":\"11#关键点-1\",\"53\":\"11#代码-1\",\"54\":\"11@1\",\"55\":\"12\",\"56\":\"12#题目地址-142-环形链表-ii-力扣-leetcode\",\"57\":\"12#题目描述\",\"58\":\"12#前置知识\",\"59\":\"12#思路\",\"60\":\"12#关键点\",\"61\":\"12#代码\",\"62\":\"12@1\",\"63\":\"13\",\"64\":\"13#题目地址-15-三数之和-力扣-leetcode\",\"65\":\"13#题目描述\",\"66\":\"13#前置知识\",\"67\":\"13#思路-排序-双指针\",\"68\":\"13#关键点\",\"69\":\"13#代码\",\"70\":\"13@1\",\"71\":\"14\",\"72\":\"14#题目地址-151-反转字符串中的单词-力扣-leetcode\",\"73\":\"14#题目描述\",\"74\":\"14#前置知识\",\"75\":\"14#思路-1-字符串-api\",\"76\":\"14#代码\",\"77\":\"14#思路-2-倒序遍历-双指针\",\"78\":\"14#代码-1\",\"79\":\"14#思路3-手写字符串api\",\"80\":\"14#代码-2\",\"81\":\"14@1\",\"82\":\"15\",\"83\":\"15#题目地址-18-四数之和-力扣-leetcode\",\"84\":\"15#题目描述\",\"85\":\"15#前置知识\",\"86\":\"15#思路\",\"87\":\"15#关键点\",\"88\":\"15#代码\",\"89\":\"15@1\",\"90\":\"16\",\"91\":\"16#题目地址-19-删除链表的倒数第-n-个结点-力扣-leetcode\",\"92\":\"16#题目描述\",\"93\":\"16#前置知识\",\"94\":\"16#思路-1-双指针\",\"95\":\"16#关键点\",\"96\":\"16#代码\",\"97\":\"16@1\",\"98\":\"17\",\"99\":\"17#题目地址-20-有效的括号-力扣-leetcode\",\"100\":\"17#题目描述\",\"101\":\"17#前置知识\",\"102\":\"17#思路\",\"103\":\"17#关键点\",\"104\":\"17#代码\",\"105\":\"17@1\",\"106\":\"18\",\"107\":\"18#题目地址-202-快乐数-力扣-leetcode\",\"108\":\"18#题目描述\",\"109\":\"18#前置知识\",\"110\":\"18#思路\",\"111\":\"18#关键点\",\"112\":\"18#代码\",\"113\":\"18@1\",\"114\":\"19\",\"115\":\"19#题目地址-203-移除链表元素-力扣-leetcode\",\"116\":\"19#题目描述\",\"117\":\"19#思路1-直接删除\",\"118\":\"19#关键点\",\"119\":\"19#代码\",\"120\":\"19#思路2-虚拟头节点\",\"121\":\"19#关键点-1\",\"122\":\"19#代码-1\",\"123\":\"19@1\",\"124\":\"20\",\"125\":\"20#题目地址-206-反转链表-力扣-leetcode\",\"126\":\"20#题目描述\",\"127\":\"20#前置知识\",\"128\":\"20#思路1-双指针\",\"129\":\"20#关键点\",\"130\":\"20#代码\",\"131\":\"20#思路2-递归\",\"132\":\"20#关键点-1\",\"133\":\"20#代码-1\",\"134\":\"20@1\",\"135\":\"21\",\"136\":\"21#题目地址-209-长度最小的子数组-力扣-leetcode\",\"137\":\"21#题目描述\",\"138\":\"21#前置知识\",\"139\":\"21#思路1-滑动窗口\",\"140\":\"21#关键点\",\"141\":\"21#代码\",\"142\":\"22\",\"143\":\"22#题目地址-225-用队列实现栈-力扣-leetcode\",\"144\":\"22#题目描述\",\"145\":\"22#前置知识\",\"146\":\"22#思路\",\"147\":\"22#代码\",\"148\":\"22@1\",\"149\":\"23\",\"150\":\"23#题目地址-232-用栈实现队列-力扣-leetcode\",\"151\":\"23#题目描述\",\"152\":\"23#前置知识\",\"153\":\"23#思路\",\"154\":\"23#代码\",\"155\":\"23@1\",\"156\":\"24\",\"157\":\"24#题目地址-24-两两交换链表中的节点-力扣-leetcode\",\"158\":\"24#题目描述\",\"159\":\"24#前置知识\",\"160\":\"24#思路1-虚拟头节点\",\"161\":\"24#关键点\",\"162\":\"24#代码\",\"163\":\"25\",\"164\":\"25#题目地址-242-有效的字母异位词-力扣-leetcode\",\"165\":\"25#题目描述\",\"166\":\"25#前置知识\",\"167\":\"25#思路-哈希表记录\",\"168\":\"25#关键点\",\"169\":\"25#代码\",\"170\":\"25@1\",\"171\":\"26\",\"172\":\"26#题目地址-27-移除元素-力扣-leetcode\",\"173\":\"26#题目描述\",\"174\":\"26#前置知识\",\"175\":\"26#思路-1\",\"176\":\"26#关键点\",\"177\":\"26#代码\",\"178\":\"26@1\",\"179\":\"27\",\"180\":\"27#题目地址-344-反转字符串-力扣-leetcode\",\"181\":\"27#题目描述\",\"182\":\"27#前置知识\",\"183\":\"27#思路\",\"184\":\"27#关键点\",\"185\":\"27#代码\",\"186\":\"27@1\",\"187\":\"28\",\"188\":\"28#题目地址-349-两个数组的交集-力扣-leetcode\",\"189\":\"28#题目描述\",\"190\":\"28#前置知识\",\"191\":\"28#公司\",\"192\":\"28#思路\",\"193\":\"28#关键点\",\"194\":\"28#代码\",\"195\":\"28@1\",\"196\":\"29\",\"197\":\"29#题目地址-383-赎金信-力扣-leetcode\",\"198\":\"29#题目描述\",\"199\":\"29#前置知识\",\"200\":\"29#思路\",\"201\":\"29#关键点\",\"202\":\"29#代码\",\"203\":\"29@1\",\"204\":\"30\",\"205\":\"30#题目地址-454-四数相加-ii-力扣-leetcode\",\"206\":\"30#题目描述\",\"207\":\"30#前置知识\",\"208\":\"30#思路\",\"209\":\"30#代码\",\"210\":\"30@1\",\"211\":\"31\",\"212\":\"31#题目地址-541-反转字符串-ii-力扣-leetcode\",\"213\":\"31#题目描述\",\"214\":\"31#前置知识\",\"215\":\"31#思路\",\"216\":\"31#关键点\",\"217\":\"31#代码\",\"218\":\"31@1\",\"219\":\"32\",\"220\":\"32#题目地址-59-螺旋矩阵-ii-力扣-leetcode\",\"221\":\"32#题目描述\",\"222\":\"32#前置知识\",\"223\":\"32#思路\",\"224\":\"32#关键点\",\"225\":\"32#代码\",\"226\":\"33\",\"227\":\"33#题目地址-704-二分查找-力扣-leetcode\",\"228\":\"33#题目描述\",\"229\":\"33#前置知识\",\"230\":\"33#思路\",\"231\":\"33#关键点\",\"232\":\"33#代码\",\"233\":\"33#思路改进\",\"234\":\"33#左闭右必区间\",\"235\":\"33@1\",\"236\":\"34\",\"237\":\"34#题目地址-707-设计链表-力扣-leetcode\",\"238\":\"34#题目描述\",\"239\":\"34#前置知识\",\"240\":\"34#思路-单链表实现\",\"241\":\"34#关键点\",\"242\":\"34#代码\",\"243\":\"34#思路-双链表实现\",\"244\":\"34#关键点-1\",\"245\":\"34#代码-1\",\"246\":\"34@1\",\"247\":\"35\",\"248\":\"35#题目地址-977-有序数组的平方-力扣-leetcode\",\"249\":\"35#题目描述\",\"250\":\"35#前置知识\",\"251\":\"35#思路\",\"252\":\"35#关键点\",\"253\":\"35#代码\",\"254\":\"35@1\",\"255\":\"36\",\"256\":\"37\",\"257\":\"37#哈希表是什么\",\"258\":\"37#哈希函数\",\"259\":\"37#哈希冲突\",\"260\":\"37#拉链法\",\"261\":\"37#线性探测法\",\"262\":\"37@1\",\"263\":\"38\",\"264\":\"38#什么是数组\",\"265\":\"38#数组的特点\",\"266\":\"38#二分法\",\"267\":\"38#二分查找模板-1\",\"268\":\"38#二分查找模版-2-找满足条件的最左侧的值\",\"269\":\"38#二分查找模版-3-找满足条件的最右侧的值\",\"270\":\"38#双指针法\",\"271\":\"38#滑动窗口\",\"272\":\"38#模拟行为\",\"273\":\"39\",\"274\":\"39#理论\",\"275\":\"39#arraydeque\",\"276\":\"39#问题\",\"277\":\"39@1\",\"278\":\"40\",\"279\":\"40#虚拟头节点\",\"280\":\"40#快慢指针\",\"281\":\"40#删除倒数第-n-个节点\",\"282\":\"40#链表的基本操作\",\"283\":\"40#链表相交\",\"284\":\"40#环形链表\",\"285\":\"40@1\",\"286\":\"41\",\"287\":\"41#链表是什么\",\"288\":\"41#链表类型\",\"289\":\"41#单链表\",\"290\":\"41#双链表\",\"291\":\"41#循环链表\",\"292\":\"41#链表存储方式\",\"293\":\"41#链表操作\",\"294\":\"41#头插节点\",\"295\":\"41#尾插节点\",\"296\":\"41#拆链操作\",\"297\":\"41#删除节点\",\"298\":\"41#链表性能分析\",\"299\":\"41#问题\",\"300\":\"41@1\",\"301\":\"42\",\"302\":\"42#理论\",\"303\":\"42#题目\",\"304\":\"42@1\",\"305\":\"43\",\"306\":\"43#题目地址-面试题-02-07-链表相交-力扣-leetcode\",\"307\":\"43#题目描述\",\"308\":\"43#前置知识\",\"309\":\"43#思路\",\"310\":\"43#关键点\",\"311\":\"43#代码\",\"312\":\"43@1\",\"313\":\"44\",\"314\":\"45\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[1,6],\"2\":[1],\"3\":[1],\"4\":[1,88],\"5\":[1],\"6\":[null,null,1],\"7\":[1,18],\"8\":[null,null,1],\"9\":[null,null,1],\"10\":[1,20],\"11\":[null,null,1],\"12\":[null,null,1],\"13\":[2,10],\"14\":[2,8],\"15\":[2,12],\"16\":[2,11],\"17\":[2,10],\"18\":[1,10],\"19\":[1,1],\"20\":[1,3],\"21\":[1,1],\"22\":[2,10],\"23\":[1,5],\"24\":[1,2],\"25\":[1,3],\"26\":[1],\"27\":[null,null,1],\"28\":[null,null,1],\"29\":[1,3],\"30\":[1,19],\"31\":[1,20],\"32\":[1,12],\"33\":[1,13],\"34\":[null,null,1],\"35\":[null,null,2],\"36\":[2],\"37\":[6,7],\"38\":[1,45],\"39\":[1,1],\"40\":[1,21],\"41\":[1,7],\"42\":[1,37],\"43\":[null,null,1],\"44\":[2],\"45\":[6,12],\"46\":[1,35],\"47\":[1,3],\"48\":[3,13],\"49\":[1,1],\"50\":[1,47],\"51\":[3,16],\"52\":[1],\"53\":[1,45],\"54\":[null,null,1],\"55\":[3],\"56\":[7,10],\"57\":[1,57],\"58\":[1,2],\"59\":[1,49],\"60\":[1,3],\"61\":[1,52],\"62\":[null,null,1],\"63\":[2],\"64\":[6,7],\"65\":[1,38],\"66\":[1,1],\"67\":[2,58],\"68\":[1,7],\"69\":[1,82],\"70\":[null,null,2],\"71\":[2],\"72\":[6,11],\"73\":[1,55],\"74\":[1,2],\"75\":[4,5],\"76\":[1,36],\"77\":[3,10],\"78\":[1,47],\"79\":[2,6],\"80\":[1,64],\"81\":[null,null,1],\"82\":[2],\"83\":[6,7],\"84\":[1,35],\"85\":[1,2],\"86\":[1,13],\"87\":[1,4],\"88\":[1,68],\"89\":[null,null,2],\"90\":[2],\"91\":[8,13],\"92\":[1,27],\"93\":[1,2],\"94\":[3,17],\"95\":[1,5],\"96\":[1,51],\"97\":[null,null,1],\"98\":[2],\"99\":[6,8],\"100\":[1,23],\"101\":[1,2],\"102\":[1,13],\"103\":[1,2],\"104\":[1,44],\"105\":[null,null,2],\"106\":[2],\"107\":[6,7],\"108\":[1,41],\"109\":[1,1],\"110\":[1,25],\"111\":[1,4],\"112\":[1,75],\"113\":[null,null,1],\"114\":[2],\"115\":[6,10],\"116\":[1,32],\"117\":[2,6],\"118\":[1,4],\"119\":[1,39],\"120\":[2],\"121\":[1,6],\"122\":[1,40],\"123\":[null,null,1],\"124\":[2],\"125\":[6,8],\"126\":[1,24],\"127\":[1,3],\"128\":[2,8],\"129\":[1,8],\"130\":[1,40],\"131\":[2,6],\"132\":[1,3],\"133\":[1,25],\"134\":[null,null,1],\"135\":[2],\"136\":[6,9],\"137\":[1,39],\"138\":[1,3],\"139\":[2,15],\"140\":[1,5],\"141\":[1,50],\"142\":[2],\"143\":[6,10],\"144\":[1,67],\"145\":[1,2],\"146\":[1,6],\"147\":[1,51],\"148\":[null,null,2],\"149\":[2],\"150\":[6,10],\"151\":[1,78],\"152\":[1,1],\"153\":[1,14],\"154\":[1,58],\"155\":[null,null,1],\"156\":[2],\"157\":[6,10],\"158\":[1,23],\"159\":[1,1],\"160\":[2,19],\"161\":[1,2],\"162\":[1,46],\"163\":[2],\"164\":[6,8],\"165\":[1,37],\"166\":[1,1],\"167\":[2,16],\"168\":[1,2],\"169\":[1,44],\"170\":[null,null,1],\"171\":[2],\"172\":[6,7],\"173\":[1,76],\"174\":[1,1],\"175\":[2,25],\"176\":[1,1],\"177\":[1,27],\"178\":[null,null,1],\"179\":[2],\"180\":[6,7],\"181\":[1,35],\"182\":[1,2],\"183\":[1,14],\"184\":[1,6],\"185\":[1,34],\"186\":[null,null,1],\"187\":[2],\"188\":[6,9],\"189\":[1,30],\"190\":[1],\"191\":[1,1],\"192\":[1],\"193\":[1],\"194\":[1,48],\"195\":[null,null,2],\"196\":[2],\"197\":[6,8],\"198\":[1,33],\"199\":[1,1],\"200\":[1,21],\"201\":[1,7],\"202\":[1,44],\"203\":[null,null,1],\"204\":[3],\"205\":[7,8],\"206\":[1,33],\"207\":[1,1],\"208\":[1,21],\"209\":[1,47],\"210\":[null,null,2],\"211\":[3],\"212\":[7,9],\"213\":[1,34],\"214\":[1,2],\"215\":[1,20],\"216\":[1,10],\"217\":[1,56],\"218\":[null,null,2],\"219\":[3],\"220\":[7,8],\"221\":[1,26],\"222\":[1,2],\"223\":[1,32],\"224\":[1,2],\"225\":[1,67],\"226\":[2],\"227\":[6,7],\"228\":[1,38],\"229\":[1,1],\"230\":[1,45],\"231\":[1,2],\"232\":[1,34],\"233\":[1,35],\"234\":[1,23],\"235\":[null,null,2],\"236\":[2],\"237\":[6,9],\"238\":[1,75],\"239\":[1,2],\"240\":[2,7],\"241\":[1,4],\"242\":[1,73],\"243\":[2,14],\"244\":[1,17],\"245\":[1,55],\"246\":[null,null,1],\"247\":[2],\"248\":[6,11],\"249\":[1,42],\"250\":[1,1],\"251\":[1,7],\"252\":[1,6],\"253\":[1,50],\"254\":[null,null,2],\"255\":[1,1],\"256\":[1],\"257\":[1,17],\"258\":[1,16],\"259\":[1,6],\"260\":[1,2],\"261\":[1,4],\"262\":[null,null,1],\"263\":[1],\"264\":[2,6],\"265\":[1,10],\"266\":[1],\"267\":[2,61],\"268\":[3,72],\"269\":[3,42],\"270\":[1,7],\"271\":[1,12],\"272\":[1,6],\"273\":[1],\"274\":[1,25],\"275\":[1,9],\"276\":[1,9],\"277\":[null,null,1],\"278\":[1],\"279\":[1,5],\"280\":[1,2],\"281\":[3,12],\"282\":[1,10],\"283\":[1,4],\"284\":[1,9],\"285\":[null,null,1],\"286\":[1],\"287\":[2,7],\"288\":[1],\"289\":[1,2],\"290\":[1,4],\"291\":[1,4],\"292\":[1,20],\"293\":[1],\"294\":[1,38],\"295\":[1,22],\"296\":[1,21],\"297\":[1,24],\"298\":[1,7],\"299\":[1,12],\"300\":[null,null,1],\"301\":[1],\"302\":[1,13],\"303\":[1,162],\"304\":[null,null,1],\"305\":[3],\"306\":[8,12],\"307\":[1,76],\"308\":[1,3],\"309\":[1,38],\"310\":[1,7],\"311\":[1,57],\"312\":[null,null,1],\"313\":[1,3],\"314\":[1]},\"averageFieldLength\":[1.7456050492696669,20.132218420058845,0.671804267950047],\"storedFields\":{\"0\":{\"h\":\"档案主页\"},\"1\":{\"h\":\"介绍\",\"t\":[\"This is Me!\",\"相关配置文档请见 档案主页。\"]},\"2\":{\"h\":\"关于我\"},\"3\":{\"h\":\"关于我\"},\"4\":{\"h\":\"关于本站\",\"t\":[\"2024-06-17\",\"完善 deploy,yml，部署到SSH 域名解析 doublew2w.cn\",\"2024-06-16\",\"完善 deploy.yml 文件，部署到 github-page\",\"注意\",\"记得建立 gh-pages 分支\",\"name: 部署文档 on: push: branches: - master permissions: contents: write jobs: deploy-gh-pages: runs-on: ubuntu-latest environment: master steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 1 # 如果你文档需要 Git 子模块，取消注释下一行 # submodules: true - name: 设置 pnpm uses: pnpm/action-setup@v4 - name: 设置 Node.js uses: actions/setup-node@v4 with: node-version: 20 cache: \\\"pnpm\\\" - name: 安装依赖 run: | corepack enable pnpm install --frozen-lockfile - name: 构建文档 env: NODE_OPTIONS: --max_old_space_size=8192 run: |- pnpm run docs:build > src/.vuepress/dist/.nojekyll - name: 部署文档 uses: JamesIves/github-pages-deploy-action@v4 with: # 部署文档 branch: gh-pages folder: src/.vuepress/dist\",\"2024-06-15\",\"初始化项目并上传到github\"]},\"5\":{\"h\":\"主要功能与配置演示\"},\"6\":{\"c\":[\"使用指南\"]},\"7\":{\"h\":\"布局与功能禁用\",\"t\":[\"你可以通过设置页面的 Frontmatter，在页面禁用功能与布局。\",\"本页面就是一个示例，禁用了如下功能:\",\"导航栏\",\"侧边栏\",\"路径导航\",\"页面信息\",\"贡献者\",\"编辑此页链接\",\"更新时间\",\"上一篇/下一篇 链接\",\"评论\",\"页脚\",\"返回顶部按钮\"]},\"8\":{\"c\":[\"使用指南\"]},\"9\":{\"c\":[\"禁用\"]},\"10\":{\"h\":\"布局\",\"t\":[\"布局包括:\",\"导航栏\",\"侧边栏\",\"页脚\",\"同时每个页面包含:\",\"路径导航\",\"标题和页面信息\",\"TOC (文章标题列表)\",\"贡献者、更新时间等页面元信息\",\"评论\",\"主题也带有以下元素:\",\"夜间模式按钮\",\"返回顶部按钮\",\"打印按钮\",\"你可以在主题选项和页面的 frontmatter 中自定义它们。\"]},\"11\":{\"c\":[\"指南\"]},\"12\":{\"c\":[\"布局\"]},\"13\":{\"h\":\"Markdown 展示\",\"t\":[\"VuePress 主要从 Markdown 文件生成页面。因此，你可以使用它轻松生成文档或博客站点。\",\"你需要创建并编写 Markdown，以便 VuePress 可以根据文件结构将它们转换为不同的页面。\"]},\"14\":{\"h\":\"Markdown 介绍\",\"t\":[\"如果你是一个新手，还不会编写 Markdown，请先阅读 Markdown 介绍 和 Markdown 演示。\"]},\"15\":{\"h\":\"Markdown 配置\",\"t\":[\"VuePress 通过 Frontmatter 为每个 Markdown 页面引入配置。\",\"Frontmatter\",\"Frontmatter 是 VuePress 中很重要的一个概念，请阅读 Frontmatter 介绍 了解详情。\"]},\"16\":{\"h\":\"Markdown 扩展\",\"t\":[\"VuePress 会使用 markdown-it 来解析 Markdown 内容，因此可以借助于 markdown-it 插件来实现 语法扩展 。\"]},\"17\":{\"h\":\"VuePress 扩展\",\"t\":[\"为了丰富文档写作，VuePress 对 Markdown 语法进行了扩展。\",\"关于这些扩展，请阅读 VuePress 中的 Markdown 扩展。\"]},\"18\":{\"h\":\"主题扩展\",\"t\":[\"通过 vuepress-plugin-md-enhance，主题扩展了更多 Markdown 语法，提供更加丰富的写作功能。\"]},\"19\":{\"h\":\"选项卡\",\"t\":[\"查看详情\"]},\"20\":{\"h\":\"脚注\",\"t\":[\"此文字有脚注[1].\",\"查看详情\"]},\"21\":{\"h\":\"导入文件\",\"t\":[\"查看详情\"]},\"22\":{\"h\":\"TeX 语法\",\"t\":[\"∂ωr∂r​(ωyω​)=(ωyω​){(logy)r+i=1∑r​ωi(−1)ir⋯(r−i+1)(logy)r−i​}\",\"查看详情\"]},\"23\":{\"h\":\"任务列表\",\"t\":[\" 计划 1\",\" 计划 2\",\"查看详情\"]},\"24\":{\"h\":\"图片增强\",\"t\":[\"支持为图片设置颜色模式和大小。\",\"查看详情\"]},\"25\":{\"h\":\"上下角标\",\"t\":[\"19th H2O\",\"查看详情\"]},\"26\":{\"h\":\"组件\"},\"27\":{\"c\":[\"使用指南\"]},\"28\":{\"c\":[\"Markdown\"]},\"29\":{\"h\":\"页面配置\",\"t\":[\"more 注释之前的内容被视为文章摘要。\"]},\"30\":{\"h\":\"页面标题\",\"t\":[\"The first H1 title in Markdown will be regarded as page title.\",\"Markdown 中的第一个 H1 标题会被视为页面标题。\",\"你可以在 Markdown 的 Frontmatter 中设置页面标题。\",\"--- title: 页面标题 ---\"]},\"31\":{\"h\":\"页面信息\",\"t\":[\"你可以在 Markdown 的 Frontmatter 中设置页面信息。\",\"作者设置为 Ms.Hope。\",\"写作日期为 2020 年 1 月 1 日\",\"分类为 “使用指南”\",\"标签为 “页面配置” 和 “使用指南”\"]},\"32\":{\"h\":\"页面内容\",\"t\":[\"你可以自由在这里书写你的 Markdown。\",\"图片引入\",\"你可以将图片和 Markdown 文件放置在一起使用相对路径进行引用。\",\"对于 .vuepress/public 文件夹的图片，请使用绝对链接 / 进行引用。\"]},\"33\":{\"h\":\"组件\",\"t\":[\"每个 Markdown 页面都会被转换为一个 Vue 组件，这意味着你可以在 Markdown 中使用 Vue 语法：\",\"{{ 1 + 1 }}\",\"{{ i }}\",\"你也可以创建并引入你自己的组件。\"]},\"34\":{\"c\":[\"使用指南\"]},\"35\":{\"c\":[\"页面配置\",\"使用指南\"]},\"36\":{\"h\":\"1-两数之和\"},\"37\":{\"h\":\"题目地址(1. 两数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/two-sum/\"]},\"38\":{\"h\":\"题目描述\",\"t\":[\" 给定一个整数数组 nums 和一个整数目标值 target ，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\",\" 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\",\" 你可以按任意顺序返回答案。\",\" 示例 1：\",\" 输入： nums = [2,7,11,15], target = 9 输出： [0,1] 解释： 因为 nums [0] + nums [1] == 9 ，返回 [0, 1] 。 \",\" 示例 2：\",\" 输入： nums = [3,2,4], target = 6 输出： [1,2] \",\" 示例 3：\",\" 输入： nums = [3,3], target = 6 输出： [0,1] \",\" 提示：\",\" 2 <= nums.length <= 10 4 \",\"-10 9 <= nums [i] <= 10 9 \",\"-10 9 <= target <= 10 9 \",\" 只会存在一个有效答案 \",\" 进阶： 你可以想出一个时间复杂度小于 O(n 2 ) 的算法吗？\"]},\"39\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"40\":{\"h\":\"思路\",\"t\":[\"创建一个哈希表，对于每个 x，通过查询 target - x 是否存在于哈希表中\",\"不存在，则将 x 插入哈希表\",\"存在，x 的下标与 target-x 的下标就是答案\",\"如果有 3 个或者以上的重复元素，代表这个重复元素不可能是解\",\"如果只有两个重复元素，同样的道理，假如这个重复元素是解，那么必定是两个重复元素的和等于 target。\"]},\"41\":{\"h\":\"关键点\",\"t\":[\"每种输入只会对应一个答案\",\"哈希表存储的 key 是 x 和 target - x\"]},\"42\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] twoSum(int[] nums, int target) { Map<Integer, Integer> map = new HashMap<>(); for (int i = 0; i < nums.length; ++i) { int first = target - nums[i]; if (map.containsKey(first)) { int firstIndex = map.get(target - nums[i]); return new int[]{firstIndex, i}; } map.put(nums[i], i); } return new int[0]; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，哈希表存储元素的开销\"]},\"43\":{\"c\":[\"哈希表\"]},\"44\":{\"h\":\"1047-删除字符串中的所有相邻重复项\"},\"45\":{\"h\":\"题目地址(1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/\"]},\"46\":{\"h\":\"题目描述\",\"t\":[\" 给出由小写字母组成的字符串 S ， 重复项删除操作 会选择两个相邻且相同的字母，并删除它们。\",\" 在 S 上反复执行重复项删除操作，直到无法继续删除。\",\" 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\",\" 示例：\",\" 输入： \\\"abbaca\\\" 输出： \\\"ca\\\" 解释： 例如，在 \\\"abbaca\\\" 中，我们可以删除 \\\"bb\\\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \\\"aaca\\\"，其中又只有 \\\"aa\\\" 可以执行重复项删除操作，所以最后的字符串为 \\\"ca\\\"。 \",\" 提示：\",\" 1 <= S.length <= 20000 \",\" S 仅由小写英文字母组成。\"]},\"47\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"栈\",\"数组\"]},\"48\":{\"h\":\"思路 1：双端队列\",\"t\":[\"当字符串中同时有多组相邻重复项时，我们无论是先删除哪一个，都不会影响最终的结果。\",\"遍历字符串，使用一个集合（数字或者队列）存储遍历的情况。\",\"当前字符与队列尾部相同时，说明此时是重复项已经出现，此时将队列尾部元素删除\",\"当前字符与队列尾部不同时，说明不是重复项，放进队列中\"]},\"49\":{\"h\":\"关键点\",\"t\":[\"利用栈的思想来判断匹配情况\"]},\"50\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public String removeDuplicates(String s) { if (s == null || s.length() == 0) { return s; } Deque<Character> queue = new ArrayDeque<>(); for (char c : s.toCharArray()) { if (queue.isEmpty() || c != queue.peekLast()) { queue.offer(c); } else { queue.pollLast(); } } StringBuilder sb = new StringBuilder(); while (!queue.isEmpty()) { sb.append(queue.poll()); } return sb.toString(); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，我们只需要遍历该字符串一次。\",\"空间复杂度：O(n)，需要创建一个队列来存储情况，最坏的情况是字符串中不存在相邻重复项。\"]},\"51\":{\"h\":\"思路 2：数组\",\"t\":[\"把数组当成一个队列使用，使用两个指针来判断遍历情况\",\"hh <= tt 时说明，字符串不为空。\",\"如果数组尾元素 d[tt] == c ，说明 当前是相邻重复项，修改 tt 指向上一个元素\",\"否则就将元素放进数组\"]},\"52\":{\"h\":\"关键点\"},\"53\":{\"h\":\"代码\",\"t\":[\"class Solution { public String removeDuplicates(String s) { if (s == null || s.length() == 0) { return s; } char[] d = new char[s.length()]; // 双指针，tt 指向最后的数组末尾指针 int hh = 0, tt = -1; for (char c : s.toCharArray()) { if (hh <= tt && d[tt] == c) { tt--; } else { // 数组为空时，添加元素 // 当前字符与末尾元素不相同时，添加元素 d[++tt] = c; } } return new String(d, 0, tt + 1); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，我们只需要遍历该字符串一次。\",\"空间复杂度：O(n)，需要创建一个长度为 n 的数组来存储情况，最坏的情况是字符串中不存在相邻重复项。\"]},\"54\":{\"c\":[\"字符串\"]},\"55\":{\"h\":\"142-环形链表 ii\"},\"56\":{\"h\":\"题目地址(142. 环形链表 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/linked-list-cycle-ii/description/\"]},\"57\":{\"h\":\"题目描述\",\"t\":[\" 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null 。\",\" 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（ 索引从 0 开始 ）。如果 pos 是 -1 ，则在该链表中没有环。 注意： pos 不作为参数进行传递 ，仅仅是为了标识链表的实际情况。\",\" 不允许修改 链表。\",\" 示例 1：\",\" 输入： head = [3,2,0,-4], pos = 1 输出： 返回索引为 1 的链表节点 解释： 链表中有一个环，其尾部连接到第二个节点。 \",\" 示例 2：\",\" 输入： head = [1,2], pos = 0 输出： 返回索引为 0 的链表节点 解释： 链表中有一个环，其尾部连接到第一个节点。 \",\" 示例 3：\",\" 输入： head = [1], pos = -1 输出： 返回 null 解释： 链表中没有环。 \",\" 提示：\",\" 链表中节点的数目范围在范围 [0, 10 4 ] 内 \",\"-10 5 <= Node.val <= 10 5 \",\" pos 的值为 -1 或者链表中的一个有效索引 \",\" 进阶： 你是否可以使用 O(1) 空间解决此题？\"]},\"58\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"环形证明\"]},\"59\":{\"h\":\"思路\",\"t\":[\"使用双指针，分别定义为 fast 和 slow。从头节点出发，fast 每次走两步，slow 每次走 1 步。\",\"如果存在环，由于 fast 的步速大于 slow，最终 fast 和 slow 一定会在环中相遇\",\"如果不存在环，fast 会先于 slow 走到 null\",\"从头节点到环形入口节点的节点数为 x，环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 y。从相遇节点 再到环形入口节点节点数为 z。\",\"相遇时，slow 走过的节点数为 x+y，fast 走过的节点数为 x+y+n(y+z)，其中 n 为走过的环的圈数。\",\"fast 每次走两步，slow 每次走一步。\",\"x+y+n(y+z) = 2*(x+y) => x = (n-1)(y+z)+z\",\"从「相遇点到入环点的距离」加上「 n−1 圈的环长度」，恰好等于「从链表头部到入环点的距离」。\"]},\"60\":{\"h\":\"关键点\",\"t\":[\"判断链表是否环\",\"如果有环，如何找到这个环的入口\"]},\"61\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { if(head == null || head.next == null){ return null; } // 采用双指针的方式 ListNode fast = head,slow = head; // 第一次相遇, fast 走了 2n 个环， slow 走了 n 个环 while(true){ if(fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if(fast == slow) break; } // 让 fast 和 slow 一起同时 1，在次相遇就是环入口 fast = head; while(fast != slow){ fast = fast.next; slow = slow.next; } return slow; } }\",\"复杂度分析\",\"时间复杂度：O(n)：第一次相遇时，slow 要走 x+y 步，第二次相遇，slow 要走 z 步，总体是线性复杂度\",\"空间复杂度：O(1)：双指针使用常数大小的额外空间\"]},\"62\":{\"c\":[\"链表\"]},\"63\":{\"h\":\"15-三数之和\"},\"64\":{\"h\":\"题目地址(15. 三数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/3sum/description/\"]},\"65\":{\"h\":\"题目描述\",\"t\":[\" 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums [j], nums [k]] 满足 i != j 、 i != k 且 j != k ，同时还满足 nums [i] + nums [j] + nums [k] == 0 。请 \",\" 你返回所有和为 0 且不重复的三元组。\",\" 注意： 答案中不可以包含重复的三元组。\",\" 示例 1：\",\" 输入： nums = [-1,0,1,2,-1,-4] 输出： [[-1,-1,2], [-1,0,1]] 解释： nums [0] + nums [1] + nums [2] = (-1) + 0 + 1 = 0 。 nums [1] + nums [2] + nums [4] = 0 + 1 + (-1) = 0 。 nums [0] + nums [3] + nums [4] = (-1) + 2 + (-1) = 0 。 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。 \",\" 示例 2：\",\" 输入： nums = [0,1,1] 输出： [] 解释： 唯一可能的三元组和不为 0 。 \",\" 示例 3：\",\" 输入： nums = [0,0,0] 输出： [[0,0,0]] 解释： 唯一可能的三元组和为 0 。 \",\" 提示：\",\" 3 <= nums.length <= 3000 \",\"-10 5 <= nums [i] <= 10 5 \"]},\"66\":{\"h\":\"前置知识\",\"t\":[\"双指针\"]},\"67\":{\"h\":\"思路：排序+双指针\",\"t\":[\"如果使用「暴力枚举」的方式，时间复杂度为 O(n3), 最后还要通过哈希表进行去重。\",\"为了「不重复」，我们先要排序。这样就能保证我们每一层循环都可以过滤掉相同的元素，而且能快速做出剪枝\",\"排序的时间复杂度为 O(nlogn)\",\"在固定两个元素的情况下，第三个元素会导致和为 <0>0=0。而两个元素的交替移动也能达到这个效果。\",\"定义三个指针 k, i, j，其中 k 指向最左的元素，双指针 i, j 分别在数组索引（k, length(nums)）处, 双指针 i , j 交替向中间移动，记录对于每个固定指针 k 的所有满足 nums [k] + nums [i] + nums [j] == 0 的 i, j 组合：\",\"如果 nums[k] > 0 ，而 nums[k] 又是最小，所以和肯定 > 0，终止循环\",\"如果 nums[k] == nums[k-1] 有可能是重复答案，处理一次即可\",\"双指针 i, j 变动情况： \",\"如果和 < 0, 说明 i 需要往 右边 移动，移动的时候要注意处理相同元素情况\",\"如果和 > 0, 说明 j 需要往 左边 移动，移动的时候要注意处理相同元素情况\",\"如果和 = 0, i 和 j 同时往中间移动的时候处理相同元素的情况\"]},\"68\":{\"h\":\"关键点\",\"t\":[\"为了 “不可以包含重复的三元组”，通过排序容易找到相同的三元组答案。\",\"为了更有效的找到有效解，双指针「交替向中间移动」\"]},\"69\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public List<List<Integer>> threeSum(int[] nums) { // 三重循环枚举，不重复则需要 // 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； // 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素； // 因此需要先排序。 // 双指针为什么要交替移动，往中间靠拢 // 在固定两重循环元素的情况，第三个元素导致的三数之和有可能导致 > 0 ,= 0 < 0，也有可能 = 0（重复答案） // 而 < 0 时，第二个枚举元素的下标要右边移动，增大总和 // 而 > 0 时，只能让第三个枚举元素的下标向左移动，减小总和 // = 0，就是当前答案，随后继续交替移动，排除重复答案、 List<List<Integer>> res = new ArrayList<>(); if(nums == null || nums.length <3){ return res; } Arrays.sort(nums); for(int k = 0;k < nums.length; k++){ if(nums[k] > 0) break; // 此时剩余两个元素都 > 0，往后的查找不满足。 if(k > 0 && nums[k] == nums[k - 1]) continue; // 找到重复答案（题目要求不重复） int i = k + 1,j = nums.length - 1; while(i < j){ int sum = nums[k] + nums[i] + nums[j]; if(sum < 0){ while(i < j && nums[i] == nums[++i]); // 不判断相同元素 }else if(sum > 0){ while(i < j && nums[j] == nums[--j]); // 不判断相同元素 }else if(sum == 0){ res.add(new ArrayList<Integer>(Arrays.asList(nums[k],nums[i],nums[j]))); while(i < j && nums[i] == nums[++i]); // 不判断相同答案的元素 while(i < j && nums[j] == nums[--j]); // 不判断相同答案的元素 } } } return res; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)，排序的时间复杂度为 O(nlogn)。双重循环的时间复杂度为 O(n2)\",\"空间复杂度：O(1)，指针使用常数大小的额外空间，忽略答案的存储空间。\"]},\"70\":{\"c\":[\"双指针\",\"数组\"]},\"71\":{\"h\":\"151-反转字符串中的单词\"},\"72\":{\"h\":\"题目地址(151. 反转字符串中的单词 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-words-in-a-string/submissions/\"]},\"73\":{\"h\":\"题目描述\",\"t\":[\" 给你一个字符串 s ，请你反转字符串中 单词 的顺序。\",\" 单词 是由非空格字符组成的字符串。 s 中使用至少一个空格将字符串中的 单词 分隔开。\",\" 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\",\" 注意： 输入字符串 s 中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\",\" 示例 1：\",\" 输入： s = \\\" the sky is blue \\\" 输出： \\\" blue is sky the \\\" \",\" 示例 2：\",\" 输入： s = \\\" hello world \\\" 输出： \\\"world hello\\\" 解释： 反转后的字符串中不能存在前导空格和尾随空格。 \",\" 示例 3：\",\" 输入： s = \\\"a good example\\\" 输出： \\\"example good a\\\" 解释： 如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 \",\" 提示：\",\" 1 <= s.length <= 10 4 \",\" s 包含英文大小写字母、数字和空格 ' '\",\" s 中 至少存在一个 单词 \",\" 进阶： 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\"]},\"74\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"75\":{\"h\":\"思路 1：字符串 API\",\"t\":[\"使用 split() ，以空格进行分割\",\"使用 reverse() 倒排字符串列表\"]},\"76\":{\"h\":\"代码\",\"t\":[\"Java Code\",\"class Solution { public String reverseWords(String s) { // 除去开头和末尾的空白字符 s = s.trim(); // 正则匹配连续的空白字符作为分隔符分割 List<String> wordList = Arrays.asList(s.split(\\\"\\\\\\\\s+\\\")); Collections.reverse(wordList); return String.join(\\\" \\\", wordList); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，线性遍历字符串。\",\"空间复杂度：O(n)，List 中的元素总长度，占用 O(N) 大小的额外空间。\"]},\"77\":{\"h\":\"思路 2：倒序遍历+双指针\",\"t\":[\"倒序遍历字符串 s，使用双指针 i，j 指向单词的范围。\",\"将单词添加到结果中\",\"并将双指针指向新的单词，最后将所有单词拼接起来。\"]},\"78\":{\"h\":\"代码\",\"t\":[\"Java Code:\",\" class Solution { public String reverseWords(String s) { s = s.trim(); // 删除首尾空格 int j = s.length() - 1, i = j; StringBuilder res = new StringBuilder(); while (i >= 0) { while (i >= 0 && s.charAt(i) != ' ') i--; // 搜索首个空格 res.append(s.substring(i + 1, j + 1) + \\\" \\\"); // 添加单词 while (i >= 0 && s.charAt(i) == ' ') i--; // 跳过单词间空格 j = i; // j 指向下个单词的尾字符 } return res.toString().trim(); // 转化为字符串并返回 } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，线性遍历字符串。\",\"空间复杂度：O(n)，StringBuilder(Java) 中的字符串总长度，占用 O(N) 大小的额外空间。\"]},\"79\":{\"h\":\"思路3：手写字符串API\",\"t\":[\"去除空格 trimSpaces\",\"先翻转整个字符串 reverse\",\"再翻转每个单词 reverseEachWord\"]},\"80\":{\"h\":\"代码\",\"t\":[\"class Solution { public String reverseWords(String s) { StringBuilder sb = trimSpaces(s); // 翻转字符串 reverse(sb, 0, sb.length() - 1); // 翻转每个单词 reverseEachWord(sb); return sb.toString(); } // 去掉多余空格 public StringBuilder trimSpaces(String s) { int left = 0, right = s.length() - 1; // 去掉字符串开头的空白字符 while (left <= right && s.charAt(left) == ' ') { ++left; } // 去掉字符串末尾的空白字符 while (left <= right && s.charAt(right) == ' ') { --right; } // 将字符串间多余的空白字符去除 StringBuilder sb = new StringBuilder(); while (left <= right) { char c = s.charAt(left); if (c != ' ') { sb.append(c); } else if (sb.charAt(sb.length() - 1) != ' ') { sb.append(c); } ++left; } return sb; } // 反转字符串 public void reverse(StringBuilder sb, int left, int right) { while (left < right) { char tmp = sb.charAt(left); sb.setCharAt(left++, sb.charAt(right)); sb.setCharAt(right--, tmp); } } // 翻转每一个单词 public void reverseEachWord(StringBuilder sb) { int n = sb.length(); int start = 0, end = 0; while (start < n) { // 循环至单词的末尾 while (end < n && sb.charAt(end) != ' ') { ++end; } // 翻转单词 reverse(sb, start, end - 1); // 更新start，去找下一个单词 start = end + 1; ++end; } } }\",\"复杂度分析\",\"时间复杂度：O(n)，其中 n 为输入字符串的长度。\",\"空间复杂度：Java 和 Python 的方法需要 O(n) 的空间来存储字符串\"]},\"81\":{\"c\":[\"字符串\"]},\"82\":{\"h\":\"18-四数之和\"},\"83\":{\"h\":\"题目地址(18. 四数之和 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/4sum/description/\"]},\"84\":{\"h\":\"题目描述\",\"t\":[\"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\",\"0 <= a, b, c, d < n\",\"a、b、c 和 d互不相同\",\"nums[a] + nums[b] + nums[c] + nums[d] == target\",\"你可以按 任意顺序 返回答案 。\",\"示例 1：\",\"输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] \",\"示例 2：\",\"输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] \",\"提示：\",\"1 <= nums.length <= 200\",\"-109 <= nums[i] <= 109\",\"-109 <= target <= 109\"]},\"85\":{\"h\":\"前置知识\",\"t\":[\"哈希表\",\"三数之和\"]},\"86\":{\"h\":\"思路\",\"t\":[\"本题与「15. 三数之和」相似，解法也相似。\",\"为了避免枚举到重复四元组，则需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素，且在同一重循环中不能多次枚举到相同的元素。因此我们需要「排序」。\",\"使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。\"]},\"87\":{\"h\":\"关键点\",\"t\":[\"排序解决重复问题\",\"使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。\"]},\"88\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { Arrays.sort(nums); List<List<Integer>> ans = new ArrayList<>(); int n = nums.length; // 枚举第一个数 for (int a = 0; a < n - 3; a++) { long x = nums[a]; // 跳过重复数字 if (a > 0 && x == nums[a - 1]) continue; if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break; if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue; // 枚举第二个数 for (int b = a + 1; b < n - 2; b++) { long y = nums[b]; if (b > a + 1 && y == nums[b - 1]) continue; if (x + y + nums[b + 1] + nums[b + 2] > target) break; if (x + y + nums[n - 2] + nums[n - 1] < target) continue; int l = b + 1, r = n - 1; while (l < r) { long sum = x + y + nums[l] + nums[r]; if (sum > target) r--; else if (sum < target) l++; else { // sum == target ans.add(Arrays.asList((int)x, (int)y, nums[l], nums[r])); l++; while (l < r && nums[l] == nums[l - 1]) l++; r--; while (l < r && nums[r] == nums[r + 1]) r--; } } } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n3)，排序的时间复杂度是 O(nlogn)，枚举四元组的时间复杂度是 O(n3)，因此总时间复杂度为 O(n3+nlogn)=O(n3)。\",\"空间复杂度：O(n)，空间复杂度主要取决于排序额外使用的空间。可以看成使用了一个额外的数组存储了数组 nums 的副本并排序，空间复杂度为 O(n)。\"]},\"89\":{\"c\":[\"双指针\",\"数组\"]},\"90\":{\"h\":\"19-删除链表的倒数第N个结点\"},\"91\":{\"h\":\"题目地址(19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\"]},\"92\":{\"h\":\"题目描述\",\"t\":[\" 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\",\" 示例 1：\",\" 输入： head = [1,2,3,4,5], n = 2 输出： [1,2,3,5] \",\" 示例 2：\",\" 输入： head = [1], n = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [1,2], n = 1 输出： [1] \",\" 提示：\",\" 链表中结点的数目为 sz \",\" 1 <= sz <= 30 \",\" 0 <= Node.val <= 100 \",\" 1 <= n <= sz \",\" 进阶： 你能尝试使用一趟扫描实现吗？\"]},\"93\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针\"]},\"94\":{\"h\":\"思路 1：双指针\",\"t\":[\"dummyHead 存储虚拟头节点，first 存储头节点，second 存储虚拟头节点，进行遍历。\",\"让 first 先走 N 步。\",\"second 和 first 一起走。\",\"当 first 走到空节点时时，second 刚好走好倒数第 N+1 个\"]},\"95\":{\"h\":\"关键点\",\"t\":[\"由于要进行删除操作，因此要找到「倒数第 n+1」个节点位置\"]},\"96\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { if (head.next == null && n == 1) { return null; } // 怎么知道是倒数第 2 个，使用双指针，让一个指针先走 2 步 ListNode dummyHead = new ListNode(-1, head); ListNode first = head; ListNode second = dummyHead; // 让 first 先走 n，让 first 到达尾节点，second 刚好指向倒数第 n 个 for (int i = 0; i < n; i++) { first = first.next; } while (first != null) { first = first.next; second = second.next; } second.next = second.next.next; return dummyHead.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"97\":{\"c\":[\"链表\"]},\"98\":{\"h\":\"20-有效的括号\"},\"99\":{\"h\":\"题目地址(20. 有效的括号 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/valid-parentheses/description/\"]},\"100\":{\"h\":\"题目描述\",\"t\":[\"给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\",\"有效字符串需满足：\",\"左括号必须用相同类型的右括号闭合。\",\"左括号必须以正确的顺序闭合。\",\"每个右括号都有一个对应的相同类型的左括号。\",\"示例 1：\",\"输入：s = \\\"()\\\" 输出：true \",\"示例 2：\",\"输入：s = \\\"()[]{}\\\" 输出：true \",\"示例 3：\",\"输入：s = \\\"(]\\\" 输出：false \",\"提示：\",\"1 <= s.length <= 104\",\"s 仅由括号 '()[]{}' 组成\"]},\"101\":{\"h\":\"前置知识\",\"t\":[\"栈\",\"字符串\"]},\"102\":{\"h\":\"思路\",\"t\":[\"当我们遇到一个左括号时，就放入一个对应的右括号。\",\"当我们遇到一个右括号时，\",\"如果栈为空或者栈顶元素与「当前的右括号」不一样时，那么字符串就是无效的。\",\"如果与栈顶元素一样，就说明括号右效。将栈顶元素出栈\",\"最后再判断栈是不是为空，解决 [({}) 这种情况\"]},\"103\":{\"h\":\"关键点\",\"t\":[\"入栈是右括号，并将当前元素与栈顶元素判断是否相同\"]},\"104\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"class Solution { public boolean isValid(String s) { if (s.isEmpty()) { return true; } // 长度为奇数时 if(s.length() % 2 == 1){ return false; } Deque<Character> queue = new ArrayDeque<>(); for (char c : s.toCharArray()) { if(c == '('){ queue.offer(')'); }else if(c == '['){ queue.offer(']'); }else if(c == '{'){ queue.offer('}'); }else if(queue.isEmpty() || c != queue.pollLast()){ return false; } } return queue.isEmpty(); } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n),创建一个双端队列存放右括号，最多是1/2 n个。\"]},\"105\":{\"c\":[\"字符串\",\"栈\"]},\"106\":{\"h\":\"202-快乐数\"},\"107\":{\"h\":\"题目地址(202. 快乐数 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/happy-number/\"]},\"108\":{\"h\":\"题目描述\",\"t\":[\"编写一个算法来判断一个数 n 是不是快乐数。\",\"「快乐数」 定义为：\",\"对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\",\"然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\",\"如果这个过程 结果为 1，那么这个数就是快乐数。\",\"如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\",\"示例 1：\",\"输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 \",\"示例 2：\",\"输入：n = 2 输出：false \",\"提示：\",\"1 <= n <= 231 - 1\"]},\"109\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"110\":{\"h\":\"思路\",\"t\":[\"通过反复调用 getNext(n) 得到的链是一个隐式的链表。链中的所有其他数字都是节点。那问题就直接转换为「检测一个链表是否有环。」\",\"定义两个指针slow和fast，slow在链表中前进 1 个节点，fast在链表前进 2 个节点（对 getNext(n) 函数的嵌套调用）。\",\"如果 n 是快乐数，则就说明没有循环，fast 会先到 “1”\",\"如果 n 不是快乐数，fast 和 slow 一定会在循环中。\"]},\"111\":{\"h\":\"关键点\",\"t\":[\"将”快乐数“操作视为寻找下一个数，即看成一个链表\"]},\"112\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { // 对于一个三位数来说，最大的平方和为 9^2+9^2+9^2 = 243 // 对于一个四位数来说，最大的平方和为 81 + 81 + 81 + 81 = 324 // 在继续往下后，4位数只会降到3位数，而不会无穷大 public int getNext(int n) { int totalSum = 0; // 计算每一位的平方和 while (n > 0) { int d = n % 10; n = n / 10; totalSum += d * d; } return totalSum; } public boolean isHappy(int n) { int slowRunner = n; int fastRunner = getNext(n); if(fastRunner == 1){ return true; } // 快慢指针，不是快乐数，那么存在一个环使得算法无限循环 // 在环中它们由于步速不一致，会相遇 // 如果相遇，则说明不是快乐数 // 如果是快乐数，最后会返回1 while (slowRunner != fastRunner) { // slow 走一步, fast 走两步 slowRunner = getNext(slowRunner); fastRunner = getNext(fastRunner); fastRunner = getNext(fastRunner); } return fastRunner == 1; } }\",\"复杂度分析\",\"时间复杂度：O(n)\",\"如果没有循环，那么fast将先到达 1，slow将到达链表中的一半。成本是 O(2⋅logn)=O(logn)\",\"一旦两个指针都在循环中，假设循环中有 k 个数字。如果他们的起点是相隔 k−1 的位置（这是他们可以开始的最远的距离），那么快跑者需要 k−1 步才能到达慢跑者，主操作不变，所以也是 O(logn)。\",\"空间复杂度：O(n)\"]},\"113\":{\"c\":[\"哈希表\"]},\"114\":{\"h\":\"203-移除链表元素\"},\"115\":{\"h\":\"题目地址(203. 移除链表元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-linked-list-elements/description/\"]},\"116\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\",\" 示例 1：\",\" 输入： head = [1,2,6,3,4,5,6], val = 6 输出： [1,2,3,4,5] \",\" 示例 2：\",\" 输入： head = [], val = 1 输出： [] \",\" 示例 3：\",\" 输入： head = [7,7,7,7], val = 7 输出： [] \",\" 提示：\",\" 列表中的节点数目在范围 [0, 10 4 ] 内 \",\" 1 <= Node.val <= 50 \",\" 0 <= val <= 50 ## 前置知识 \",\"链表\",\"删除节点\",\"虚拟节点\"]},\"117\":{\"h\":\"思路1:直接删除\",\"t\":[\"先判断头结点的情况 head!=null&&head.val!=val\",\"从当前节点的后驱节点进行遍历\"]},\"118\":{\"h\":\"关键点\",\"t\":[\"头结点要特殊处理\",\"cur.next=cur.next.next\"]},\"119\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\"/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { // 删除值相同的头结点后，可能新的头结点也值相等，用循环解决 while (head != null && head.val == val) { head = head.next; } if (head == null) return head; ListNode prev = head; // 确保当前结点后还有结点 while (prev.next != null) { if (prev.next.val == val) { prev.next = prev.next.next; } else { prev = prev.next; } } return head; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"120\":{\"h\":\"思路2：虚拟头节点\"},\"121\":{\"h\":\"关键点\",\"t\":[\"在虚拟头节点下，要删除一个节点，删除方式一样。最后返回的时候是 dummyNode.next\"]},\"122\":{\"h\":\"代码\",\"t\":[\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { //创建一个虚拟头结点 ListNode dummyNode=new ListNode(val-1); dummyNode.next=head; ListNode prev=dummyNode; //确保当前结点后还有结点 while(prev.next!=null){ if(prev.next.val==val){ prev.next=prev.next.next; }else{ prev=prev.next; } } return dummyNode.next; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"123\":{\"c\":[\"链表\"]},\"124\":{\"h\":\"206-反转链表\"},\"125\":{\"h\":\"题目地址(206. 反转链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-linked-list/\"]},\"126\":{\"h\":\"题目描述\",\"t\":[\"给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\",\"示例 1：\",\"输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] \",\"示例 2：\",\"输入：head = [1,2] 输出：[2,1] \",\"示例 3：\",\"输入：head = [] 输出：[] \",\"提示：\",\"链表中节点的数目范围是 [0, 5000]\",\"-5000 <= Node.val <= 5000\",\"进阶：链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\"]},\"127\":{\"h\":\"前置知识\",\"t\":[\"链表\",\"双指针/递归思想\"]},\"128\":{\"h\":\"思路1:双指针\",\"t\":[\"图片来自：代码随想录\",\"pre 指向虚拟节点，cur 指向头节点\",\"在每一次移动过程中，修改节点指向\"]},\"129\":{\"h\":\"关键点\",\"t\":[\"先存储 next 引用 next=cur.next\",\"cur.next=pre\",\"pre=cur\",\"cur=next\"]},\"130\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; // 前驱节点 null ListNode curr = head; // 当前节点 1 (1->2) while (curr != null) { ListNode next = curr.next; // 后驱节点 2 curr.next = prev; // 反向 1<-2 prev = curr; // prev = 1 curr = next; // curr = 2 } return prev; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"131\":{\"h\":\"思路2：递归\",\"t\":[\"递归函数的定义\",\"输出一个节点 head\",\"将 head 为起点的链表进行反转\",\"返回反转之后的头节点\"]},\"132\":{\"h\":\"关键点\",\"t\":[\"理解递归\",\"当第一次递归时，已经把链表分成后两部分\"]},\"133\":{\"h\":\"代码\",\"t\":[\"class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode last = reverseList(head.next); head.next.next = head; head.next = null; return last; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(n)，空间复杂度主要取决于递归调用的栈空间，最多为 n 层。\"]},\"134\":{\"c\":[\"链表\"]},\"135\":{\"h\":\"209-长度最小的子数组\"},\"136\":{\"h\":\"题目地址(209. 长度最小的子数组 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/minimum-size-subarray-sum/\"]},\"137\":{\"h\":\"题目描述\",\"t\":[\"给定一个含有 n个正整数的数组和一个正整数 target 。\",\"找出该数组中满足其总和大于等于target的长度最小的 \",\"子数组\",\"[numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\",\"示例 1：\",\"输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 \",\"示例 2：\",\"输入：target = 4, nums = [1,4,4] 输出：1 \",\"示例 3：\",\"输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 \",\"提示：\",\"1 <= target <= 109\",\"1 <= nums.length <= 105\",\"1 <= nums[i] <= 105\",\"进阶：\",\"如果你已经实现O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\"]},\"138\":{\"h\":\"前置知识\",\"t\":[\"滑动窗口\",\"[前缀和+二分查找]\"]},\"139\":{\"h\":\"思路1：滑动窗口\",\"t\":[\"定义两个指针 start 和 end 分别指向滑动窗口的开始位置和结束位置\",\"计算滑动窗口的总和 sum\",\"当 sum 符合题目时，窗口的长度为子数组的最小长度 end−start+1\",\"将 start 继续往右移，找到更小的窗口长度\",\"继续更新子数组的最小长度\"]},\"140\":{\"h\":\"关键点\",\"t\":[\"当窗口符合条件时，要将 start 继续往右移，找到更小的窗口长度\"]},\"141\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int minSubArrayLen(int target, int[] nums) { // 第一次符合条件为窗口长度 right - left // int n = nums.length; if(n == 0) return 0; int ans = Integer.MAX_VALUE; int start = 0, end = 0; // 滑动串口的指针和右指针 int sum = 0; while (end < n) { sum += nums[end]; // 把当前元素添加进去,直到符合最小窗口的长度 while (sum >= target) { // 最小窗口长度右移，直到不满足 此时，ans = end - start + 1， end - start ans = Math.min(ans, end - start + 1); sum -= nums[start]; start++; } end++; } return ans == Integer.MAX_VALUE ? 0 : ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"142\":{\"h\":\"225-用队列实现栈\"},\"143\":{\"h\":\"题目地址(225. 用队列实现栈 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/implement-stack-using-queues/description/\"]},\"144\":{\"h\":\"题目描述\",\"t\":[\" 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（ push 、 top 、 pop 和 empty ）。\",\" 实现 MyStack 类：\",\" void push(int x) 将元素 x 压入栈顶。\",\" int pop() 移除并返回栈顶元素。\",\" int top() 返回栈顶元素。\",\" boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\",\" 注意：\",\" 你只能使用队列的标准操作 —— 也就是 push to back 、 peek/pop from front 、 size 和 is empty 这些操作。\",\" 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\",\" 示例：\",\" 输入： [\\\"MyStack\\\", \\\"push\\\", \\\"push\\\", \\\"top\\\", \\\"pop\\\", \\\"empty\\\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False \",\" 提示：\",\" 1 <= x <= 9 \",\" 最多调用 100 次 push 、 pop 、 top 和 empty \",\" 每次调用 pop 和 top 都保证栈不为空 \",\" 进阶： 你能否仅用一个队列来实现栈。\"]},\"145\":{\"h\":\"前置知识\",\"t\":[\"栈\",\"队列\"]},\"146\":{\"h\":\"思路\",\"t\":[\"队列是先进先出\",\"栈是后进先出。\",\"使用两个队列，一个当成主要的，一个辅助备份。\"]},\"147\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyStack { //q1 作为主要的队列，其元素排列顺序和出栈顺序相同 Queue<Integer> q1 = new ArrayDeque<>(); //q2 仅作为临时放置 Queue<Integer> q2 = new ArrayDeque<>(); public MyStack() { } //在加入元素时先将 q1 中的元素依次出栈压入 q2，然后将新加入的元素压入 q1，再将 q2 中的元素依次出栈压入 q1 public void push(int x) { while (q1.size() > 0) { q2.offer(q1.poll()); } q1.offer(x); while (q2.size() > 0) { q1.offer(q2.poll()); } } public int pop() { return q1.poll(); } public int top() { return q1.peek(); } public boolean empty() { return q1.isEmpty(); } }\",\"复杂度分析\",\"令 n 为栈内元素个数。\",\"时间复杂度：O(n), push 操作为 2n+1 个，pop 操作为 O(1), top 操作为 O(1)，empty 操作为 O(1)\",\"空间复杂度：O(n), 其中 n 是栈内的元素个数。需要使用两个队列存储栈内的元素。\"]},\"148\":{\"c\":[\"列队、栈\"]},\"149\":{\"h\":\"232-用栈实现队列\"},\"150\":{\"h\":\"题目地址(232. 用栈实现队列 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/implement-queue-using-stacks/description/\"]},\"151\":{\"h\":\"题目描述\",\"t\":[\" 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（ push 、 pop 、 peek 、 empty ）：\",\" 实现 MyQueue 类：\",\" void push(int x) 将元素 x 推到队列的末尾 \",\" int pop() 从队列的开头移除并返回元素 \",\" int peek() 返回队列开头的元素 \",\" boolean empty() 如果队列为空，返回 true ；否则，返回 false \",\" 说明：\",\" 你 只能 使用标准的栈操作 —— 也就是只有 push to top , peek/pop from top , size , 和 is empty 操作是合法的。\",\" 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\",\" 示例 1：\",\" 输入： [\\\"MyQueue\\\", \\\"push\\\", \\\"push\\\", \\\"peek\\\", \\\"pop\\\", \\\"empty\\\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false \",\" 提示：\",\" 1 <= x <= 9 \",\" 最多调用 100 次 push 、 pop 、 peek 和 empty \",\" 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\",\" 进阶：\",\" 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\"]},\"152\":{\"h\":\"前置知识\",\"t\":[\"队列\"]},\"153\":{\"h\":\"思路\",\"t\":[\"用一个队列存放 push 元素，用一个队列存放 pop 元素。在 pop 或 peek 时，需要将元素从 in 放进 out 中进行。\"]},\"154\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyQueue { Deque<Integer> out, in; public MyQueue() { in = new ArrayDeque<Integer>(); out = new ArrayDeque<Integer>(); } public void push(int x) { in.push(x); } public int pop() { if (out.isEmpty()) { in2out(); } return out.pop(); } public int peek() { if (out.isEmpty()) { in2out(); } return out.peek(); } public boolean empty() { return in.isEmpty() && out.isEmpty(); } private void in2out() { while (!in.isEmpty()) { out.push(in.pop()); } } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */\",\"复杂度分析\",\"令 n 为操作数。\",\"时间复杂度：O(1), push 和 empty 操作都是 O(1), pop 和 peek 为均摊 O(1)。\",\"空间复杂度：O(n)，对于有 n 次 push 操作的情况，队列中会有 n 个元素，故空间复杂度为 O(n)。\"]},\"155\":{\"c\":[\"栈\"]},\"156\":{\"h\":\"24-两两交换链表中的节点\"},\"157\":{\"h\":\"题目地址(24. 两两交换链表中的节点 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/swap-nodes-in-pairs/description/\"]},\"158\":{\"h\":\"题目描述\",\"t\":[\"给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\",\"示例 1：\",\"输入：head = [1,2,3,4] 输出：[2,1,4,3] \",\"示例 2：\",\"输入：head = [] 输出：[] \",\"示例 3：\",\"输入：head = [1] 输出：[1] \",\"提示：\",\"链表中节点的数目在范围 [0, 100] 内\",\"0 <= Node.val <= 100\"]},\"159\":{\"h\":\"前置知识\",\"t\":[\"链表\"]},\"160\":{\"h\":\"思路1：虚拟头节点\",\"t\":[\"使用变量 cur 代表当前节点，初始化为 cur=dummy\",\"使用两个变量 first 和 second 待交换的节点，即 first=cur.next 和 second=cur.next.next\",\"当链表还剩下两个节点时，就可以进行更改链表节点的交换\",\"cur.next = secod\",\"first.next = second.next\",\"second.next = first\",\"cur = first\",\"进行下一轮的判断并且交换\"]},\"161\":{\"h\":\"关键点\",\"t\":[\"循环条件是当前链表还有2个以上的节点\",\"链表节点交换的指针变动\"]},\"162\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(0); // 设置一个虚拟头节点 dummy.next = head; // 将虚拟头结点指向head,这样方便后续做删除操作 ListNode cur = dummy; while (cur.next != null && cur.next.next != null) { ListNode first = cur.next; ListNode second = cur.next.next; cur.next = second; // 步骤一 first.next = second.next; // 步骤三 second.next = first; // 步骤二 cur = first; } return dummy.next; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"163\":{\"h\":\"242-有效的字母异位词\"},\"164\":{\"h\":\"题目地址(242. 有效的字母异位词 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/valid-anagram/description/\"]},\"165\":{\"h\":\"题目描述\",\"t\":[\" 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\",\" 注意： 若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\",\" 示例 1: \",\" 输入: s = \\\"anagram\\\", t = \\\"nagaram\\\" 输出: true \",\" 示例 2: \",\" 输入: s = \\\"rat\\\", t = \\\"car\\\" 输出: false \",\" 提示: \",\" 1 <= s.length, t.length <= 5 * 10 4 \",\" s 和 t 仅包含小写字母 \",\" 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\"]},\"166\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"167\":{\"h\":\"思路：哈希表记录\",\"t\":[\"若 s、t 长度不相等，则「非字母异位词」\",\"若 s、t 某对应字母数量不同，则「非字母异位词」\",\"统计 s 各字符时执行 +1 ，统计 t 各字符时 −1 。若两字符串互为字母异位词，则最终哈希表中所有字符统计数值都应为 0 。\"]},\"168\":{\"h\":\"关键点\",\"t\":[\"使用哈希表进行记录不同字母出现的次数\",\"也可以使用长度固定的数组记录不同字母出现的次数\"]},\"169\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public boolean isAnagram(String s, String t) { // 先判断长度一致 if (s.length() != t.length()) { return false; } // 使用字母的特性：只有 26 个，以一个数组来记录 int[] table = new int[26]; for (int i = 0; i < s.length(); i++) { table[s.charAt(i) - 'a']++; table[t.charAt(i) - 'a']--; } for (int i = 0; i < 26; i++) { if (table[i] != 0) { return false; } } return true; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，数组长度为常数，因此空间复杂度为常数\"]},\"170\":{\"c\":[\"哈希表\"]},\"171\":{\"h\":\"27-移除元素\"},\"172\":{\"h\":\"题目地址(27. 移除元素 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/remove-element/\"]},\"173\":{\"h\":\"题目描述\",\"t\":[\" 给你一个数组 nums 和一个值 val ，你需要 原地 移除所有数值等于 val 的元素。元素的顺序可能发生改变。然后返回 nums 中与 val 不同的元素的数量。\",\" 假设 nums 中不等于 val 的元素数量为 k ，要通过此题，您需要执行以下操作：\",\" 更改 nums 数组，使 nums 的前 k 个元素包含不等于 val 的元素。 nums 的其余元素和 nums 的大小并不重要。\",\" 返回 k 。\",\" 用户评测：\",\" 评测机将使用以下代码测试您的解决方案：\",\"int [] nums = [...]; // 输入数组 int val = ...; // 要移除的值 int [] expectedNums = [...]; // 长度正确的预期答案。 // 它以不等于 val 的值排序。 int k = removeElement(nums, val); // 调用你的实现 assert k == expectedNums.length; sort(nums, 0, k); // 排序 nums 的前 k 个元素 for (int i = 0; i < actualLength; i++) { assert nums [i] == expectedNums [i]; }\",\" 如果所有的断言都通过，你的解决方案将会 通过 。\",\" 示例 1：\",\" 输入： nums = [3,2,2,3], val = 3 输出： 2, nums = [2,2, _,_] 解释： 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。\",\" 示例 2：\",\" 输入： nums = [0,1,2,2,3,0,4,2], val = 2 输出： 5, nums = [0,1,4,0,3, _,_,_] 解释： 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。 注意这五个元素可以任意顺序返回。 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。 \",\" 提示：\",\" 0 <= nums.length <= 100 \",\" 0 <= nums [i] <= 50 \",\" 0 <= val <= 100 \"]},\"174\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"175\":{\"h\":\"思路 1\",\"t\":[\"题意：\",\"原地-》空间复杂度为 O(1)\",\"前 K 个元素不等于 val\",\"遍历数组 nums，每次取出的数字变量为 num，同时设置一个下标 ans\",\"在遍历过程中如果出现数字与需要移除的值 不相同 时，则进行拷贝覆盖 nums[ans]=num，ans 自增 1\",\"如果相同的时候，则跳过该数字不进行拷贝覆盖，最后 ans 即为新的数组长度\"]},\"176\":{\"h\":\"关键点\",\"t\":[\"拷贝覆盖\"]},\"177\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int removeElement(int[] nums, int val) { int ans = 0; for (int num : nums) { if (num != val) { nums[ans] = num; ans++; } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)\"]},\"178\":{\"c\":[\"数组\"]},\"179\":{\"h\":\"344-反转字符串\"},\"180\":{\"h\":\"题目地址(344. 反转字符串 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-string/\"]},\"181\":{\"h\":\"题目描述\",\"t\":[\" 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\" 不要给另外的数组分配额外的空间，你必须 原地 修改输入数组 、使用 O(1) 的额外空间解决这一问题。\",\" 示例 1：\",\" 输入： s = [\\\"h\\\", \\\"e\\\", \\\"l\\\", \\\"l\\\", \\\"o\\\"] 输出： [\\\"o\\\", \\\"l\\\", \\\"l\\\", \\\"e\\\", \\\"h\\\"] \",\" 示例 2：\",\" 输入： s = [\\\"H\\\", \\\"a\\\", \\\"n\\\", \\\"n\\\", \\\"a\\\", \\\"h\\\"] 输出： [\\\"h\\\", \\\"a\\\", \\\"n\\\", \\\"n\\\", \\\"a\\\", \\\"H\\\"] \",\" 提示：\",\" 1 <= s.length <= 10 5 \",\" s [i] 都是 ASCII 码表中的可打印字符 \"]},\"182\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"183\":{\"h\":\"思路\",\"t\":[\"使用两个指针 l, r 分别指向字符数组首元素，字符数组尾元素。\",\"当 l < r 时，交换 l 和 r 指向的元素。\",\"当 l == r 时，就表示反转结束。\"]},\"184\":{\"h\":\"关键点\",\"t\":[\"s[i] 与 s[n-1-i] 交换\"]},\"185\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public void reverseString(char[] s) { //O(1) int left = 0; int right = s.length - 1; while(left < right){ char temp = s[left]; s[left] = s[right]; s[right] = temp; left++; right--; } } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n), 一共执行了 n/2 次交换。\",\"空间复杂度：O(1)，两个指针，常数的空间。\"]},\"186\":{\"c\":[\"字符串\",\"字符串\"]},\"187\":{\"h\":\"349-两个数组的交集\"},\"188\":{\"h\":\"题目地址(349. 两个数组的交集 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-arrays/\"]},\"189\":{\"h\":\"题目描述\",\"t\":[\"给定两个数组 nums1 和 nums2 ，返回 它们的 \",\"交集\",\" 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\",\"示例 1：\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] \",\"示例 2：\",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 \",\"提示：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 1000\"]},\"190\":{\"h\":\"前置知识\"},\"191\":{\"h\":\"公司\",\"t\":[\"暂无\"]},\"192\":{\"h\":\"思路\"},\"193\":{\"h\":\"关键点\"},\"194\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] intersection(int[] nums1, int[] nums2) { int[] hash1 = new int[1002]; int[] hash2 = new int[1002]; // 计数 for(int i : nums1) hash1[i]++; for(int i : nums2) hash2[i]++; List<Integer> resList = new ArrayList<>(); // 寻找交集元素 for(int i = 0; i < 1002; i++) if(hash1[i] > 0 && hash2[i] > 0) resList.add(i); // 转换成数组 int index = 0; int res[] = new int[resList.size()]; for(int i : resList) res[index++] = i; return res; } }\",\"复杂度分析\",\"令 n 为nums1数组长度,m为nums2数组长度。\",\"时间复杂度：O(m+n),使用两个集合分别存储两个数组中的元素需要 O(m+n) 的时间\",\"空间复杂度：O(m+n)，两个存储数组都是固定长度。\"]},\"195\":{\"c\":[\"哈希表\",\"数组\"]},\"196\":{\"h\":\"383-赎金信\"},\"197\":{\"h\":\"题目地址(383. 赎金信 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/ransom-note/description/\"]},\"198\":{\"h\":\"题目描述\",\"t\":[\" 给你两个字符串： ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\",\" 如果可以，返回 true ；否则返回 false 。\",\" magazine 中的每个字符只能在 ransomNote 中使用一次。\",\" 示例 1：\",\" 输入： ransomNote = \\\"a\\\", magazine = \\\"b\\\" 输出： false \",\" 示例 2：\",\" 输入： ransomNote = \\\"aa\\\", magazine = \\\"ab\\\" 输出： false \",\" 示例 3：\",\" 输入： ransomNote = \\\"aa\\\", magazine = \\\"aab\\\" 输出： true \",\" 提示：\",\" 1 <= ransomNote.length, magazine.length <= 10 5 \",\" ransomNote 和 magazine 由小写英文字母组成 \"]},\"199\":{\"h\":\"前置知识\",\"t\":[\"哈希表\"]},\"200\":{\"h\":\"思路\",\"t\":[\"如果两个字符串的长度不相等，则不是正确答案。\",\"如果 ransomNote 存在 magazine 没有的字母，则不是正确答案。\",\"定义一个长度为 26 的数组存放 magazine 不同字母的个数。 \",\"记录 ransomNote 每个字符的情况\",\"如果某个字符数量检查情况中，出现数量 < 0，说明 ransomNote 针对该字母的数量比 magazine 多，也不是正确答案\"]},\"201\":{\"h\":\"关键点\",\"t\":[\"字母总数为 26 个\",\"哈希表计数或者数组计数\",\"同样的题目还有 242-有效的字母异位词\"]},\"202\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public boolean canConstruct(String ransomNote, String magazine) { if (ransomNote.length() > magazine.length()) { return false; } int[] cnt = new int[26]; for (char c : magazine.toCharArray()) { cnt[c - 'a']++; } for (char c : ransomNote.toCharArray()) { cnt[c - 'a']--; if (cnt[c - 'a'] < 0) { return false; } } return true; } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)，遍历字符串所需要的时间复杂度\",\"空间复杂度：O(S),定义存储的数组，固定长度，|S| <= 26;\"]},\"203\":{\"c\":[\"哈希表\"]},\"204\":{\"h\":\"454-四数相加 ii\"},\"205\":{\"h\":\"题目地址(454. 四数相加 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/4sum-ii/description/\"]},\"206\":{\"h\":\"题目描述\",\"t\":[\" 给你四个整数数组 nums1 、 nums2 、 nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\",\" 0 <= i, j, k, l < n \",\" nums1 [i] + nums2 [j] + nums3 [k] + nums4 [l] == 0 \",\" 示例 1：\",\" 输入： nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出： 2 解释： 两个元组如下： 1. (0, 0, 0, 1) -> nums1 [0] + nums2 [0] + nums3 [0] + nums4 [1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> nums1 [1] + nums2 [1] + nums3 [0] + nums4 [0] = 2 + (-1) + (-1) + 0 = 0 \",\" 示例 2：\",\" 输入： nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出： 1 \",\" 提示：\",\" n == nums1.length \",\" n == nums2.length \",\" n == nums3.length \",\" n == nums4.length \",\" 1 <= n <= 200 \",\"-2 28 <= nums1 [i], nums2 [i], nums3 [i], nums4 [i] <= 2 28 \"]},\"207\":{\"h\":\"前置知识\",\"t\":[\"两数之和思路\"]},\"208\":{\"h\":\"思路\",\"t\":[\"使用一个哈希表map存储 A 和 B 所有和sumAB的情况，其中 key 是和，value是和出现的次数\",\"使用同样的遍历方式，遍历 C + D，找到map是否存在 −(sumCD)。\",\"将 −(sumCD) 对应的值累加起来，就是答案。\"]},\"209\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { Map<Integer, Integer> countAB = new HashMap<Integer, Integer>(); for (int u : A) { for (int v : B) { countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1); } } int ans = 0; for (int u : C) { for (int v : D) { if (countAB.containsKey(-u - v)) { ans += countAB.get(-u - v); } } } return ans; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)：使用双重循环进行遍历求和，其中哈希表操作都是 O(1)\",\"空间复杂度：O(n2)：哈希表所用的空间，最坏情况下，A 和 B 数组中每个元素之和都不相同。\"]},\"210\":{\"c\":[\"哈希表\",\"数组\"]},\"211\":{\"h\":\"541-反转字符串 ii\"},\"212\":{\"h\":\"题目地址(541. 反转字符串 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/reverse-string-ii/description/\"]},\"213\":{\"h\":\"题目描述\",\"t\":[\" 给定一个字符串 s 和一个整数 k ，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\",\" 如果剩余字符少于 k 个，则将剩余字符全部反转。\",\" 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\",\" 示例 1：\",\" 输入： s = \\\"abcdefg\\\", k = 2 输出： \\\"bacdfeg\\\" \",\" 示例 2：\",\" 输入： s = \\\"abcd\\\", k = 2 输出： \\\"bacd\\\" \",\" 提示：\",\" 1 <= s.length <= 10 4 \",\" s 仅由小写英文组成 \",\" 1 <= k <= 10 4 \"]},\"214\":{\"h\":\"前置知识\",\"t\":[\"字符串\",\"双指针\"]},\"215\":{\"h\":\"思路\",\"t\":[\"使用 left 和 right 两个指针分别指向待反转的范围。\",\"每次翻转完，要更新 left 和 right 的范围。\",\"l = l + 2 * k\",\"r = l + k - 1\",\"指向下一个 2k 范围，然后再进行反转。\"]},\"216\":{\"h\":\"关键点\",\"t\":[\"双指针移动的更新\",\"最后一次翻转，r 有可能越界，因为要取 Math.min(r,n-1)\"]},\"217\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public String reverseStr(String s, int k) { char[] cs = s.toCharArray(); int n = s.length(); // l 和 r 分别指向待反转的范围 // 更新 l 和 r 要注意 不足 k 的情况。 // r 可能会 > n-1，此时应该是最后一次，而 l 还是会在索引范围内， // 极端的情况是 l = n-1，此时不需要翻转。 for (int l = 0; l < n; l = l + 2 * k) { int r = l + k - 1; reverse(cs, l, Math.min(r, n - 1)); } return String.valueOf(cs); } void reverse(char[] cs, int l, int r) { while (l < r) { char c = cs[l]; cs[l] = cs[r]; cs[r] = c; l++; r--; } } }\",\"复杂度分析\",\"令 n 为字符串长度。\",\"时间复杂度：O(n)。遍历的长度为字符串长度n。\",\"空间复杂度：O(n),因为Java语言不需要申请长度为n的数组来存储字符。\"]},\"218\":{\"c\":[\"字符串\",\"双指针\"]},\"219\":{\"h\":\"59-螺旋矩阵 II\"},\"220\":{\"h\":\"题目地址(59. 螺旋矩阵 II - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/spiral-matrix-ii/\"]},\"221\":{\"h\":\"题目描述\",\"t\":[\" 给你一个正整数 n ，生成一个包含 1 到 n 2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\",\" 示例 1：\",\" 输入： n = 3 输出： [[1,2,3], [8,9,4], [7,6,5]] \",\" 示例 2：\",\" 输入： n = 1 输出： [[1]] \",\" 提示：\",\" 1 <= n <= 20 \"]},\"222\":{\"h\":\"前置知识\",\"t\":[\"数组\",\"模拟\"]},\"223\":{\"h\":\"思路\",\"t\":[\"定义好上下左右四个边界 top, bottom, left, right\",\"按照题目进行模拟，从左到右（上边界缩减），从上到下（右边界缩减），从右到左（下边界缩减），从下到上（下边界缩减）\",\"使用 num<=tar 而不是 l<r∣∣t<b 作为迭代条件，是为了解决当 n 为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。 \",\"当 n = 3 时，填充到8时，此时 top==bottom ，就会导致退出循环，中心数字无法在迭代过程中被填充。\"]},\"224\":{\"h\":\"关键点\",\"t\":[\"边界变化条件\",\"循环终止条件\"]},\"225\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[][] generateMatrix(int n) { int left = 0, right = n-1, top = 0, bottom = n-1; int count = 1, target = n * n; int[][] res = new int[n][n]; //for循环中变量定义成i或j的细节：按照通常的思维，i代表行，j代表列 //这样，就可以很容易区分出来变化的量应该放在[][]的第一个还是第二个 //对于变量的边界怎么定义： //从左向右填充：填充的列肯定在[left,right]区间 //从上向下填充：填充的行肯定在[top,bottom]区间 //从右向左填充：填充的列肯定在[right,left]区间 //从下向上填充：填充的行肯定在[bootom,top]区间 //通过上面的总结会发现边界的起始和结束与方向是对应的 while(count <= target){ //从左到右填充，相当于缩小上边界 for(int j = left; j <= right; j++) res[top][j] = count++; //缩小上边界 top++; //从上向下填充，相当于缩小右边界 for(int i = top; i <=bottom; i++) res[i][right] = count++; //缩小右边界 right--; //从右向左填充，相当于缩小下边界 for(int j = right; j >= left; j--) res[bottom][j] = count++; //缩小下边界 bottom--; //从下向上填充，相当于缩小左边界 for(int i = bottom; i >= top; i--) res[i][left] = count++; //缩小左边界 left++; } return res; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n2)\",\"空间复杂度：O(1)\"]},\"226\":{\"h\":\"704-二分查找\"},\"227\":{\"h\":\"题目地址(704. 二分查找 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/binary-search/\"]},\"228\":{\"h\":\"题目描述\",\"t\":[\" 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target ，如果目标值存在返回下标，否则返回 -1 。\",\" 示例 1: \",\" 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 \",\" 示例 2: \",\" 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 \",\" 提示：\",\" 你可以假设 nums 中的所有元素是不重复的。\",\" n 将在 [1, 10000] 之间。\",\" nums 的每个元素都将在 [-9999, 9999] 之间。\"]},\"229\":{\"h\":\"前置知识\",\"t\":[\"数组\"]},\"230\":{\"h\":\"思路\",\"t\":[\"区间定义\",\"当我们选择「左闭右开」的时候，我们可以 0 来定义左边界(left)，而以数组的长度来定义右边界(right)，因此右边界我们是判断不到的。\",\"循环终止条件\",\"在左闭右开的情况，区间不为空，也就意味着 right 至少大于等于 left 。如果超过了这个条件，循环就终止。\",\"判断条件\",\"nums[mid]==target ，mid 就是我们要得到的结果，直接返回\",\"nums[mid]<target，我们应往右边的区间继续寻找，注意 mid 的位置我们是可以取到的，因此我们更新左边界的时候，应该为 left=mid+1\",\"nums[mid]>target，我们应往左边的区间找，而 mid 的位置明显不是答案，但是我们选择的是左闭右开区间，而右开所指向的位置本身就不在我们的候选区间里，所以 right=mid，而不是 right=mid−1.\",\"如果 mid−1 的位置正好是答案，在左闭右开的情况是找不到这个位置的\"]},\"231\":{\"h\":\"关键点\",\"t\":[\"左右区间的闭合\",\"左右区间的比较\"]},\"232\":{\"h\":\"代码\",\"t\":[\"Java Code:\",\" class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left) / 2; if(nums[mid] > target){ right = mid; }else if(nums[mid] < target) { left = mid +1 ; }else{ return mid; } } return -1; }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(logn)\",\"空间复杂度：O(1)\"]},\"233\":{\"h\":\"思路改进\",\"t\":[\"在 nums[mid]<target 和 nums[mid]==target 是可以合并起来的。当区间长度为 1 时，剩下的就是答案，由于 nums [mid] 可能等于答案，因此我们不能跳过这个 mid 的位置\",\"public int search(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right){ int mid = (right + left)/2; if(nums[mid] > target){ right = mid; }else{ left = mid; } } if(nums[l] == target){ return l; } return -1; }\"]},\"234\":{\"h\":\"左闭右必区间\",\"t\":[\"public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; while(left <= right){ // #1 int mid = (right + left) / 2; if(nums[mid] == target){ return mid; }else if(nums[mid] < target){ left = mid + 1; // #2 }else{ right = mid - 1; // #3 } } return -1; }\"]},\"235\":{\"c\":[\"数组\",\"二分查找\"]},\"236\":{\"h\":\"707-设计链表\"},\"237\":{\"h\":\"题目地址(707. 设计链表 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/design-linked-list/description/\"]},\"238\":{\"h\":\"题目描述\",\"t\":[\" 你可以选择使用单链表或者双链表，设计并实现自己的链表。\",\" 单链表中的节点应该具备两个属性： val 和 next 。 val 是当前节点的值， next 是指向下一个节点的指针/引用。\",\" 如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\",\" 实现 MyLinkedList 类：\",\" MyLinkedList() 初始化 MyLinkedList 对象。\",\" int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\",\" void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\",\" void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\",\" void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\",\" void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\",\" 示例：\",\" 输入 [\\\"MyLinkedList\\\", \\\"addAtHead\\\", \\\"addAtTail\\\", \\\"addAtIndex\\\", \\\"get\\\", \\\"deleteAtIndex\\\", \\\"get\\\"] [[], [1], [3], [1, 2], [1], [1], [1]] 输出 [null, null, null, null, 2, null, 3] 解释 MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // 链表变为 1-> 2-> 3 myLinkedList.get(1); // 返回 2 myLinkedList.deleteAtIndex(1); // 现在，链表变为 1-> 3 myLinkedList.get(1); // 返回 3 \",\" 提示：\",\" 0 <= index, val <= 1000 \",\" 请不要使用内置的 LinkedList 库。\",\" 调用 get 、 addAtHead 、 addAtTail 、 addAtIndex 和 deleteAtIndex 的次数不超过 2000 。\"]},\"239\":{\"h\":\"前置知识\",\"t\":[\"链表结果\",\"链表基本操作\"]},\"240\":{\"h\":\"思路: 单链表实现\",\"t\":[\"内部定义一个 Node 对象当成链表中的节点\",\"由于需要根据索引来查找节点，因此提供查询节点的方法 getNode()\"]},\"241\":{\"h\":\"关键点\",\"t\":[\"插入/删除节点，需要同时更新 size\"]},\"242\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class MyLinkedList { // 单向链表 class Node { int val; Node next; public Node(int val) { this.val = val; } } Node _head = new Node(-1); int size = 0; public MyLinkedList() { _head.next = null; } public int get(int index) { Node ret = getNode(index); return ret == null ? -1 : ret.val; } public void addAtHead(int val) { Node newNode = new Node(val); newNode.next = _head.next; _head.next = newNode; size++; } public void addAtTail(int val) { Node newNode = new Node(val); newNode.next = null; if (size == 0) { _head.next = newNode; } else { // 头节点 Node head = _head.next; // 遍历找到最后一个节点 while (head.next != null) { head = head.next; } // 最后一个节点的后驱节点是新节点 head.next = newNode; } size++; } public void addAtIndex(int index, int val) { if (index > size) { return; } if (index == size) { addAtTail(val); return; } Node newNode = new Node(val); Node indexNode = getNode(index - 1); newNode.next = indexNode.next; indexNode.next = newNode; size++; } public void deleteAtIndex(int index) { if (index >= size) { return; } if (index == 0) { _head.next = _head.next.next; } else { Node indexPreNode = getNode(index - 1); indexPreNode.next = indexPreNode.next.next; } size--; } Node getNode(int index) { if (index >= size) { return null; } Node head = _head; for (int i = 0; i <= index; i++) { head = head.next; } return head; } } /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList obj = new MyLinkedList(); * int param_1 = obj.get(index); * obj.addAtHead(val); * obj.addAtTail(val); * obj.addAtIndex(index, val); * obj.deleteAtIndex(index); */\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(n)\",\"空间复杂度：所有函数的单次调用空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"243\":{\"h\":\"思路：双链表实现\",\"t\":[\"实现双向链表，即每个节点要存储本身的值，「后继节点」和「前驱节点」。除此之外，需要一个「哨兵节点」作为头节点 head 和一个「哨兵节点」作为尾节点 tail。\"]},\"244\":{\"h\":\"关键点\",\"t\":[\"在遍历过程过程，从前往后遍历（当索引小于链表长度的一半时）还是从后往前遍历来优化查找效率。\",\"遍历时，每移动一次就减小 index 的值，当 index 为 0 时，说明找到了目标节点并返回。如果遍历结束没有找到，则返回 null。\"]},\"245\":{\"h\":\"代码\",\"t\":[\"class MyLinkedList { class Node { Node prev, next; int val; Node (int _val) { val = _val; } } Node head = new Node(-1), tail = new Node(-1); int size = 0; public MyLinkedList() { head.next = tail; tail.prev = head; } public int get(int index) { Node node = getNode(index); return node == null ? -1 : node.val; } public void addAtHead(int val) { Node node = new Node(val); node.next = head.next; node.prev = head; head.next.prev = node; head.next = node; size++; } public void addAtTail(int val) { Node node = new Node(val); node.prev = tail.prev; node.next = tail; tail.prev.next = node; tail.prev = node; size++; } public void addAtIndex(int index, int val) { if (index > sz) return ; if (index <= 0) { addAtHead(val); } else if (index == sz) { addAtTail(val); } else { Node node = new Node(val), cur = getNode(index); node.next = cur; node.prev = cur.prev; cur.prev.next = node; cur.prev = node; size++; } } public void deleteAtIndex(int index) { Node cur = getNode(index); if (cur == null) return ; cur.next.prev = cur.prev; cur.prev.next = cur.next; size--; } Node getNode(int index) { boolean isLeft = index < size / 2; if (!isLeft) index = size - index - 1; Node cur = isLeft ? head.next : tail.prev; for (; cur != tail && cur != head; cur = isLeft ? cur.next : cur.prev) { if (index-- == 0) return cur; } return null; } }\",\"复杂度分析\",\"令 n 为链表长度。\",\"时间复杂度：初始化消耗 O(1)，get 消耗 O(index)，addAtHead 消耗 O(1)，addAtTail 消耗 O(1)，addAtIndex 消耗 O(index)。\",\"空间复杂度：所有函数单次调用的空间复杂度均为 O(1)，总体空间复杂度为 O(n)，其中 n 为 addAtHead，addAtTail 和 addAtIndex 调用次数之和。\"]},\"246\":{\"c\":[\"链表\"]},\"247\":{\"h\":\"977-有序数组的平方\"},\"248\":{\"h\":\"题目地址(977. 有序数组的平方 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/squares-of-a-sorted-array/description/\"]},\"249\":{\"h\":\"题目描述\",\"t\":[\" 给你一个按 非递减顺序 排序的整数数组 nums ，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\",\" 示例 1：\",\" 输入： nums = [-4,-1,0,3,10] 输出： [0,1,9,16,100] 解释： 平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] \",\" 示例 2：\",\" 输入： nums = [-7,-3,2,3,11] 输出： [4,9,9,49,121] \",\" 提示：\",\" 1 <= nums.length <= 10 4 \",\"-10 4 <= nums [i] <= 10 4 \",\" nums 已按 非递减顺序 排序 \",\" 进阶：\",\" 请你 设计时间复杂度为 O(n) 的算法解决本问题 \"]},\"250\":{\"h\":\"前置知识\",\"t\":[\"双指针\"]},\"251\":{\"h\":\"思路\",\"t\":[\"使用两个指针分别指向位置 0 和 n−1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。\"]},\"252\":{\"h\":\"关键点\",\"t\":[\"平方大小的比较 = 绝对值大小的比较\",\"双指针指向相等时，任意放一个进入结果数组即可。\"]},\"253\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" class Solution { public int[] sortedSquares(int[] nums) { // 非递减 // 在正数，越大，平方也就越大 // 在负数，越小，平方越大 // 采用双指针，头尾比较 int left = 0; int right = nums.length - 1; int[] ret = new int[nums.length]; int index = right; while (left < right) { // 当left == right时，退出循环 if (Math.abs(nums[left]) < Math.abs(nums[right])) { ret[index--] = nums[right] * nums[right]; right--; } else if (Math.abs(nums[left]) > Math.abs(nums[right])) { ret[index--] = nums[left]*nums[left]; left++; }else if(Math.abs(nums[left]) == Math.abs(nums[right])){ ret[index--] = nums[right]*nums[right]; right--; } } ret[index] = nums[left]*nums[left]; return ret; } }\",\"复杂度分析\",\"令 n 为数组长度。\",\"时间复杂度：O(n)\",\"空间复杂度：O(1)，除了存储答案的数组以外，我们只需要维护常量空间。\"]},\"254\":{\"c\":[\"数组\",\"二分查找\"]},\"255\":{\"h\":\"LeetCode\",\"t\":[\"记录自己的刷题过程\"]},\"256\":{\"h\":\"哈希表基础理论\"},\"257\":{\"h\":\"哈希表是什么\",\"t\":[\"通过建立键 key 与值 value 之间的映射，实现高效的元素查询。就像每一个人的身份证对应一个人一样。\",\"数组\",\"链表\",\"哈希表\",\"查找元素\",\"O(1)\",\"O(n)\",\"O(1)\",\"添加元素\",\"O(n)\",\"O(1)\",\"O(1)\",\"删除元素\",\"O(n)\",\"O(1)\",\"O(1)\"]},\"258\":{\"h\":\"哈希函数\",\"t\":[\"通过某种算法将 value 映射到 key上。\",\"比如\",\"当我们使用数组实现哈希表时，会将所有的key能映射到数组上对应的索引，数组元素则是对应的value\",\"index = hash(key) % cap\",\"图片来自：hello-algo\"]},\"259\":{\"h\":\"哈希冲突\",\"t\":[\"理论上一定存在“多个输入对应相同输出”的情况，将这种情况视为“哈希冲突”。\"]},\"260\":{\"h\":\"拉链法\",\"t\":[\"冲突的位置存储在链表中。\"]},\"261\":{\"h\":\"线性探测法\",\"t\":[\"在冲突的地方继续往前查询，直到查询到不冲突，就放入对应的索引中。\"]},\"262\":{\"c\":[\"哈希表\"]},\"263\":{\"h\":\"数组总结篇\"},\"264\":{\"h\":\"什么是数组？\",\"t\":[\"数组是存放在「连续内存空间」上的「相同类型数据」的集合。\"]},\"265\":{\"h\":\"数组的特点\",\"t\":[\"索引从 0 开始\",\"内存地址是连续\",\"访问元素：O(1)\",\"插入和删除元素: O(n)\"]},\"266\":{\"h\":\"二分法\"},\"267\":{\"h\":\"二分查找模板 1\",\"t\":[\"public int binarySearch(int[] nums, int target){ int left = 0; int right = nums.length - 1; // 注意 1 while(left <= right){ // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target){ return mid; } else if(nums[mid] < target) { left = mid + 1; // 注意 }else if(nums[mid] > target){ right = mid - 1; // 注意 } } // End Condition: left > right return -1; }\",\"初始化条件：left = 0, right = nums.length - 1 ，相当于闭区间 [left,right]，而这个区间就是我们的「搜索区间」\",\"循环停止条件：\",\"nums[mid] == target\",\"如果没有找到的情况下，「搜索区间」不存在。即 left > right => [right+1,right] ，区间不存在\",\" 如果非要用 while(left < right)，我该怎么办？\",\" //... while(left < right) { // ... } return nums [left] == target ? left : -1; \",\" 分析如下：\",\" 当退出循环时，存在 left == right ，不管是因为什么原因导致的， 左元素还是右元素最终有一个没做判断 \",\" left = mid + 1 ，所以才有 left == right 退出循环 \",\" right = mid - 1 ，所以才有 left == right 退出循环 \",\"向左查找，向右查找：在上面的「搜索区间」情况下，当 nums[mid] 查找不到时，此时 mid 已经被判断了。因此下次「搜索区间」应该是 [left,mid−1] 或者 [mid+1,right]\"]},\"268\":{\"h\":\"二分查找模版 2：找满足条件的最左侧的值\",\"t\":[\"int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left < right) { // 注意 int mid = (left + right) / 2; if (nums[mid] == target) { right = mid; } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; // 注意 } } return left; }\",\"初始化条件：left = 0, right = nums.length ，每次循环的「搜索区间」是 [left, right) 左闭右开\",\"循环停止条件：left == right，[left,left) 区间为空，搜索停止。\",\"向左查找：nums[mid] > target，nums[mid] == target 都会改变 right 的值。其实相当于告诉我们 nums[mid]的值都在target的右侧。只有这样做，我们才能不断地 缩小「搜索区间」的上界right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\",\"如果 target 在数组中，最后返回的结果 left 表示，数组中小于 target 的元素有 left 个，也可以表示 target 最左的下标为 left\",\"如果 target 不在数组中，假设一种极端情况\",\"[2,5,7,8] target = 1\",\"在循环过程中，left 一直保持不变，而 right 一直向左边靠近，最终 left == right 最后循环，最后返回 left = 0。\",\"含义是：数组中小于 1 的元素有 0 个。\",\"综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间[0,nums.length]\",\"while (left < right) { //... } // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1; //if(left != nums.length && nums [left] == target){ //return left; //} //return -1;\"]},\"269\":{\"h\":\"二分查找模版 3：找满足条件的最右侧的值\",\"t\":[\"public int search(int[] nums,int target){ int left = 0; int right = nums.length; while(left < right){ int mid = left + (right - left) / 2; if (nums[mid] == target) { left = mid + 1; // 注意 } else if (nums[mid] < target) { left = mid + 1; } else if (nums[mid] > target) { right = mid; } } if(left != 0 && nums[left-1] == target){ return left - 1; } return -1; }\",\"当 nums[mid] == target 时，不要立即返回，而是 增大「搜索区间」的下界**left**，使得区间不断向右收缩，达到锁定右侧边界的目的。\",\"由于我们更新 left 是 left = mid + 1，那就出现一种情况，left = mid + 1 = right 越界退出循环。\",\"nums[left] 一定不等于 target，否则也不会导致 left = mid+ 1 的操作发生\",\"nums[left-1] 有可能是 target，所以要进行 后处理检查\"]},\"270\":{\"h\":\"双指针法\",\"t\":[\"双指针法（快慢指针法）：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\"]},\"271\":{\"h\":\"滑动窗口\",\"t\":[\"根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O(n2) 的暴力解法降为 O(n)。\",\"最小/最大子数组问题\",\"字符串模式匹配问题\",\"固定长度的子数组/子字符串问题\",\"固定长度的子数组/子字符串问题\"]},\"272\":{\"h\":\"模拟行为\",\"t\":[\"模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟。\",\"循环不变量原则，其实这也是写程序中的重要原则。\"]},\"273\":{\"h\":\"栈理论基础篇\"},\"274\":{\"h\":\"理论\",\"t\":[\"堆栈是一种抽象数据类型，用作元素的集合，具有两个主要的操作；\",\"PUSH：将元素添加到集合\",\"POP：删除最近添加但尚未删除的元素\",\"栈是一种 LIFO（后进先出）的线性的数据结构，push 和 pop 操作只发生在结构的一端，称为栈顶。\",\"在 Java 中，Stack 类是很粗糙的，源码中推荐使用 ArrayDeque 去替代。\"]},\"275\":{\"h\":\"ArrayDeque\",\"t\":[\"基于数组实现的双端队列\",\"ArrayDeque 允许在其头部和尾部进行高效地添加和移除元素，它可以用作栈（LIFO，后进先出）\",\"当空间不足时，它会自动进行扩容操作，通常扩容后的容量是原容量的两倍\"]},\"276\":{\"h\":\"问题\",\"t\":[\"堆栈的使用场景？\",\"为什么不是用 Stack 类？\",\"ArrayDeque 是基于什么实现的？\",\"ArrayDeque 数据结构使用过程叙述。\",\"ArrayDeque 为什么要初始化2的n次幂个长度？\"]},\"277\":{\"c\":[\"栈\"]},\"278\":{\"h\":\"链表总结篇\"},\"279\":{\"h\":\"虚拟头节点\",\"t\":[\"203-移除链表元素\",\"通过添加虚拟头节点的方式，可以很方便进行删除操作。\"]},\"280\":{\"h\":\"快慢指针\",\"t\":[\"206-翻转链表\"]},\"281\":{\"h\":\"删除倒数第 N 个节点\",\"t\":[\"19-删除倒数第 N 个节点 结合虚拟头结点 和 双指针法来移除链表倒数第 N 个节点\",\"交换链表中的节点\",\"删除链表 M 个节点之后的 N 个节点\",\"删除链表的中间节点\"]},\"282\":{\"h\":\"链表的基本操作\",\"t\":[\"707-设计链表\",\"获取链表第 index 个节点的数值\",\"在链表的最前面插入一个节点\",\"在链表的最后面插入一个节点\",\"在链表第 index 个节点前面插入一个节点\",\"删除链表的第 index 个节点的数值\"]},\"283\":{\"h\":\"链表相交\",\"t\":[\"面试题 02.07-链表相交\"]},\"284\":{\"h\":\"环形链表\",\"t\":[\"这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。\",\"142-环形链表-ii\"]},\"285\":{\"c\":[\"链表\"]},\"286\":{\"h\":\"链表理论基础\"},\"287\":{\"h\":\"链表是什么？\",\"t\":[\"链表是一种通过指针串联在一起的线性结构\",\"每一个节点由两部分组成，一部分是「数据域」，一部分是「指针域」，最后一个节点的指针域指向 null\"]},\"288\":{\"h\":\"链表类型\"},\"289\":{\"h\":\"单链表\",\"t\":[\"​ \"]},\"290\":{\"h\":\"双链表\",\"t\":[\"每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\"]},\"291\":{\"h\":\"循环链表\",\"t\":[\"循环链表，顾名思义，就是链表首尾相连。\"]},\"292\":{\"h\":\"链表存储方式\",\"t\":[\"链表在内存中可不是连续分布的。\",\"链表是通过「指针域的指针」链接在内存中各个节点，每个节点存放着下一个节点的内存地址。\",\"链表的组成单位是 Node 对象\",\"/* 链表节点类 */ class ListNode { int val; // 节点值 ListNode next; // 指向下一节点的引用 ListNode(int x) { val = x; } // 构造函数 }\"]},\"293\":{\"h\":\"链表操作\"},\"294\":{\"h\":\"头插节点\",\"t\":[\"记录头节点\",\"创建新节点，新节点的头节点为null\",\"新节点的 next 为 「步骤1」的头节点\",\"「步骤1」的前驱节点为 新节点\",\"void linkFirst(E e) { final Node<E> f = first; // 头节点 final Node<E> newNode = new Node<>(null, e, f); // 新节点，后驱节点是f first = newNode; // 现在头节点是新节点 if (f == null) // 如果之前的头节点为null last = newNode; // 那么现在头节点和尾节点都是 新节点 else f.prev = newNode; // 之间的头节点的前驱节点是新节点 size++; }\",\"图片来自：bugstack.cn\"]},\"295\":{\"h\":\"尾插节点\",\"t\":[\"void linkLast(E e) { final Node<E> l = last; final Node<E> newNode = new Node<>(l, e, null); last = newNode; if (l == null) { first = newNode; } else { l.next = newNode; } size++; }\",\"图片来自：bugstack.cn\"]},\"296\":{\"h\":\"拆链操作\",\"t\":[\"E unlink(Node<E> x) { final E element = x.item; final Node<E> next = x.next; final Node<E> prev = x.prev; if (prev == null) { first = next; } else { prev.next = next; x.prev = null; } if (next == null) { last = prev; } else { next.prev = prev; x.next = null; } x.item = null; size--; return element; }\",\"图片来自：bugstack.cn\"]},\"297\":{\"h\":\"删除节点\",\"t\":[\"public boolean remove(Object o) { if (o == null) { for (Node<E> x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { for (Node<E> x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; }\",\"图片来自：bugstack.cn\"]},\"298\":{\"h\":\"链表性能分析\",\"t\":[\"插入/删除为 O(1)\",\"查询为O(n)\"]},\"299\":{\"h\":\"问题\",\"t\":[\"描述一下链表的数据结构？\",\"Java 中 LinkedList 使用的是单向链表、双向链表还是循环链表？\",\"链表中数据的插入、删除、获取元素，时间复杂度是多少？\",\"什么场景下使用链表更合适？\"]},\"300\":{\"c\":[\"链表\"]},\"301\":{\"h\":\"队列理论基础篇\"},\"302\":{\"h\":\"理论\",\"t\":[\"一个 队列(queue) 是一种特殊类型的抽象数据类型或集合。集合中的实体按顺序保存。\",\"队列既可以是数组实现也可以是链表实现。\",\"在 Java 中 Queue 是单端队列接口\",\"在 Java 中 Deque 是双端队列接口\"]},\"303\":{\"h\":\"题目\",\"t\":[\"单端队列和双端队列，分别对应的实现类是哪个？\",\"单端队列遵循先进先出（FIFO）原则，主要通过实现 java.util.Queue 接口来定义，通常使用 java.util.LinkedList 来作为 Queue 的实现模拟单端队列行为。\",\"双端队列（Deque，全称为 Double Ended Queue）是一种允许在其两端进行插入和删除的线性数据结构。\",\"它可以被用作栈，也可以用作队列。双端队列的直接实现类是 java.util.Deque 接口，而常用的实现类是 java.util.ArrayDeque 和 java.util.LinkedList。\",\"简述延迟队列/优先队列的实现方式\",\"优先队列（PriorityQueue）的底层实现是一个二叉堆，通常是最大堆。\",\"最大堆的特点是父节点的优先级总是 >= 其子节点的优先级。为了支持优先级的比较，会实现一个 Comparable 接口或者提供一个 Comparator。\",\"延迟队列（Delay Queue）是一种特殊类型的优先队列，它根据元素的延迟时间来决定元素的优先级。它基于优先队列（PriorityQueue）实现的，用于处理具有过期时间（delay）的任务。\",\"队列里面的元素实现了 java.util.concurrent.Delayed 接口\",\"内部使用一个 PriorityQueue 来存储元素\",\"二叉堆插入/弹出元素的过程\",\"二叉堆(基于数组）插入元素的过程\",\"public void insert(int element) { heap.add(element); // 添加一个元素在数组末尾 int currentIndex = heapArray.size() - 1; // 当前节点位置 int parentIndex = (currentIndex - 1) / 2; // 当前节点的父节点位置 // Compare and swap with parent until the heap property is restored // 当子节点小于父节点，交换他们的元素（最大堆） // 继续比较其节点和其父节点 while (currentIndex > 0 && heap.get(currentIndex) < heap.get(parentIndex)) { swap(currentIndex, parentIndex); currentIndex = parentIndex; parentIndex = (currentIndex - 1) / 2; } }\",\"二叉堆(基于数组）弹出元素的过程\",\"public int pop() { if (heap.isEmpty()) { throw new IllegalStateException(\\\"堆为空！\\\"); } int poppedElement = heap.get(0); // 弹出的元素 heap.set(0, heap.get(heapArray.size() - 1)); // 将数组尾元素替换根元素，并删除旧的数组尾元素 heap.remove(heap.size() - 1); int currentIndex = 0; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; // 比较并交换与较大子节点，直到满足最大堆的性质 while (leftChildIndex < heapArray.size()) { int largerChildIndex = leftChildIndex; if (rightChildIndex < heapArray.size() && heapArray.get(rightChildIndex) > heapArray.get(leftChildIndex)) { largerChildIndex = rightChildIndex; } // 已经满足最大堆的性质 if (heapArray.get(currentIndex) > heapArray.get(largerChildIndex)) { break; } swap(currentIndex, largerChildIndex); currentIndex = largerChildIndex; leftChildIndex = 2 * currentIndex + 1; rightChildIndex = 2 * currentIndex + 2; } return poppedElement; }\",\"延迟队列的使用场景\",\"订单超时处理：在线购物平台中，当用户下单后，系统可能会设置一个延迟队列，如果订单在 30 分钟或 1 小时内未完成支付，则自动取消订单并释放锁定的库存。\",\"定时任务触发：如定期发送报告、数据同步、缓存刷新等操作可以在特定时间点通过延迟队列自动触发执行。\",\"短信或邮件通知：在用户注册、下单等操作后，系统不立即发送确认短信或邮件，而是在用户操作后的几分钟或更长时间后再发送，以避免即时发送失败或对用户体验造成干扰。\",\"延迟队列为什么要添加信号量\",\"信号量用于控制对共享资源的访问，尤其是当涉及到 多个线程访问有限资源 时。它通过维护一个 计数器 来实现这一功能，允许一定数量的并发访问，并且其他请求访问的线程必须等待直到计数器非零。\",\"流量控制：通过信号量限制生产者向延迟队列中添加消息的速度，可以实现流量控制，确保队列不会被过快填满，从而维持系统的稳定运行。\",\"资源访问同步：如果队列某些操作（如调整队列参数、查询队列状态）需要独占访问，信号量可以用来同步这些操作，确保同一时间只有一个线程能执行此类操作，防止数据不一致性或竞态条件。\"]},\"304\":{\"c\":[\"队列\"]},\"305\":{\"h\":\"面试题02.07-链表相交\"},\"306\":{\"h\":\"题目地址(面试题 02.07. 链表相交 - 力扣（LeetCode）)\",\"t\":[\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\"]},\"307\":{\"h\":\"题目描述\",\"t\":[\" 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\",\" 图示两个链表在节点 c1 开始相交 ：\",\" 题目数据 保证 整个链式结构中不存在环。\",\" 注意 ，函数返回结果后，链表必须 保持其原始结构 。\",\" 示例 1：\",\" 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出： Intersected at '8' 解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 \",\" 示例 2：\",\" 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出： Intersected at '2' 解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 \",\" 示例 3：\",\" 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出： null 解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 \",\" 提示：\",\" listA 中节点数目为 m \",\" listB 中节点数目为 n \",\" 0 <= m, n <= 3 * 10 4 \",\" 1 <= Node.val <= 10 5 \",\" 0 <= skipA <= m \",\" 0 <= skipB <= n \",\" 如果 listA 和 listB 没有交点， intersectVal 为 0 \",\" 如果 listA 和 listB 有交点， intersectVal == listA [skipA + 1] == listB [skipB + 1] \",\" 进阶： 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\"]},\"308\":{\"h\":\"前置知识\",\"t\":[\"双指针\",\"链表\",\"哈希表\"]},\"309\":{\"h\":\"思路\",\"t\":[\"相交部分长度为 c，listA 长度为 a，listb 长度为 b。\",\"有两个变量 headA、headB 分别从 listA、listB 分别出发。\",\"当 headA 走完 listA 时，从 headB 继续走。\",\"当 headB 走完 listB 时，从 headA 继续走。\",\"headA == headB 时就是相交节点\",\"headA 共走了 a+（b-c）\",\"headB 共走了 b+（a-c）\",\"若两链表 有 公共尾部 (即 c > 0 ) ：指针 A, B 同时指向第一个相交节点。\",\"若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。\"]},\"310\":{\"h\":\"关键点\",\"t\":[\"双指针遍历各自所在链表后，在遍历对方的链表，第一次「相等」就是相交点\",\"「相等」有可能两个指针都指向 null\"]},\"311\":{\"h\":\"代码\",\"t\":[\"语言支持：Java\",\"Java Code:\",\" /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } // A 链长度为 a // B 链长度为 b // A 和 B 重叠的链长度为 c // A 相交的位置在 a+b-c // B 相交的位置在 b+a-c ListNode first = headA; ListNode second = headB; while(first != second){ // 循环终止条件 first = first == null? headB:first.next; second = second == null? headA:second.next; } return first; } }\",\"复杂度分析\",\"令 a 为 listA 长度，b 为 listB 长度\",\"时间复杂度：O(a+b)，最差情况下（即 ∣a−b∣=1 , c=0 ），此时需遍历 a+b 个节点。\",\"空间复杂度：O(1)\"]},\"312\":{\"c\":[\"链表\"]},\"313\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"314\":{\"h\":\"About\"}},\"dirtCount\":0,\"index\":[[\"∣a−b∣=1\",{\"1\":{\"311\":1}}],[\"重叠的链长度为\",{\"1\":{\"311\":1}}],[\"重复答案\",{\"1\":{\"69\":1}}],[\"重复项删除操作\",{\"1\":{\"46\":1}}],[\"无\",{\"1\":{\"309\":1}}],[\"无限循环\",{\"1\":{\"108\":1}}],[\"公共尾部\",{\"1\":{\"309\":2}}],[\"公司\",{\"0\":{\"191\":1}}],[\"共走了\",{\"1\":{\"309\":2}}],[\"没有交点\",{\"1\":{\"307\":1}}],[\"没有的字母\",{\"1\":{\"200\":1}}],[\"必须为\",{\"1\":{\"307\":1}}],[\"保持其原始结构\",{\"1\":{\"307\":1}}],[\"保证\",{\"1\":{\"307\":1}}],[\"函数返回结果后\",{\"1\":{\"307\":1}}],[\"函数的返回值\",{\"1\":{\"268\":1}}],[\"函数的嵌套调用\",{\"1\":{\"110\":1}}],[\"图示两个链表在节点\",{\"1\":{\"307\":1}}],[\"图片来自\",{\"1\":{\"128\":1,\"258\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1}}],[\"图片引入\",{\"1\":{\"32\":1}}],[\"图片增强\",{\"0\":{\"24\":1}}],[\"防止数据不一致性或竞态条件\",{\"1\":{\"303\":1}}],[\"信号量可以用来同步这些操作\",{\"1\":{\"303\":1}}],[\"信号量用于控制对共享资源的访问\",{\"1\":{\"303\":1}}],[\"资源访问同步\",{\"1\":{\"303\":1}}],[\"确保同一时间只有一个线程能执行此类操作\",{\"1\":{\"303\":1}}],[\"确保队列不会被过快填满\",{\"1\":{\"303\":1}}],[\"确保当前结点后还有结点\",{\"1\":{\"119\":1,\"122\":1}}],[\"流量控制\",{\"1\":{\"303\":1}}],[\"允许一定数量的并发访问\",{\"1\":{\"303\":1}}],[\"允许在其头部和尾部进行高效地添加和移除元素\",{\"1\":{\"275\":1}}],[\"尤其是当涉及到\",{\"1\":{\"303\":1}}],[\"系统不立即发送确认短信或邮件\",{\"1\":{\"303\":1}}],[\"系统可能会设置一个延迟队列\",{\"1\":{\"303\":1}}],[\"短信或邮件通知\",{\"1\":{\"303\":1}}],[\"缓存刷新等操作可以在特定时间点通过延迟队列自动触发执行\",{\"1\":{\"303\":1}}],[\"定时任务触发\",{\"1\":{\"303\":1}}],[\"定义好上下左右四个边界\",{\"1\":{\"223\":1}}],[\"定义存储的数组\",{\"1\":{\"202\":1}}],[\"定义一个长度为\",{\"1\":{\"200\":1}}],[\"定义两个指针\",{\"1\":{\"139\":1}}],[\"定义两个指针slow和fast\",{\"1\":{\"110\":1}}],[\"定义为\",{\"1\":{\"108\":1}}],[\"定义三个指针\",{\"1\":{\"67\":1}}],[\"小时内未完成支付\",{\"1\":{\"303\":1}}],[\"订单超时处理\",{\"1\":{\"303\":1}}],[\"弹出的元素\",{\"1\":{\"303\":1}}],[\"弹出元素的过程\",{\"1\":{\"303\":2}}],[\"堆为空\",{\"1\":{\"303\":1}}],[\"堆栈的使用场景\",{\"1\":{\"276\":1}}],[\"堆栈是一种抽象数据类型\",{\"1\":{\"274\":1}}],[\"基于数组\",{\"1\":{\"303\":2}}],[\"基于数组实现的双端队列\",{\"1\":{\"275\":1}}],[\"二叉堆\",{\"1\":{\"303\":2}}],[\"二叉堆插入\",{\"1\":{\"303\":1}}],[\"二分法\",{\"0\":{\"266\":1}}],[\"二分查找模版\",{\"0\":{\"268\":1,\"269\":1}}],[\"二分查找模板\",{\"0\":{\"267\":1}}],[\"二分查找\",{\"0\":{\"226\":1,\"227\":1},\"2\":{\"235\":1,\"254\":1}}],[\"延迟队列为什么要添加信号量\",{\"1\":{\"303\":1}}],[\"延迟队列的使用场景\",{\"1\":{\"303\":1}}],[\"延迟队列\",{\"1\":{\"303\":1}}],[\"优先队列\",{\"1\":{\"303\":1}}],[\"优先队列的实现方式\",{\"1\":{\"303\":1}}],[\"简述延迟队列\",{\"1\":{\"303\":1}}],[\"接口或者提供一个\",{\"1\":{\"303\":1}}],[\"接口\",{\"1\":{\"303\":2}}],[\"接口来定义\",{\"1\":{\"303\":1}}],[\"全称为\",{\"1\":{\"303\":1}}],[\"原则\",{\"1\":{\"303\":1}}],[\"原地\",{\"1\":{\"73\":1,\"173\":1,\"175\":1,\"181\":1}}],[\"集合中的实体按顺序保存\",{\"1\":{\"302\":1}}],[\"什么场景下使用链表更合适\",{\"1\":{\"299\":1}}],[\"什么是数组\",{\"0\":{\"264\":1}}],[\"获取元素\",{\"1\":{\"299\":1}}],[\"获取链表第\",{\"1\":{\"282\":1}}],[\"获取链表中下标为\",{\"1\":{\"238\":1}}],[\"描述一下链表的数据结构\",{\"1\":{\"299\":1}}],[\"拆链操作\",{\"0\":{\"296\":1}}],[\"尾插节点\",{\"0\":{\"295\":1}}],[\"尾随空格或者单词间的多个空格\",{\"1\":{\"73\":1}}],[\"创建新节点\",{\"1\":{\"294\":1}}],[\"创建一个虚拟头结点\",{\"1\":{\"122\":1}}],[\"创建一个双端队列存放右括号\",{\"1\":{\"104\":1}}],[\"创建一个哈希表\",{\"1\":{\"40\":1}}],[\"构造函数\",{\"1\":{\"292\":1}}],[\"构建文档\",{\"1\":{\"4\":1}}],[\"节点值\",{\"1\":{\"292\":1}}],[\"顾名思义\",{\"1\":{\"291\":1}}],[\"​\",{\"1\":{\"289\":1}}],[\"寻找公共尾部入口等\",{\"1\":{\"284\":1}}],[\"寻找环入口\",{\"1\":{\"284\":1}}],[\"寻找交集元素\",{\"1\":{\"194\":1}}],[\"面试题02\",{\"0\":{\"305\":1}}],[\"面试题\",{\"0\":{\"306\":1},\"1\":{\"283\":1}}],[\"结合虚拟头结点\",{\"1\":{\"281\":1}}],[\"结果为\",{\"1\":{\"108\":1}}],[\"问题\",{\"0\":{\"276\":1,\"299\":1}}],[\"通常是最大堆\",{\"1\":{\"303\":1}}],[\"通常使用\",{\"1\":{\"303\":1}}],[\"通常扩容后的容量是原容量的两倍\",{\"1\":{\"275\":1}}],[\"通过信号量限制生产者向延迟队列中添加消息的速度\",{\"1\":{\"303\":1}}],[\"通过添加虚拟头节点的方式\",{\"1\":{\"279\":1}}],[\"通过一个快指针和慢指针在一个\",{\"1\":{\"270\":1}}],[\"通过某种算法将\",{\"1\":{\"258\":1}}],[\"通过建立键\",{\"1\":{\"257\":1}}],[\"通过上面的总结会发现边界的起始和结束与方向是对应的\",{\"1\":{\"225\":1}}],[\"通过反复调用\",{\"1\":{\"110\":1}}],[\"通过排序容易找到相同的三元组答案\",{\"1\":{\"68\":1}}],[\"通过查询\",{\"1\":{\"40\":1}}],[\"通过\",{\"1\":{\"15\":1,\"18\":1,\"173\":1}}],[\"源码中推荐使用\",{\"1\":{\"274\":1}}],[\"称为栈顶\",{\"1\":{\"274\":1}}],[\"具有两个主要的操作\",{\"1\":{\"274\":1}}],[\"根据当前子序列和大小的情况\",{\"1\":{\"271\":1}}],[\"达到锁定右侧边界的目的\",{\"1\":{\"269\":1}}],[\"达到锁定左侧边界的目的\",{\"1\":{\"268\":1}}],[\"增大\",{\"1\":{\"269\":1}}],[\"增大总和\",{\"1\":{\"69\":1}}],[\"取值区间是闭区间\",{\"1\":{\"268\":1}}],[\"取消注释下一行\",{\"1\":{\"4\":1}}],[\"变量的值\",{\"1\":{\"268\":1}}],[\"变动情况\",{\"1\":{\"67\":1}}],[\"综上可以看出\",{\"1\":{\"268\":1}}],[\"含义是\",{\"1\":{\"268\":1}}],[\"表示\",{\"1\":{\"268\":1}}],[\"应该是\",{\"1\":{\"267\":1}}],[\"应该为\",{\"1\":{\"230\":1}}],[\"情况下\",{\"1\":{\"267\":1}}],[\"向右查找\",{\"1\":{\"267\":1}}],[\"向左查找\",{\"1\":{\"267\":1,\"268\":1}}],[\"我该怎么办\",{\"1\":{\"267\":1}}],[\"我们才能不断地\",{\"1\":{\"268\":1}}],[\"我们只需要维护常量空间\",{\"1\":{\"253\":1}}],[\"我们只需要遍历该字符串一次\",{\"1\":{\"50\":1,\"53\":1}}],[\"我们应往左边的区间找\",{\"1\":{\"230\":1}}],[\"我们应往右边的区间继续寻找\",{\"1\":{\"230\":1}}],[\"我们可以\",{\"1\":{\"189\":1,\"230\":1}}],[\"我们可以删除\",{\"1\":{\"46\":1}}],[\"我们先要排序\",{\"1\":{\"67\":1}}],[\"我们无论是先删除哪一个\",{\"1\":{\"48\":1}}],[\"搜索停止\",{\"1\":{\"268\":1}}],[\"搜索区间\",{\"1\":{\"267\":4,\"268\":2,\"269\":1}}],[\"搜索首个空格\",{\"1\":{\"78\":1}}],[\"访问元素\",{\"1\":{\"265\":1}}],[\"连续内存空间\",{\"1\":{\"264\":1}}],[\"线性探测法\",{\"0\":{\"261\":1}}],[\"线性遍历字符串\",{\"1\":{\"76\":1,\"78\":1}}],[\"冲突的位置存储在链表中\",{\"1\":{\"260\":1}}],[\"拉链法\",{\"0\":{\"260\":1}}],[\"理论\",{\"0\":{\"274\":1,\"302\":1}}],[\"理论上一定存在\",{\"1\":{\"259\":1}}],[\"理解递归\",{\"1\":{\"132\":1}}],[\"比较并交换与较大子节点\",{\"1\":{\"303\":1}}],[\"比所有数都大\",{\"1\":{\"268\":1}}],[\"比如\",{\"1\":{\"258\":1}}],[\"比长度更大\",{\"1\":{\"238\":1}}],[\"映射到\",{\"1\":{\"258\":1}}],[\"哈希冲突\",{\"0\":{\"259\":1},\"1\":{\"259\":1}}],[\"哈希函数\",{\"0\":{\"258\":1}}],[\"哈希表是什么\",{\"0\":{\"257\":1}}],[\"哈希表基础理论\",{\"0\":{\"256\":1}}],[\"哈希表所用的空间\",{\"1\":{\"209\":1}}],[\"哈希表计数或者数组计数\",{\"1\":{\"201\":1}}],[\"哈希表记录\",{\"0\":{\"167\":1}}],[\"哈希表存储元素的开销\",{\"1\":{\"42\":1}}],[\"哈希表存储的\",{\"1\":{\"41\":1}}],[\"哈希表\",{\"1\":{\"39\":1,\"85\":1,\"109\":1,\"166\":1,\"199\":1,\"257\":1,\"308\":1},\"2\":{\"43\":1,\"113\":1,\"170\":1,\"195\":1,\"203\":1,\"210\":1,\"262\":1}}],[\"查询队列状态\",{\"1\":{\"303\":1}}],[\"查询为o\",{\"1\":{\"298\":1}}],[\"查找不到时\",{\"1\":{\"267\":1}}],[\"查找元素\",{\"1\":{\"257\":1}}],[\"查看详情\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"22\":1,\"23\":1,\"24\":1,\"25\":1}}],[\"退出循环\",{\"1\":{\"253\":1,\"267\":2}}],[\"采用双指针\",{\"1\":{\"253\":1}}],[\"采用双指针的方式\",{\"1\":{\"61\":1}}],[\"越界退出循环\",{\"1\":{\"269\":1}}],[\"越小\",{\"1\":{\"253\":1}}],[\"越大\",{\"1\":{\"253\":1}}],[\"绝对值大小的比较\",{\"1\":{\"252\":1}}],[\"平方越大\",{\"1\":{\"253\":1}}],[\"平方也就越大\",{\"1\":{\"253\":1}}],[\"平方大小的比较\",{\"1\":{\"252\":1}}],[\"平方后\",{\"1\":{\"249\":1}}],[\"选择较大的那个逆序放入答案并移动指针\",{\"1\":{\"251\":1}}],[\"选项卡\",{\"0\":{\"19\":1}}],[\"已经满足最大堆的性质\",{\"1\":{\"303\":1}}],[\"已经被判断了\",{\"1\":{\"267\":1}}],[\"已经把链表分成后两部分\",{\"1\":{\"132\":1}}],[\"已按\",{\"1\":{\"249\":1}}],[\"非递减\",{\"1\":{\"253\":1}}],[\"非递减顺序\",{\"1\":{\"249\":3}}],[\"非字母异位词\",{\"1\":{\"167\":2}}],[\"哨兵节点\",{\"1\":{\"243\":2}}],[\"除了存储答案的数组以外\",{\"1\":{\"253\":1}}],[\"除此之外\",{\"1\":{\"243\":1}}],[\"除去开头和末尾的空白字符\",{\"1\":{\"76\":1}}],[\"后进先出\",{\"1\":{\"274\":1,\"275\":1}}],[\"后处理检查\",{\"1\":{\"269\":1}}],[\"后继节点\",{\"1\":{\"243\":1}}],[\"后驱节点是f\",{\"1\":{\"294\":1}}],[\"后驱节点\",{\"1\":{\"130\":1}}],[\"总体空间复杂度为\",{\"1\":{\"242\":1,\"245\":1}}],[\"总体是线性复杂度\",{\"1\":{\"61\":1}}],[\"消耗\",{\"1\":{\"242\":3,\"245\":4}}],[\"头插节点\",{\"0\":{\"294\":1}}],[\"头尾比较\",{\"1\":{\"253\":1}}],[\"头节点\",{\"1\":{\"242\":1,\"294\":1}}],[\"头结点要特殊处理\",{\"1\":{\"118\":1}}],[\"调用次数之和\",{\"1\":{\"242\":1,\"245\":1}}],[\"调用\",{\"1\":{\"238\":1}}],[\"调用你的实现\",{\"1\":{\"173\":1}}],[\"库\",{\"1\":{\"238\":1}}],[\"现在头节点是新节点\",{\"1\":{\"294\":1}}],[\"现在\",{\"1\":{\"238\":1}}],[\"该节点将\",{\"1\":{\"238\":1}}],[\"等于链表的长度\",{\"1\":{\"238\":1}}],[\"新节点\",{\"1\":{\"294\":3}}],[\"新节点的\",{\"1\":{\"294\":1}}],[\"新节点的头节点为null\",{\"1\":{\"294\":1}}],[\"新节点会成为链表的第一个节点\",{\"1\":{\"238\":1}}],[\"新的头节点\",{\"1\":{\"116\":1}}],[\"单端队列遵循先进先出\",{\"1\":{\"303\":1}}],[\"单端队列和双端队列\",{\"1\":{\"303\":1}}],[\"单向链表\",{\"1\":{\"242\":1}}],[\"单链表\",{\"0\":{\"289\":1}}],[\"单链表实现\",{\"0\":{\"240\":1}}],[\"单链表中的节点应该具备两个属性\",{\"1\":{\"238\":1}}],[\"单词间应当仅用单个空格分隔\",{\"1\":{\"73\":1}}],[\"单词\",{\"1\":{\"73\":6}}],[\"设计时间复杂度为\",{\"1\":{\"249\":1}}],[\"设计并实现自己的链表\",{\"1\":{\"238\":1}}],[\"设计链表\",{\"0\":{\"236\":1,\"237\":1},\"1\":{\"282\":1}}],[\"设置一个虚拟头节点\",{\"1\":{\"162\":1}}],[\"设置\",{\"1\":{\"4\":2}}],[\"剩下的就是答案\",{\"1\":{\"233\":1}}],[\"至少大于等于\",{\"1\":{\"230\":1}}],[\"至少存在一个\",{\"1\":{\"73\":1}}],[\"出现在\",{\"1\":{\"228\":1}}],[\"出现数量\",{\"1\":{\"200\":1}}],[\"写一个函数搜索\",{\"1\":{\"228\":1}}],[\"写作日期为\",{\"1\":{\"31\":1}}],[\"整个链式结构中不存在环\",{\"1\":{\"307\":1}}],[\"整型数组\",{\"1\":{\"228\":1}}],[\"整数\",{\"1\":{\"38\":1}}],[\"升序\",{\"1\":{\"228\":1}}],[\"缩小\",{\"1\":{\"268\":1}}],[\"缩小左边界\",{\"1\":{\"225\":1}}],[\"缩小下边界\",{\"1\":{\"225\":1}}],[\"缩小右边界\",{\"1\":{\"225\":1}}],[\"缩小上边界\",{\"1\":{\"225\":1}}],[\"区间为空\",{\"1\":{\"268\":1}}],[\"区间不存在\",{\"1\":{\"267\":1}}],[\"区间不为空\",{\"1\":{\"230\":1}}],[\"区间定义\",{\"1\":{\"230\":1}}],[\"区间\",{\"1\":{\"225\":4}}],[\"填充的行肯定在\",{\"1\":{\"225\":2}}],[\"填充的列肯定在\",{\"1\":{\"225\":2}}],[\"填充到8时\",{\"1\":{\"223\":1}}],[\"按照通常的思维\",{\"1\":{\"225\":1}}],[\"按照题目进行模拟\",{\"1\":{\"223\":1}}],[\"边界变化条件\",{\"1\":{\"224\":1}}],[\"矩阵中心数字无法在迭代过程中被填充的问题\",{\"1\":{\"223\":1}}],[\"下单等操作后\",{\"1\":{\"303\":1}}],[\"下边界缩减\",{\"1\":{\"223\":2}}],[\"下一篇\",{\"1\":{\"7\":1}}],[\"模拟类的题目在数组中很常见\",{\"1\":{\"272\":1}}],[\"模拟行为\",{\"0\":{\"272\":1}}],[\"模拟\",{\"1\":{\"222\":1}}],[\"正方形矩阵\",{\"1\":{\"221\":1}}],[\"正则匹配连续的空白字符作为分隔符分割\",{\"1\":{\"76\":1}}],[\"到链表中\",{\"1\":{\"238\":1}}],[\"到\",{\"1\":{\"221\":1}}],[\"到达尾节点\",{\"1\":{\"96\":1}}],[\"生成一个包含\",{\"1\":{\"221\":1}}],[\"螺旋矩阵\",{\"0\":{\"219\":1,\"220\":1}}],[\"极端的情况是\",{\"1\":{\"217\":1}}],[\"还是从后往前遍历来优化查找效率\",{\"1\":{\"244\":1}}],[\"还是会在索引范围内\",{\"1\":{\"217\":1}}],[\"还不会编写\",{\"1\":{\"14\":1}}],[\"范围\",{\"1\":{\"215\":1}}],[\"−\",{\"1\":{\"208\":2}}],[\"−1\",{\"1\":{\"22\":1,\"167\":1}}],[\"所有函数单次调用的空间复杂度均为\",{\"1\":{\"245\":1}}],[\"所有函数的单次调用空间复杂度均为\",{\"1\":{\"242\":1}}],[\"所有元素\",{\"1\":{\"221\":1}}],[\"所有和sumab的情况\",{\"1\":{\"208\":1}}],[\"所以要进行\",{\"1\":{\"269\":1}}],[\"所以才有\",{\"1\":{\"267\":2}}],[\"所以\",{\"1\":{\"230\":1,\"307\":1}}],[\"所以也是\",{\"1\":{\"112\":1}}],[\"所以和肯定\",{\"1\":{\"67\":1}}],[\"所以最后的字符串为\",{\"1\":{\"46\":1}}],[\"能满足\",{\"1\":{\"206\":1}}],[\"能不能由\",{\"1\":{\"198\":1}}],[\"四数相加\",{\"0\":{\"204\":1,\"205\":1}}],[\"四数之和\",{\"0\":{\"82\":1,\"83\":1}}],[\"固定长度的子数组\",{\"1\":{\"271\":2}}],[\"固定长度\",{\"1\":{\"202\":1}}],[\"字母总数为\",{\"1\":{\"201\":1}}],[\"字符中的前\",{\"1\":{\"213\":1}}],[\"字符数组尾元素\",{\"1\":{\"183\":1}}],[\"字符怎么办\",{\"1\":{\"165\":1}}],[\"字符串模式匹配问题\",{\"1\":{\"271\":1}}],[\"字符串不为空\",{\"1\":{\"51\":1}}],[\"字符串\",{\"0\":{\"75\":1},\"1\":{\"47\":1,\"74\":1,\"101\":1,\"182\":1,\"214\":1},\"2\":{\"54\":1,\"81\":1,\"105\":1,\"186\":2,\"218\":1}}],[\"多个线程访问有限资源\",{\"1\":{\"303\":1}}],[\"多个输入对应相同输出\",{\"1\":{\"259\":1}}],[\"多\",{\"1\":{\"200\":1}}],[\"针对该字母的数量比\",{\"1\":{\"200\":1}}],[\"由小写英文字母组成\",{\"1\":{\"198\":1}}],[\"由于这两个链表不相交\",{\"1\":{\"307\":1}}],[\"由于我们更新\",{\"1\":{\"269\":1}}],[\"由于需要根据索引来查找节点\",{\"1\":{\"240\":1}}],[\"由于要进行删除操作\",{\"1\":{\"95\":1}}],[\"由于\",{\"1\":{\"59\":1,\"233\":1}}],[\"由于两字母相邻且相同\",{\"1\":{\"46\":1}}],[\"里面的字符构成\",{\"1\":{\"198\":1}}],[\"赎金信\",{\"0\":{\"196\":1,\"197\":1}}],[\"转换成数组\",{\"1\":{\"194\":1}}],[\"转化为字符串并返回\",{\"1\":{\"78\":1}}],[\"暂无\",{\"1\":{\"191\":1}}],[\"唯一\",{\"1\":{\"189\":1}}],[\"唯一可能的三元组和为\",{\"1\":{\"65\":1}}],[\"唯一可能的三元组和不为\",{\"1\":{\"65\":1}}],[\"它通过维护一个\",{\"1\":{\"303\":1}}],[\"它基于优先队列\",{\"1\":{\"303\":1}}],[\"它根据元素的延迟时间来决定元素的优先级\",{\"1\":{\"303\":1}}],[\"它可以被用作栈\",{\"1\":{\"303\":1}}],[\"它可以用作栈\",{\"1\":{\"275\":1}}],[\"它会自动进行扩容操作\",{\"1\":{\"275\":1}}],[\"它们的\",{\"1\":{\"189\":1}}],[\"它以不等于\",{\"1\":{\"173\":1}}],[\"常数的空间\",{\"1\":{\"185\":1}}],[\"与值\",{\"1\":{\"257\":1}}],[\"与\",{\"1\":{\"184\":1}}],[\"交集\",{\"1\":{\"189\":1}}],[\"交换他们的元素\",{\"1\":{\"303\":1}}],[\"交换链表中的节点\",{\"1\":{\"281\":1}}],[\"交换\",{\"1\":{\"183\":1,\"184\":1}}],[\"交替向中间移动\",{\"1\":{\"67\":1,\"68\":1}}],[\"码表中的可打印字符\",{\"1\":{\"181\":1}}],[\"拷贝覆盖\",{\"1\":{\"176\":1}}],[\"自增\",{\"1\":{\"175\":1}}],[\"遍历时\",{\"1\":{\"244\":1}}],[\"遍历找到最后一个节点\",{\"1\":{\"242\":1}}],[\"遍历的长度为字符串长度n\",{\"1\":{\"217\":1}}],[\"遍历\",{\"1\":{\"208\":1}}],[\"遍历数组\",{\"1\":{\"175\":1}}],[\"遍历字符串所需要的时间复杂度\",{\"1\":{\"202\":1}}],[\"遍历字符串\",{\"1\":{\"48\":1}}],[\"题意\",{\"1\":{\"175\":1}}],[\"题目数据\",{\"1\":{\"307\":1}}],[\"题目\",{\"0\":{\"303\":1}}],[\"题目要求不重复\",{\"1\":{\"69\":1}}],[\"题目描述\",{\"0\":{\"38\":1,\"46\":1,\"57\":1,\"65\":1,\"73\":1,\"84\":1,\"92\":1,\"100\":1,\"108\":1,\"116\":1,\"126\":1,\"137\":1,\"144\":1,\"151\":1,\"158\":1,\"165\":1,\"173\":1,\"181\":1,\"189\":1,\"198\":1,\"206\":1,\"213\":1,\"221\":1,\"228\":1,\"238\":1,\"249\":1,\"307\":1}}],[\"题目地址\",{\"0\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"使得区间不断向右收缩\",{\"1\":{\"269\":1}}],[\"使\",{\"1\":{\"173\":1}}],[\"使用的是单向链表\",{\"1\":{\"299\":1}}],[\"使用双重循环进行遍历求和\",{\"1\":{\"209\":1}}],[\"使用双指针\",{\"1\":{\"59\":1,\"77\":1,\"96\":1}}],[\"使用同样的遍历方式\",{\"1\":{\"208\":1}}],[\"使用一个哈希表map存储\",{\"1\":{\"208\":1}}],[\"使用一个集合\",{\"1\":{\"48\":1}}],[\"使用字母的特性\",{\"1\":{\"169\":1}}],[\"使用哈希表进行记录不同字母出现的次数\",{\"1\":{\"168\":1}}],[\"使用变量\",{\"1\":{\"160\":1}}],[\"使用标准的栈操作\",{\"1\":{\"151\":1}}],[\"使用两个集合分别存储两个数组中的元素需要\",{\"1\":{\"194\":1}}],[\"使用两个指针分别指向位置\",{\"1\":{\"251\":1}}],[\"使用两个指针\",{\"1\":{\"183\":1}}],[\"使用两个指针来判断遍历情况\",{\"1\":{\"51\":1}}],[\"使用两个变量\",{\"1\":{\"160\":1}}],[\"使用两个队列\",{\"1\":{\"146\":1}}],[\"使用两重循环分别枚举前两个数\",{\"1\":{\"86\":1,\"87\":1}}],[\"使用\",{\"1\":{\"75\":2,\"181\":1,\"215\":1,\"223\":1}}],[\"使用指南\",{\"1\":{\"31\":2},\"2\":{\"6\":1,\"8\":1,\"27\":1,\"34\":1,\"35\":1}}],[\"更改\",{\"1\":{\"173\":1}}],[\"更新\",{\"1\":{\"217\":1}}],[\"更新start\",{\"1\":{\"80\":1}}],[\"更新时间等页面元信息\",{\"1\":{\"10\":1}}],[\"更新时间\",{\"1\":{\"7\":1}}],[\"您需要执行以下操作\",{\"1\":{\"173\":1}}],[\"各字符时\",{\"1\":{\"167\":1}}],[\"各字符时执行\",{\"1\":{\"167\":1}}],[\"统计\",{\"1\":{\"167\":2}}],[\"某对应字母数量不同\",{\"1\":{\"167\":1}}],[\"互为字母异位词\",{\"1\":{\"165\":1}}],[\"若两链表\",{\"1\":{\"309\":2}}],[\"若两字符串互为字母异位词\",{\"1\":{\"167\":1}}],[\"若两个四元组元素一一对应\",{\"1\":{\"84\":1}}],[\"若\",{\"1\":{\"165\":1,\"167\":2}}],[\"循环链表\",{\"0\":{\"291\":1},\"1\":{\"291\":1}}],[\"循环不变量原则\",{\"1\":{\"272\":1}}],[\"循环的工作\",{\"1\":{\"270\":1}}],[\"循环下完成两个\",{\"1\":{\"270\":1}}],[\"循环停止条件\",{\"1\":{\"267\":1,\"268\":1}}],[\"循环就终止\",{\"1\":{\"230\":1}}],[\"循环终止条件\",{\"1\":{\"224\":1,\"230\":1,\"311\":1}}],[\"循环条件是当前链表还有2个以上的节点\",{\"1\":{\"161\":1}}],[\"循环至单词的末尾\",{\"1\":{\"80\":1}}],[\"待交换的节点\",{\"1\":{\"160\":1}}],[\"初始化条件\",{\"1\":{\"267\":1,\"268\":1}}],[\"初始化消耗\",{\"1\":{\"242\":1,\"245\":1}}],[\"初始化\",{\"1\":{\"238\":1}}],[\"初始化为\",{\"1\":{\"160\":1}}],[\"初始化项目并上传到github\",{\"1\":{\"4\":1}}],[\"故空间复杂度为\",{\"1\":{\"154\":1}}],[\"放进\",{\"1\":{\"153\":1}}],[\"放进队列中\",{\"1\":{\"48\":1}}],[\"或\",{\"1\":{\"153\":1}}],[\"或者\",{\"1\":{\"144\":1,\"151\":2,\"267\":1}}],[\"或者链表中的一个有效索引\",{\"1\":{\"57\":1}}],[\"元素的顺序可能发生改变\",{\"1\":{\"173\":1}}],[\"元素\",{\"1\":{\"153\":2}}],[\"即不断向左收缩\",{\"1\":{\"268\":1}}],[\"即每个节点要存储本身的值\",{\"1\":{\"243\":1}}],[\"即为新的数组长度\",{\"1\":{\"175\":1}}],[\"即\",{\"1\":{\"158\":1,\"160\":1,\"267\":1,\"268\":1,\"309\":2,\"311\":1}}],[\"即使其中一个操作可能花费较长时间\",{\"1\":{\"151\":1}}],[\"即看成一个链表\",{\"1\":{\"111\":1}}],[\"执行\",{\"1\":{\"151\":1}}],[\"换句话说\",{\"1\":{\"151\":1}}],[\"推到队列的末尾\",{\"1\":{\"151\":1}}],[\"列队\",{\"2\":{\"148\":1}}],[\"列表\",{\"1\":{\"144\":1}}],[\"列表中的节点数目在范围\",{\"1\":{\"116\":1}}],[\"操作只发生在结构的一端\",{\"1\":{\"274\":1}}],[\"操作的情况\",{\"1\":{\"154\":1}}],[\"操作都是\",{\"1\":{\"154\":1}}],[\"操作\",{\"1\":{\"151\":1}}],[\"操作是合法的\",{\"1\":{\"151\":1}}],[\"操作为\",{\"1\":{\"147\":4}}],[\"操作视为寻找下一个数\",{\"1\":{\"111\":1}}],[\"作为尾节点\",{\"1\":{\"243\":1}}],[\"作为头节点\",{\"1\":{\"243\":1}}],[\"作为迭代条件\",{\"1\":{\"223\":1}}],[\"作为主要的队列\",{\"1\":{\"147\":1}}],[\"作者设置为\",{\"1\":{\"31\":1}}],[\"q2\",{\"1\":{\"147\":7}}],[\"q1\",{\"1\":{\"147\":12}}],[\"queue<integer>\",{\"1\":{\"147\":2}}],[\"queues\",{\"1\":{\"143\":1}}],[\"queue\",{\"1\":{\"50\":7,\"104\":7,\"150\":1,\"151\":4,\"302\":2,\"303\":4}}],[\"队列里面的元素实现了\",{\"1\":{\"303\":1}}],[\"队列既可以是数组实现也可以是链表实现\",{\"1\":{\"302\":1}}],[\"队列理论基础篇\",{\"0\":{\"301\":1}}],[\"队列中会有\",{\"1\":{\"154\":1}}],[\"队列应当支持一般队列支持的所有操作\",{\"1\":{\"151\":1}}],[\"队列是先进先出\",{\"1\":{\"146\":1}}],[\"队列\",{\"1\":{\"145\":1,\"152\":1,\"302\":1},\"2\":{\"304\":1}}],[\"都会改变\",{\"1\":{\"268\":1}}],[\"都是\",{\"1\":{\"181\":1}}],[\"都保证栈不为空\",{\"1\":{\"144\":1}}],[\"都不会影响最终的结果\",{\"1\":{\"48\":1}}],[\"次交换\",{\"1\":{\"185\":1}}],[\"次\",{\"1\":{\"144\":1,\"151\":1,\"154\":1}}],[\"否则也不会导致\",{\"1\":{\"269\":1}}],[\"否则返回\",{\"1\":{\"198\":1,\"228\":1}}],[\"否则\",{\"1\":{\"144\":1,\"151\":1}}],[\"否则就将元素放进数组\",{\"1\":{\"51\":1}}],[\"压入栈顶\",{\"1\":{\"144\":1}}],[\"类是很粗糙的\",{\"1\":{\"274\":1}}],[\"类似之前算法的处理方式\",{\"1\":{\"268\":1}}],[\"类\",{\"1\":{\"144\":1,\"151\":1,\"238\":1,\"276\":1}}],[\"实现的\",{\"1\":{\"303\":1}}],[\"实现高效的元素查询\",{\"1\":{\"257\":1}}],[\"实现双向链表\",{\"1\":{\"243\":1}}],[\"实现\",{\"1\":{\"144\":1,\"151\":1,\"238\":1}}],[\"用于处理具有过期时间\",{\"1\":{\"303\":1}}],[\"用作元素的集合\",{\"1\":{\"274\":1}}],[\"用户评测\",{\"1\":{\"173\":1}}],[\"用一个队列存放\",{\"1\":{\"153\":2}}],[\"用栈实现队列\",{\"0\":{\"149\":1,\"150\":1}}],[\"用队列实现栈\",{\"0\":{\"142\":1,\"143\":1}}],[\"用循环解决\",{\"1\":{\"119\":1}}],[\"把当前元素添加进去\",{\"1\":{\"141\":1}}],[\"把数组当成一个队列使用\",{\"1\":{\"51\":1}}],[\"滑动串口的指针和右指针\",{\"1\":{\"141\":1}}],[\"滑动窗口\",{\"0\":{\"139\":1,\"271\":1},\"1\":{\"138\":1}}],[\"继续走\",{\"1\":{\"309\":2}}],[\"继续比较其节点和其父节点\",{\"1\":{\"303\":1}}],[\"继续更新子数组的最小长度\",{\"1\":{\"139\":1}}],[\"继续往右移\",{\"1\":{\"139\":1,\"140\":1}}],[\"窗口的长度为子数组的最小长度\",{\"1\":{\"139\":1}}],[\"符合题目时\",{\"1\":{\"139\":1}}],[\"子字符串问题\",{\"1\":{\"271\":2}}],[\"子数组\",{\"1\":{\"137\":2}}],[\"子模块\",{\"1\":{\"4\":1}}],[\"找满足条件的最右侧的值\",{\"0\":{\"269\":1}}],[\"找满足条件的最左侧的值\",{\"0\":{\"268\":1}}],[\"找到map是否存在\",{\"1\":{\"208\":1}}],[\"找到更小的窗口长度\",{\"1\":{\"139\":1,\"140\":1}}],[\"找到重复答案\",{\"1\":{\"69\":1}}],[\"找出该数组中满足其总和大于等于target的长度最小的\",{\"1\":{\"137\":1}}],[\"长度\",{\"1\":{\"311\":2}}],[\"长度为\",{\"1\":{\"309\":2}}],[\"长度为奇数时\",{\"1\":{\"104\":1}}],[\"长度正确的预期答案\",{\"1\":{\"173\":1}}],[\"长度不相等\",{\"1\":{\"167\":1}}],[\"长度最小的子数组\",{\"0\":{\"135\":1,\"136\":1}}],[\"层\",{\"1\":{\"133\":1}}],[\"递归函数的定义\",{\"1\":{\"131\":1}}],[\"递归\",{\"0\":{\"131\":1}}],[\"递归思想\",{\"1\":{\"127\":1}}],[\"反向\",{\"1\":{\"130\":1}}],[\"反转链表\",{\"0\":{\"124\":1,\"125\":1}}],[\"反转字符串\",{\"0\":{\"179\":1,\"180\":1,\"211\":1,\"212\":1},\"1\":{\"80\":1}}],[\"反转字符串中的单词\",{\"0\":{\"71\":1,\"72\":1}}],[\"反转后的字符串需要将单词间的空格减少到仅有一个\",{\"1\":{\"73\":1}}],[\"反转后的字符串中不能存在前导空格和尾随空格\",{\"1\":{\"73\":1}}],[\"前\",{\"1\":{\"175\":1}}],[\"前缀和+二分查找\",{\"1\":{\"138\":1}}],[\"前驱节点\",{\"1\":{\"130\":1,\"243\":1}}],[\"前置知识\",{\"0\":{\"39\":1,\"47\":1,\"58\":1,\"66\":1,\"74\":1,\"85\":1,\"93\":1,\"101\":1,\"109\":1,\"127\":1,\"138\":1,\"145\":1,\"152\":1,\"159\":1,\"166\":1,\"174\":1,\"182\":1,\"190\":1,\"199\":1,\"207\":1,\"214\":1,\"222\":1,\"229\":1,\"239\":1,\"250\":1,\"308\":1},\"1\":{\"116\":1}}],[\"引用\",{\"1\":{\"129\":1,\"238\":1}}],[\"要求也按\",{\"1\":{\"249\":1}}],[\"要注意\",{\"1\":{\"217\":1}}],[\"要更新\",{\"1\":{\"215\":1}}],[\"要移除的值\",{\"1\":{\"173\":1}}],[\"要通过此题\",{\"1\":{\"173\":1}}],[\"要将\",{\"1\":{\"140\":1}}],[\"要删除一个节点\",{\"1\":{\"121\":1}}],[\"要走\",{\"1\":{\"61\":2}}],[\"虚拟头节点\",{\"0\":{\"120\":1,\"160\":1,\"279\":1}}],[\"虚拟节点\",{\"1\":{\"116\":1}}],[\"可能等于答案\",{\"1\":{\"233\":1}}],[\"可能会\",{\"1\":{\"217\":1}}],[\"可能新的头结点也值相等\",{\"1\":{\"119\":1}}],[\"可以是任意值\",{\"1\":{\"307\":1}}],[\"可以实现流量控制\",{\"1\":{\"303\":1}}],[\"可以很方便进行删除操作\",{\"1\":{\"279\":1}}],[\"可以看成使用了一个额外的数组存储了数组\",{\"1\":{\"88\":1}}],[\"可以通过连续跟踪\",{\"1\":{\"57\":1}}],[\"可以执行重复项删除操作\",{\"1\":{\"46\":1}}],[\"可以根据文件结构将它们转换为不同的页面\",{\"1\":{\"13\":1}}],[\"直接返回\",{\"1\":{\"230\":1}}],[\"直接删除\",{\"0\":{\"117\":1}}],[\"直到满足最大堆的性质\",{\"1\":{\"303\":1}}],[\"直到查询到不冲突\",{\"1\":{\"261\":1}}],[\"直到不满足\",{\"1\":{\"141\":1}}],[\"直到符合最小窗口的长度\",{\"1\":{\"141\":1}}],[\"直到无法继续删除\",{\"1\":{\"46\":1}}],[\"移除所有数值等于\",{\"1\":{\"173\":1}}],[\"移除元素\",{\"0\":{\"171\":1,\"172\":1}}],[\"移除并返回栈顶元素\",{\"1\":{\"144\":1}}],[\"移除链表元素\",{\"0\":{\"114\":1,\"115\":1},\"1\":{\"279\":1}}],[\"移动的时候要注意处理相同元素情况\",{\"1\":{\"67\":2}}],[\"移动\",{\"1\":{\"67\":2}}],[\"假设一种极端情况\",{\"1\":{\"268\":1}}],[\"假设链表中的所有节点下标从\",{\"1\":{\"238\":1}}],[\"假设\",{\"1\":{\"173\":1}}],[\"假设所有操作都是有效的\",{\"1\":{\"151\":1}}],[\"假设循环中有\",{\"1\":{\"112\":1}}],[\"假如这个重复元素是解\",{\"1\":{\"40\":1}}],[\"成本是\",{\"1\":{\"112\":1}}],[\"快慢指针法\",{\"1\":{\"270\":1}}],[\"快慢指针\",{\"0\":{\"280\":1},\"1\":{\"112\":1}}],[\"快乐数\",{\"0\":{\"106\":1,\"107\":1},\"1\":{\"108\":2,\"111\":1}}],[\"计数器\",{\"1\":{\"303\":1}}],[\"计数\",{\"1\":{\"194\":1}}],[\"计算滑动窗口的总和\",{\"1\":{\"139\":1}}],[\"计算每一位的平方和\",{\"1\":{\"112\":1}}],[\"计划\",{\"1\":{\"23\":2}}],[\"检测一个链表是否有环\",{\"1\":{\"110\":1}}],[\"那就出现一种情况\",{\"1\":{\"269\":1}}],[\"那问题就直接转换为\",{\"1\":{\"110\":1}}],[\"那么现在头节点和尾节点都是\",{\"1\":{\"294\":1}}],[\"那么该节点会被追加到链表的末尾\",{\"1\":{\"238\":1}}],[\"那么快跑者需要\",{\"1\":{\"112\":1}}],[\"那么fast将先到达\",{\"1\":{\"112\":1}}],[\"那么存在一个环使得算法无限循环\",{\"1\":{\"112\":1}}],[\"那么这个数就是快乐数\",{\"1\":{\"108\":1}}],[\"那么字符串就是无效的\",{\"1\":{\"102\":1}}],[\"那么必定是两个重复元素的和等于\",{\"1\":{\"40\":1}}],[\"得到的链是一个隐式的链表\",{\"1\":{\"110\":1}}],[\"但大于或等于\",{\"1\":{\"213\":1}}],[\"但始终变不到\",{\"1\":{\"108\":1}}],[\"但是我们选择的是左闭右开区间\",{\"1\":{\"230\":1}}],[\"但是\",{\"1\":{\"38\":1}}],[\"也就意味着\",{\"1\":{\"230\":1}}],[\"也就是只有\",{\"1\":{\"151\":1}}],[\"也就是\",{\"1\":{\"144\":1}}],[\"也不是正确答案\",{\"1\":{\"200\":1}}],[\"也是可通过的\",{\"1\":{\"189\":1}}],[\"也可以用作队列\",{\"1\":{\"303\":1}}],[\"也可以表示\",{\"1\":{\"268\":1}}],[\"也可以使用长度固定的数组记录不同字母出现的次数\",{\"1\":{\"168\":1}}],[\"也可能是\",{\"1\":{\"108\":1}}],[\"也有可能\",{\"1\":{\"69\":1}}],[\"然后再进行反转\",{\"1\":{\"215\":1}}],[\"然后返回\",{\"1\":{\"173\":1}}],[\"然后将新加入的元素压入\",{\"1\":{\"147\":1}}],[\"然后重复这个过程直到这个数变为\",{\"1\":{\"108\":1}}],[\"然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数\",{\"1\":{\"86\":1,\"87\":1}}],[\"编写一个函数\",{\"1\":{\"181\":1}}],[\"编写一个函数来判断\",{\"1\":{\"165\":1}}],[\"编写一个算法来判断一个数\",{\"1\":{\"108\":1}}],[\"编辑此页链接\",{\"1\":{\"7\":1}}],[\"入栈是右括号\",{\"1\":{\"103\":1}}],[\"就放入对应的索引中\",{\"1\":{\"261\":1}}],[\"就放入一个对应的右括号\",{\"1\":{\"102\":1}}],[\"就像每一个人的身份证对应一个人一样\",{\"1\":{\"257\":1}}],[\"就可以很容易区分出来变化的量应该放在\",{\"1\":{\"225\":1}}],[\"就可以进行更改链表节点的交换\",{\"1\":{\"160\":1}}],[\"就会导致退出循环\",{\"1\":{\"223\":1}}],[\"就反转这\",{\"1\":{\"213\":1}}],[\"就是相交点\",{\"1\":{\"310\":1}}],[\"就是链表首尾相连\",{\"1\":{\"291\":1}}],[\"就是单纯的模拟\",{\"1\":{\"272\":1}}],[\"就是我们要得到的结果\",{\"1\":{\"230\":1}}],[\"就是答案\",{\"1\":{\"208\":1}}],[\"就是当前答案\",{\"1\":{\"69\":1}}],[\"就表示反转结束\",{\"1\":{\"183\":1}}],[\"就返回\",{\"1\":{\"108\":1}}],[\"就说明括号右效\",{\"1\":{\"102\":1}}],[\"左元素还是右元素最终有一个没做判断\",{\"1\":{\"267\":1}}],[\"左闭右必区间\",{\"0\":{\"234\":1}}],[\"左闭右开\",{\"1\":{\"230\":1,\"268\":1}}],[\"左右区间的比较\",{\"1\":{\"231\":1}}],[\"左右区间的闭合\",{\"1\":{\"231\":1}}],[\"左括号必须以正确的顺序闭合\",{\"1\":{\"100\":1}}],[\"左括号必须用相同类型的右括号闭合\",{\"1\":{\"100\":1}}],[\"左边\",{\"1\":{\"67\":1}}],[\"有\",{\"1\":{\"309\":1}}],[\"有两个变量\",{\"1\":{\"309\":1}}],[\"有交点\",{\"1\":{\"307\":1}}],[\"有序数组的平方\",{\"0\":{\"247\":1,\"248\":1}}],[\"有可能两个指针都指向\",{\"1\":{\"310\":1}}],[\"有可能是\",{\"1\":{\"269\":1}}],[\"有可能是重复答案\",{\"1\":{\"67\":1}}],[\"有可能越界\",{\"1\":{\"216\":1}}],[\"有效的字母异位词\",{\"0\":{\"163\":1,\"164\":1},\"1\":{\"201\":1}}],[\"有效的括号\",{\"0\":{\"98\":1,\"99\":1}}],[\"有效字符串需满足\",{\"1\":{\"100\":1}}],[\"刚好指向倒数第\",{\"1\":{\"96\":1}}],[\"刚好走好倒数第\",{\"1\":{\"94\":1}}],[\"怎么知道是倒数第\",{\"1\":{\"96\":1}}],[\"先判断长度一致\",{\"1\":{\"169\":1}}],[\"先判断头结点的情况\",{\"1\":{\"117\":1}}],[\"先存储\",{\"1\":{\"129\":1}}],[\"先走\",{\"1\":{\"94\":1,\"96\":1}}],[\"先翻转整个字符串\",{\"1\":{\"79\":1}}],[\"枚举四元组的时间复杂度是\",{\"1\":{\"88\":1}}],[\"枚举第二个数\",{\"1\":{\"88\":1}}],[\"枚举第一个数\",{\"1\":{\"88\":1}}],[\"跳过重复数字\",{\"1\":{\"88\":1}}],[\"跳过单词间空格\",{\"1\":{\"78\":1}}],[\"本题与\",{\"1\":{\"86\":1}}],[\"本页面就是一个示例\",{\"1\":{\"7\":1}}],[\"81\",{\"1\":{\"112\":4}}],[\"82\",{\"1\":{\"108\":3}}],[\"8\",{\"1\":{\"84\":1,\"189\":1,\"221\":1,\"268\":1,\"307\":7}}],[\"任意放一个进入结果数组即可\",{\"1\":{\"252\":1}}],[\"任意顺序\",{\"1\":{\"84\":1}}],[\"任务列表\",{\"0\":{\"23\":1}}],[\"将数组尾元素替换根元素\",{\"1\":{\"303\":1}}],[\"将这种情况视为\",{\"1\":{\"259\":1}}],[\"将一个值为\",{\"1\":{\"238\":3}}],[\"将在\",{\"1\":{\"228\":1}}],[\"将虚拟头结点指向head\",{\"1\":{\"162\":1}}],[\"将元素添加到集合\",{\"1\":{\"274\":1}}],[\"将元素\",{\"1\":{\"144\":1,\"151\":1}}],[\"将\",{\"1\":{\"111\":1,\"131\":1,\"139\":1,\"208\":1}}],[\"将栈顶元素出栈\",{\"1\":{\"102\":1}}],[\"将字符串间多余的空白字符去除\",{\"1\":{\"80\":1}}],[\"将单词添加到结果中\",{\"1\":{\"77\":1}}],[\"去替代\",{\"1\":{\"274\":1}}],[\"去找下一个单词\",{\"1\":{\"80\":1}}],[\"去掉字符串末尾的空白字符\",{\"1\":{\"80\":1}}],[\"去掉字符串开头的空白字符\",{\"1\":{\"80\":1}}],[\"去掉多余空格\",{\"1\":{\"80\":1}}],[\"去除空格\",{\"1\":{\"79\":1}}],[\"翻转链表\",{\"1\":{\"280\":1}}],[\"翻转单词\",{\"1\":{\"80\":1}}],[\"翻转每一个单词\",{\"1\":{\"80\":1}}],[\"翻转每个单词\",{\"1\":{\"80\":1}}],[\"翻转字符串\",{\"1\":{\"80\":1}}],[\"再将\",{\"1\":{\"147\":1}}],[\"再翻转每个单词\",{\"1\":{\"79\":1}}],[\"再到环形入口节点节点数为\",{\"1\":{\"59\":1}}],[\"手写字符串api\",{\"0\":{\"79\":1}}],[\"添加一个元素在数组末尾\",{\"1\":{\"303\":1}}],[\"添加单词\",{\"1\":{\"78\":1}}],[\"添加元素\",{\"1\":{\"53\":2,\"257\":1}}],[\"删除\",{\"1\":{\"299\":1}}],[\"删除为\",{\"1\":{\"298\":1}}],[\"删除链表的第\",{\"1\":{\"282\":1}}],[\"删除链表的中间节点\",{\"1\":{\"281\":1}}],[\"删除链表的倒数第\",{\"0\":{\"91\":1},\"1\":{\"92\":1}}],[\"删除链表的倒数第n个结点\",{\"0\":{\"90\":1}}],[\"删除链表\",{\"1\":{\"281\":1}}],[\"删除倒数第\",{\"0\":{\"281\":1},\"1\":{\"281\":1}}],[\"删除最近添加但尚未删除的元素\",{\"1\":{\"274\":1}}],[\"删除元素\",{\"1\":{\"257\":1}}],[\"删除方式一样\",{\"1\":{\"121\":1}}],[\"删除值相同的头结点后\",{\"1\":{\"119\":1}}],[\"删除节点\",{\"0\":{\"297\":1},\"1\":{\"116\":1,\"241\":1}}],[\"删除首尾空格\",{\"1\":{\"78\":1}}],[\"删除字符串中的所有相邻重复项\",{\"0\":{\"44\":1,\"45\":1}}],[\"倒数第\",{\"1\":{\"95\":1}}],[\"倒序遍历字符串\",{\"1\":{\"77\":1}}],[\"倒序遍历+双指针\",{\"0\":{\"77\":1}}],[\"倒排字符串列表\",{\"1\":{\"75\":1}}],[\"大小的额外空间\",{\"1\":{\"76\":1,\"78\":1}}],[\"占用\",{\"1\":{\"76\":1,\"78\":1}}],[\"以避免即时发送失败或对用户体验造成干扰\",{\"1\":{\"303\":1}}],[\"以指示链表中的上一个节点\",{\"1\":{\"238\":1}}],[\"以一个数组来记录\",{\"1\":{\"169\":1}}],[\"以空格进行分割\",{\"1\":{\"75\":1}}],[\"以便\",{\"1\":{\"13\":1}}],[\"解决\",{\"1\":{\"102\":1}}],[\"解法也相似\",{\"1\":{\"86\":1}}],[\"解法\",{\"1\":{\"73\":1}}],[\"解释\",{\"1\":{\"38\":1,\"46\":1,\"57\":3,\"65\":3,\"73\":2,\"108\":1,\"137\":1,\"144\":1,\"151\":1,\"173\":2,\"189\":1,\"206\":1,\"228\":2,\"238\":1,\"249\":1,\"307\":3}}],[\"额外空间复杂度的\",{\"1\":{\"73\":1}}],[\"包含英文大小写字母\",{\"1\":{\"73\":1}}],[\"之间的头节点的前驱节点是新节点\",{\"1\":{\"294\":1}}],[\"之间的映射\",{\"1\":{\"257\":1}}],[\"之间\",{\"1\":{\"228\":2}}],[\"之间用单个空格连接的结果字符串\",{\"1\":{\"73\":1}}],[\"之后我们得到字符串\",{\"1\":{\"46\":1}}],[\"顺序颠倒且\",{\"1\":{\"73\":1}}],[\"忽略答案的存储空间\",{\"1\":{\"69\":1}}],[\"往后的查找不满足\",{\"1\":{\"69\":1}}],[\"往中间靠拢\",{\"1\":{\"69\":1}}],[\"排除重复答案\",{\"1\":{\"69\":1}}],[\"排序后\",{\"1\":{\"249\":1}}],[\"排序的整数数组\",{\"1\":{\"249\":1}}],[\"排序的时间复杂度是\",{\"1\":{\"88\":1}}],[\"排序的时间复杂度为\",{\"1\":{\"67\":1,\"69\":1}}],[\"排序解决重复问题\",{\"1\":{\"87\":1}}],[\"排序\",{\"1\":{\"86\":1,\"173\":1,\"249\":2}}],[\"排序+双指针\",{\"0\":{\"67\":1}}],[\"随后继续交替移动\",{\"1\":{\"69\":1}}],[\"减小总和\",{\"1\":{\"69\":1}}],[\"只有这样做\",{\"1\":{\"268\":1}}],[\"只有\",{\"1\":{\"169\":1}}],[\"只要是标准的栈操作即可\",{\"1\":{\"151\":1}}],[\"只要是标准的队列操作即可\",{\"1\":{\"144\":1}}],[\"只能进行节点交换\",{\"1\":{\"158\":1}}],[\"只能\",{\"1\":{\"151\":1}}],[\"只能让第三个枚举元素的下标向左移动\",{\"1\":{\"69\":1}}],[\"只会存在一个有效答案\",{\"1\":{\"38\":1}}],[\"三重循环枚举\",{\"1\":{\"69\":1}}],[\"三数之和\",{\"0\":{\"63\":1,\"64\":1},\"1\":{\"85\":1,\"86\":1}}],[\"右边界缩减\",{\"1\":{\"223\":1}}],[\"右边\",{\"1\":{\"67\":1}}],[\"需要独占访问\",{\"1\":{\"303\":1}}],[\"需要一个\",{\"1\":{\"243\":1}}],[\"需要同时更新\",{\"1\":{\"241\":1}}],[\"需要将元素从\",{\"1\":{\"153\":1}}],[\"需要使用两个队列存储栈内的元素\",{\"1\":{\"147\":1}}],[\"需要往\",{\"1\":{\"67\":2}}],[\"需要创建一个长度为\",{\"1\":{\"53\":1}}],[\"需要创建一个队列来存储情况\",{\"1\":{\"50\":1}}],[\"终止循环\",{\"1\":{\"67\":1}}],[\"又是最小\",{\"1\":{\"67\":1}}],[\"组成的新数组\",{\"1\":{\"249\":1}}],[\"组成\",{\"1\":{\"100\":1}}],[\"组合\",{\"1\":{\"67\":1}}],[\"组件\",{\"0\":{\"26\":1,\"33\":1},\"1\":{\"33\":1}}],[\"记录头节点\",{\"1\":{\"294\":1}}],[\"记录自己的刷题过程\",{\"1\":{\"255\":1}}],[\"记录\",{\"1\":{\"200\":1}}],[\"记录对于每个固定指针\",{\"1\":{\"67\":1}}],[\"记得建立\",{\"1\":{\"4\":1}}],[\"处理一次即可\",{\"1\":{\"67\":1}}],[\"处\",{\"1\":{\"67\":1}}],[\"而常用的实现类是\",{\"1\":{\"303\":1}}],[\"而是在用户操作后的几分钟或更长时间后再发送\",{\"1\":{\"303\":1}}],[\"而是\",{\"1\":{\"269\":1}}],[\"而这个区间就是我们的\",{\"1\":{\"267\":1}}],[\"而右开所指向的位置本身就不在我们的候选区间里\",{\"1\":{\"230\":1}}],[\"而以数组的长度来定义右边界\",{\"1\":{\"230\":1}}],[\"而不是\",{\"1\":{\"223\":1,\"230\":1}}],[\"而不会无穷大\",{\"1\":{\"112\":1}}],[\"而\",{\"1\":{\"67\":1,\"69\":2,\"217\":1,\"230\":1,\"268\":1,\"307\":1}}],[\"而两个元素的交替移动也能达到这个效果\",{\"1\":{\"67\":1}}],[\"而且能快速做出剪枝\",{\"1\":{\"67\":1}}],[\"暴力枚举\",{\"1\":{\"67\":1}}],[\"答案中不可以包含重复的三元组\",{\"1\":{\"65\":1}}],[\"答案保证唯一\",{\"1\":{\"46\":1}}],[\"且元素按顺时针顺序螺旋排列的\",{\"1\":{\"221\":1}}],[\"且在同一重循环中不能多次枚举到相同的元素\",{\"1\":{\"86\":1}}],[\"且不包含任何额外的空格\",{\"1\":{\"73\":1}}],[\"且不重复的三元组\",{\"1\":{\"65\":1}}],[\"且\",{\"1\":{\"65\":1}}],[\"满足\",{\"1\":{\"65\":1}}],[\"k−1\",{\"1\":{\"112\":2}}],[\"k++\",{\"1\":{\"69\":1}}],[\"k\",{\"1\":{\"65\":4,\"67\":9,\"69\":9,\"112\":1,\"173\":11,\"175\":1,\"206\":3,\"213\":8,\"215\":2,\"217\":4,\"284\":1}}],[\"key上\",{\"1\":{\"258\":1}}],[\"key\",{\"1\":{\"41\":1,\"208\":1,\"257\":1,\"258\":1}}],[\"判断条件\",{\"1\":{\"230\":1}}],[\"判断\",{\"1\":{\"198\":1}}],[\"判断字符串是否有效\",{\"1\":{\"100\":1}}],[\"判断是否存在三元组\",{\"1\":{\"65\":1}}],[\"判断链表是否环\",{\"1\":{\"60\":1}}],[\"第一次\",{\"1\":{\"310\":1}}],[\"第一次符合条件为窗口长度\",{\"1\":{\"141\":1}}],[\"第一次相遇时\",{\"1\":{\"61\":1}}],[\"第一次相遇\",{\"1\":{\"61\":1}}],[\"第三个元素导致的三数之和有可能导致\",{\"1\":{\"69\":1}}],[\"第三个元素会导致和为\",{\"1\":{\"67\":1}}],[\"第三重循环枚举到的元素不小于当前第二重循环枚举到的元素\",{\"1\":{\"69\":1}}],[\"第二个枚举元素的下标要右边移动\",{\"1\":{\"69\":1}}],[\"第二重循环枚举到的元素不小于当前第一重循环枚举到的元素\",{\"1\":{\"69\":1}}],[\"第二次相遇\",{\"1\":{\"61\":1}}],[\"一部分是\",{\"1\":{\"287\":2}}],[\"一定不等于\",{\"1\":{\"269\":1}}],[\"一定会在循环中\",{\"1\":{\"110\":1}}],[\"一定会在环中相遇\",{\"1\":{\"59\":1}}],[\"一直向左边靠近\",{\"1\":{\"268\":1}}],[\"一直保持不变\",{\"1\":{\"268\":1}}],[\"一共执行了\",{\"1\":{\"185\":1}}],[\"一个\",{\"1\":{\"302\":1}}],[\"一个指向上一个节点\",{\"1\":{\"290\":1}}],[\"一个指向下一个节点\",{\"1\":{\"290\":1}}],[\"一个空的队列不会调用\",{\"1\":{\"151\":1}}],[\"一个辅助备份\",{\"1\":{\"146\":1}}],[\"一个当成主要的\",{\"1\":{\"146\":1}}],[\"一旦两个指针都在循环中\",{\"1\":{\"112\":1}}],[\"一起走\",{\"1\":{\"94\":1}}],[\"一起同时\",{\"1\":{\"61\":1}}],[\"让一个指针先走\",{\"1\":{\"96\":1}}],[\"让\",{\"1\":{\"61\":1,\"94\":1,\"96\":2}}],[\"个字符\",{\"1\":{\"213\":3}}],[\"个元素有序的\",{\"1\":{\"228\":1}}],[\"个元素不等于\",{\"1\":{\"175\":1}}],[\"个元素之外留下了什么并不重要\",{\"1\":{\"173\":2}}],[\"个元素包含不等于\",{\"1\":{\"173\":1}}],[\"个元素\",{\"1\":{\"154\":1,\"173\":1}}],[\"个操作的总时间复杂度为\",{\"1\":{\"151\":1}}],[\"个数字\",{\"1\":{\"112\":1}}],[\"个节点前面插入一个节点\",{\"1\":{\"282\":1}}],[\"个节点的数值\",{\"1\":{\"282\":2}}],[\"个节点之后的\",{\"1\":{\"281\":1}}],[\"个节点\",{\"0\":{\"281\":1},\"1\":{\"110\":2,\"281\":3,\"284\":1,\"307\":4,\"311\":1}}],[\"个节点位置\",{\"1\":{\"95\":1}}],[\"个\",{\"1\":{\"94\":1,\"96\":2,\"147\":1,\"169\":1,\"201\":1,\"213\":2,\"268\":2}}],[\"个结点\",{\"0\":{\"91\":1},\"1\":{\"92\":1}}],[\"个整数组成的数组\",{\"1\":{\"84\":1}}],[\"个环\",{\"1\":{\"61\":2}}],[\"个或者以上的重复元素\",{\"1\":{\"40\":1}}],[\"如调整队列参数\",{\"1\":{\"303\":1}}],[\"如定期发送报告\",{\"1\":{\"303\":1}}],[\"如何找到这个环的入口\",{\"1\":{\"60\":1}}],[\"如果队列某些操作\",{\"1\":{\"303\":1}}],[\"如果队列为空\",{\"1\":{\"151\":1}}],[\"如果订单在\",{\"1\":{\"303\":1}}],[\"如果之前的头节点为null\",{\"1\":{\"294\":1}}],[\"如果非要用\",{\"1\":{\"267\":1}}],[\"如果没有找到的情况下\",{\"1\":{\"267\":1}}],[\"如果没有循环\",{\"1\":{\"112\":1}}],[\"如果遍历结束没有找到\",{\"1\":{\"244\":1}}],[\"如果下标有效\",{\"1\":{\"238\":1}}],[\"如果下标无效\",{\"1\":{\"238\":1}}],[\"如果是双向链表\",{\"1\":{\"238\":1}}],[\"如果是快乐数\",{\"1\":{\"112\":1}}],[\"如果超过了这个条件\",{\"1\":{\"230\":1}}],[\"如果目标值存在返回下标\",{\"1\":{\"228\":1}}],[\"如果剩余字符小于\",{\"1\":{\"213\":1}}],[\"如果剩余字符少于\",{\"1\":{\"213\":1}}],[\"如果某个字符数量检查情况中\",{\"1\":{\"200\":1}}],[\"如果两个链表相交则不能为\",{\"1\":{\"307\":2}}],[\"如果两个链表没有交点\",{\"1\":{\"307\":1}}],[\"如果两个字符串的长度不相等\",{\"1\":{\"200\":1}}],[\"如果两个单词间有多余的空格\",{\"1\":{\"73\":1}}],[\"如果可以\",{\"1\":{\"198\":1}}],[\"如果相同的时候\",{\"1\":{\"175\":1}}],[\"如果相遇\",{\"1\":{\"112\":1}}],[\"如果所有的断言都通过\",{\"1\":{\"173\":1}}],[\"如果输入字符串包含\",{\"1\":{\"165\":1}}],[\"如果栈是空的\",{\"1\":{\"144\":1}}],[\"如果栈为空或者栈顶元素与\",{\"1\":{\"102\":1}}],[\"如果不存在符合条件的子数组\",{\"1\":{\"137\":1}}],[\"如果不存在环\",{\"1\":{\"59\":1}}],[\"如果他们的起点是相隔\",{\"1\":{\"112\":1}}],[\"如果这个过程\",{\"1\":{\"108\":1}}],[\"如果与栈顶元素一样\",{\"1\":{\"102\":1}}],[\"如果字符串在你使用的编程语言中是一种可变数据类型\",{\"1\":{\"73\":1}}],[\"如果和\",{\"1\":{\"67\":3}}],[\"如果使用\",{\"1\":{\"67\":1}}],[\"如果存在环\",{\"1\":{\"59\":1}}],[\"如果\",{\"1\":{\"57\":1,\"67\":2,\"108\":1,\"110\":2,\"200\":1,\"230\":1,\"238\":2,\"268\":2,\"307\":2}}],[\"如果链表中有某个节点\",{\"1\":{\"57\":1}}],[\"如果链表无环\",{\"1\":{\"57\":1}}],[\"如果数组尾元素\",{\"1\":{\"51\":1}}],[\"如果只有两个重复元素\",{\"1\":{\"40\":1}}],[\"如果有环\",{\"1\":{\"60\":1}}],[\"如果有\",{\"1\":{\"40\":1}}],[\"如果你已经实现o\",{\"1\":{\"137\":1}}],[\"如果你是一个新手\",{\"1\":{\"14\":1}}],[\"如果你文档需要\",{\"1\":{\"4\":1}}],[\"恰好等于\",{\"1\":{\"59\":1}}],[\"圈的环长度\",{\"1\":{\"59\":1}}],[\"加上\",{\"1\":{\"59\":1}}],[\"走完\",{\"1\":{\"309\":2}}],[\"走两步\",{\"1\":{\"112\":1}}],[\"走一步\",{\"1\":{\"112\":1}}],[\"走了\",{\"1\":{\"61\":2}}],[\"走过的节点数为\",{\"1\":{\"59\":2}}],[\"走到空节点时时\",{\"1\":{\"94\":1}}],[\"走到\",{\"1\":{\"59\":1}}],[\"相等\",{\"1\":{\"310\":2}}],[\"相交的位置在\",{\"1\":{\"311\":2}}],[\"相交部分长度为\",{\"1\":{\"309\":1}}],[\"相交节点前有\",{\"1\":{\"307\":4}}],[\"相交节点的值为\",{\"1\":{\"307\":2}}],[\"相当于闭区间\",{\"1\":{\"267\":1}}],[\"相当于缩小左边界\",{\"1\":{\"225\":1}}],[\"相当于缩小下边界\",{\"1\":{\"225\":1}}],[\"相当于缩小右边界\",{\"1\":{\"225\":1}}],[\"相当于缩小上边界\",{\"1\":{\"225\":1}}],[\"相同类型数据\",{\"1\":{\"264\":1}}],[\"相似\",{\"1\":{\"86\":1}}],[\"相遇点到入环点的距离\",{\"1\":{\"59\":1}}],[\"相遇时\",{\"1\":{\"59\":1}}],[\"相关配置文档请见\",{\"1\":{\"1\":1}}],[\"z\",{\"1\":{\"59\":1,\"61\":1}}],[\"从各自的表头开始算起\",{\"1\":{\"307\":3}}],[\"从而维持系统的稳定运行\",{\"1\":{\"303\":1}}],[\"从而将\",{\"1\":{\"271\":1}}],[\"从前往后遍历\",{\"1\":{\"244\":1}}],[\"从下向上填充\",{\"1\":{\"225\":2}}],[\"从下到上\",{\"1\":{\"223\":1}}],[\"从右向左填充\",{\"1\":{\"225\":2}}],[\"从右到左\",{\"1\":{\"223\":1}}],[\"从上向下填充\",{\"1\":{\"225\":2}}],[\"从上到下\",{\"1\":{\"223\":1}}],[\"从左向右填充\",{\"1\":{\"225\":1}}],[\"从左到右填充\",{\"1\":{\"225\":1}}],[\"从左到右\",{\"1\":{\"223\":1}}],[\"从字符串开头算起\",{\"1\":{\"213\":1}}],[\"从队列的开头移除并返回元素\",{\"1\":{\"151\":1}}],[\"从当前节点的后驱节点进行遍历\",{\"1\":{\"117\":1}}],[\"从链表头部到入环点的距离\",{\"1\":{\"59\":1}}],[\"从\",{\"1\":{\"59\":1,\"309\":2}}],[\"从相遇节点\",{\"1\":{\"59\":1}}],[\"从头节点到环形入口节点的节点数为\",{\"1\":{\"59\":1}}],[\"从头节点出发\",{\"1\":{\"59\":1}}],[\"your\",{\"1\":{\"154\":1,\"242\":1}}],[\"y+z\",{\"1\":{\"59\":3}}],[\"y\",{\"1\":{\"59\":1,\"88\":6}}],[\"yml\",{\"1\":{\"4\":2}}],[\"最差情况下\",{\"1\":{\"311\":1}}],[\"最大堆\",{\"1\":{\"303\":1}}],[\"最大堆的特点是父节点的优先级总是\",{\"1\":{\"303\":1}}],[\"最大子数组问题\",{\"1\":{\"271\":1}}],[\"最大的平方和为\",{\"1\":{\"112\":2}}],[\"最小\",{\"1\":{\"271\":1}}],[\"最小窗口长度右移\",{\"1\":{\"141\":1}}],[\"最左的下标为\",{\"1\":{\"268\":1}}],[\"最坏情况下\",{\"1\":{\"209\":1}}],[\"最坏的情况是字符串中不存在相邻重复项\",{\"1\":{\"50\":1,\"53\":1}}],[\"最多调用\",{\"1\":{\"144\":1,\"151\":1}}],[\"最多为\",{\"1\":{\"133\":1}}],[\"最多是1\",{\"1\":{\"104\":1}}],[\"最后返回\",{\"1\":{\"268\":1}}],[\"最后返回的结果\",{\"1\":{\"268\":1}}],[\"最后返回的时候是\",{\"1\":{\"121\":1}}],[\"最后循环\",{\"1\":{\"268\":1}}],[\"最后一个节点的指针域指向\",{\"1\":{\"287\":1}}],[\"最后一个节点的后驱节点是新节点\",{\"1\":{\"242\":1}}],[\"最后一次翻转\",{\"1\":{\"216\":1}}],[\"最后\",{\"1\":{\"175\":1}}],[\"最后会返回1\",{\"1\":{\"112\":1}}],[\"最后再判断栈是不是为空\",{\"1\":{\"102\":1}}],[\"最后将所有单词拼接起来\",{\"1\":{\"77\":1}}],[\"最后还要通过哈希表进行去重\",{\"1\":{\"67\":1}}],[\"最终\",{\"1\":{\"59\":1,\"268\":1}}],[\"步骤1\",{\"1\":{\"294\":2}}],[\"步骤二\",{\"1\":{\"162\":1}}],[\"步骤三\",{\"1\":{\"162\":1}}],[\"步骤一\",{\"1\":{\"162\":1}}],[\"步才能到达慢跑者\",{\"1\":{\"112\":1}}],[\"步\",{\"1\":{\"59\":1,\"61\":2,\"94\":1,\"96\":1}}],[\"环形入口节点到\",{\"1\":{\"59\":1}}],[\"环形证明\",{\"1\":{\"58\":1}}],[\"环形链表\",{\"0\":{\"55\":1,\"56\":1,\"284\":1},\"1\":{\"284\":1}}],[\"空间解决此题\",{\"1\":{\"57\":1}}],[\"空间复杂度主要取决于递归调用的栈空间\",{\"1\":{\"133\":1}}],[\"空间复杂度主要取决于排序额外使用的空间\",{\"1\":{\"88\":1}}],[\"空间复杂度为\",{\"1\":{\"88\":1,\"175\":1}}],[\"空间复杂度\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"245\":1,\"253\":1,\"311\":1}}],[\"59\",{\"0\":{\"219\":1,\"220\":1}}],[\"541\",{\"0\":{\"211\":1,\"212\":1}}],[\"5000\",{\"1\":{\"126\":3}}],[\"50\",{\"1\":{\"116\":2,\"173\":1}}],[\"5\",{\"1\":{\"57\":2,\"65\":2,\"92\":2,\"116\":2,\"126\":2,\"165\":1,\"173\":2,\"181\":1,\"189\":1,\"198\":1,\"221\":1,\"228\":2,\"268\":1,\"307\":9}}],[\"内存的解决方案\",{\"1\":{\"307\":1}}],[\"内存地址是连续\",{\"1\":{\"265\":1}}],[\"内部使用一个\",{\"1\":{\"303\":1}}],[\"内部定义一个\",{\"1\":{\"240\":1}}],[\"内\",{\"1\":{\"57\":1,\"116\":1,\"158\":1}}],[\"内容\",{\"1\":{\"16\":1}}],[\"其子节点的优先级\",{\"1\":{\"303\":1}}],[\"其实这也是写程序中的重要原则\",{\"1\":{\"272\":1}}],[\"其实相当于告诉我们\",{\"1\":{\"268\":1}}],[\"其余字符保持原样\",{\"1\":{\"213\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"181\":1}}],[\"其元素排列顺序和出栈顺序相同\",{\"1\":{\"147\":1}}],[\"其中哈希表操作都是\",{\"1\":{\"209\":1}}],[\"其中\",{\"1\":{\"59\":1,\"67\":1,\"80\":1,\"147\":1,\"208\":1,\"242\":1,\"245\":1}}],[\"其中又只有\",{\"1\":{\"46\":1}}],[\"其尾部连接到第一个节点\",{\"1\":{\"57\":1}}],[\"其尾部连接到第二个节点\",{\"1\":{\"57\":1}}],[\"链长度为\",{\"1\":{\"311\":2}}],[\"链中的所有其他数字都是节点\",{\"1\":{\"110\":1}}],[\"链表必须\",{\"1\":{\"307\":1}}],[\"链表性能分析\",{\"0\":{\"298\":1}}],[\"链表操作\",{\"0\":{\"293\":1}}],[\"链表节点类\",{\"1\":{\"292\":1}}],[\"链表节点交换的指针变动\",{\"1\":{\"161\":1}}],[\"链表的组成单位是\",{\"1\":{\"292\":1}}],[\"链表的基本操作\",{\"0\":{\"282\":1}}],[\"链表在内存中可不是连续分布的\",{\"1\":{\"292\":1}}],[\"链表存储方式\",{\"0\":{\"292\":1}}],[\"链表类型\",{\"0\":{\"288\":1}}],[\"链表是通过\",{\"1\":{\"292\":1}}],[\"链表是一种通过指针串联在一起的线性结构\",{\"1\":{\"287\":1}}],[\"链表是什么\",{\"0\":{\"287\":1}}],[\"链表理论基础\",{\"0\":{\"286\":1}}],[\"链表相交\",{\"0\":{\"283\":1,\"305\":1,\"306\":1},\"1\":{\"283\":1}}],[\"链表总结篇\",{\"0\":{\"278\":1}}],[\"链表基本操作\",{\"1\":{\"239\":1}}],[\"链表结果\",{\"1\":{\"239\":1}}],[\"链表变为\",{\"1\":{\"238\":2}}],[\"链表可以选用迭代或递归方式完成反转\",{\"1\":{\"126\":1}}],[\"链表中数据的插入\",{\"1\":{\"299\":1}}],[\"链表中节点的数目在范围\",{\"1\":{\"158\":1}}],[\"链表中节点的数目范围是\",{\"1\":{\"126\":1}}],[\"链表中节点的数目范围在范围\",{\"1\":{\"57\":1}}],[\"链表中结点的数目为\",{\"1\":{\"92\":1}}],[\"链表中没有环\",{\"1\":{\"57\":1}}],[\"链表中有一个环\",{\"1\":{\"57\":2}}],[\"链表\",{\"1\":{\"57\":1,\"58\":1,\"93\":1,\"116\":1,\"127\":1,\"159\":1,\"257\":1,\"307\":6,\"308\":1},\"2\":{\"62\":1,\"97\":1,\"123\":1,\"134\":1,\"246\":1,\"285\":1,\"300\":1,\"312\":1}}],[\"链接在内存中各个节点\",{\"1\":{\"292\":1}}],[\"链接\",{\"1\":{\"7\":1}}],[\"仅用\",{\"1\":{\"307\":1}}],[\"仅包含小写字母\",{\"1\":{\"165\":1}}],[\"仅作为临时放置\",{\"1\":{\"147\":1}}],[\"仅由小写英文组成\",{\"1\":{\"213\":1}}],[\"仅由小写英文字母组成\",{\"1\":{\"46\":1}}],[\"仅由括号\",{\"1\":{\"100\":1}}],[\"仅仅是为了标识链表的实际情况\",{\"1\":{\"57\":1}}],[\"不涉及到什么算法\",{\"1\":{\"272\":1}}],[\"不断调节子序列的起始位置\",{\"1\":{\"271\":1}}],[\"不要立即返回\",{\"1\":{\"269\":1}}],[\"不要给另外的数组分配额外的空间\",{\"1\":{\"181\":1}}],[\"不在数组中\",{\"1\":{\"268\":1}}],[\"不管是因为什么原因导致的\",{\"1\":{\"267\":1}}],[\"不会插入\",{\"1\":{\"238\":1}}],[\"不足\",{\"1\":{\"217\":1}}],[\"不同字母的个数\",{\"1\":{\"200\":1}}],[\"不同的元素的数量\",{\"1\":{\"173\":1}}],[\"不同的三元组是\",{\"1\":{\"65\":1}}],[\"不考虑输出结果的顺序\",{\"1\":{\"189\":1}}],[\"不相同\",{\"1\":{\"175\":1}}],[\"不是快乐数\",{\"1\":{\"110\":1,\"112\":1}}],[\"不是\",{\"1\":{\"108\":1}}],[\"不一样时\",{\"1\":{\"102\":1}}],[\"不判断相同答案的元素\",{\"1\":{\"69\":2}}],[\"不判断相同元素\",{\"1\":{\"69\":2}}],[\"不可以包含重复的三元组\",{\"1\":{\"68\":1}}],[\"不重复则需要\",{\"1\":{\"69\":1}}],[\"不重复\",{\"1\":{\"67\":1}}],[\"不允许修改\",{\"1\":{\"57\":1}}],[\"不作为参数进行传递\",{\"1\":{\"57\":1}}],[\"不存在\",{\"1\":{\"40\":1,\"228\":1,\"267\":1}}],[\"开始相交\",{\"1\":{\"307\":1}}],[\"开始\",{\"1\":{\"57\":1,\"238\":1,\"265\":1}}],[\"索引从\",{\"1\":{\"57\":1,\"265\":1}}],[\"来实现这一功能\",{\"1\":{\"303\":1}}],[\"来存储元素\",{\"1\":{\"303\":1}}],[\"来作为\",{\"1\":{\"303\":1}}],[\"来定义左边界\",{\"1\":{\"230\":1}}],[\"来模拟一个栈\",{\"1\":{\"151\":1}}],[\"来模拟一个队列\",{\"1\":{\"144\":1}}],[\"来表示链表尾连接到链表中的位置\",{\"1\":{\"57\":1}}],[\"来解析\",{\"1\":{\"16\":1}}],[\"评测机将使用以下代码测试您的解决方案\",{\"1\":{\"173\":1}}],[\"评测系统内部使用整数\",{\"1\":{\"57\":1}}],[\"评论\",{\"1\":{\"7\":1,\"10\":1}}],[\"则自动取消订单并释放锁定的库存\",{\"1\":{\"303\":1}}],[\"则删除链表中下标为\",{\"1\":{\"238\":1}}],[\"则还需要属性\",{\"1\":{\"238\":1}}],[\"则反转前\",{\"1\":{\"213\":1}}],[\"则不是正确答案\",{\"1\":{\"200\":2}}],[\"则跳过该数字不进行拷贝覆盖\",{\"1\":{\"175\":1}}],[\"则进行拷贝覆盖\",{\"1\":{\"175\":1}}],[\"则最终哈希表中所有字符统计数值都应为\",{\"1\":{\"167\":1}}],[\"则\",{\"1\":{\"167\":2}}],[\"则称\",{\"1\":{\"165\":1}}],[\"则说明不是快乐数\",{\"1\":{\"112\":1}}],[\"则就说明没有循环\",{\"1\":{\"110\":1}}],[\"则需要保证每一重循环枚举到的元素不小于其上一重循环枚举到的元素\",{\"1\":{\"86\":1}}],[\"则认为两个四元组重复\",{\"1\":{\"84\":1}}],[\"则在该链表中没有环\",{\"1\":{\"57\":1}}],[\"则链表中存在环\",{\"1\":{\"57\":1}}],[\"则返回\",{\"1\":{\"57\":1,\"108\":1,\"238\":1,\"244\":1}}],[\"则将剩余字符全部反转\",{\"1\":{\"213\":1}}],[\"则将\",{\"1\":{\"40\":1}}],[\"双向链表还是循环链表\",{\"1\":{\"299\":1}}],[\"双链表\",{\"0\":{\"290\":1}}],[\"双链表实现\",{\"0\":{\"243\":1}}],[\"双重循环的时间复杂度为\",{\"1\":{\"69\":1}}],[\"双指针遍历各自所在链表后\",{\"1\":{\"310\":1}}],[\"双指针法来移除链表倒数第\",{\"1\":{\"281\":1}}],[\"双指针法\",{\"0\":{\"270\":1},\"1\":{\"270\":1}}],[\"双指针指向相等时\",{\"1\":{\"252\":1}}],[\"双指针移动的更新\",{\"1\":{\"216\":1}}],[\"双指针为什么要交替移动\",{\"1\":{\"69\":1}}],[\"双指针使用常数大小的额外空间\",{\"1\":{\"61\":1}}],[\"双指针\",{\"0\":{\"94\":1,\"128\":1},\"1\":{\"53\":1,\"66\":1,\"67\":3,\"68\":1,\"74\":1,\"93\":1,\"127\":1,\"182\":1,\"214\":1,\"250\":1,\"308\":1},\"2\":{\"70\":1,\"89\":1,\"218\":1}}],[\"双端队列的直接实现类是\",{\"1\":{\"303\":1}}],[\"双端队列\",{\"0\":{\"48\":1},\"1\":{\"144\":1,\"151\":1,\"303\":1}}],[\"指针\",{\"1\":{\"309\":2}}],[\"指针域的指针\",{\"1\":{\"292\":1}}],[\"指针域\",{\"1\":{\"287\":1}}],[\"指针使用常数大小的额外空间\",{\"1\":{\"69\":1}}],[\"指针相遇节点节点数为\",{\"1\":{\"59\":1}}],[\"指针与\",{\"1\":{\"59\":1}}],[\"指针再次到达\",{\"1\":{\"57\":1}}],[\"指向下一节点的引用\",{\"1\":{\"292\":1}}],[\"指向下一个\",{\"1\":{\"215\":1}}],[\"指向下个单词的尾字符\",{\"1\":{\"78\":1}}],[\"指向的元素\",{\"1\":{\"183\":1}}],[\"指向头节点\",{\"1\":{\"128\":1}}],[\"指向虚拟节点\",{\"1\":{\"128\":1}}],[\"指向单词的范围\",{\"1\":{\"77\":1}}],[\"指向最左的元素\",{\"1\":{\"67\":1}}],[\"指向最后的数组末尾指针\",{\"1\":{\"53\":1}}],[\"指向上一个元素\",{\"1\":{\"51\":1}}],[\"指南\",{\"2\":{\"11\":1}}],[\"修改输入数组\",{\"1\":{\"181\":1}}],[\"修改节点指向\",{\"1\":{\"128\":1}}],[\"修改\",{\"1\":{\"51\":1}}],[\"时就是相交节点\",{\"1\":{\"309\":1}}],[\"时\",{\"1\":{\"69\":2,\"153\":1,\"175\":1,\"183\":2,\"223\":1,\"233\":1,\"244\":1,\"269\":1,\"303\":1,\"309\":2}}],[\"时说明\",{\"1\":{\"51\":1}}],[\"时间复杂度是多少\",{\"1\":{\"299\":1}}],[\"时间复杂度的解法\",{\"1\":{\"137\":2}}],[\"时间复杂度为\",{\"1\":{\"67\":1}}],[\"时间复杂度\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"245\":1,\"253\":1,\"311\":1}}],[\"equals\",{\"1\":{\"297\":1}}],[\"e\",{\"1\":{\"181\":2,\"294\":3,\"295\":3,\"296\":2}}],[\"expectednums\",{\"1\":{\"173\":3}}],[\"example\",{\"1\":{\"73\":2}}],[\"empty\",{\"1\":{\"144\":6,\"147\":2,\"151\":6,\"154\":3}}],[\"element\",{\"1\":{\"172\":1,\"296\":2,\"303\":2}}],[\"elements\",{\"1\":{\"115\":1}}],[\"else\",{\"1\":{\"50\":1,\"53\":1,\"69\":2,\"80\":1,\"88\":2,\"104\":3,\"119\":1,\"122\":1,\"232\":2,\"233\":1,\"234\":2,\"242\":2,\"245\":2,\"253\":2,\"267\":2,\"268\":2,\"269\":2,\"294\":1,\"295\":1,\"296\":2,\"297\":1}}],[\"ended\",{\"1\":{\"303\":1}}],[\"end++\",{\"1\":{\"141\":1}}],[\"end−start+1\",{\"1\":{\"139\":1}}],[\"end\",{\"1\":{\"80\":5,\"91\":1,\"139\":1,\"141\":6,\"267\":1}}],[\"enhance\",{\"1\":{\"18\":1}}],[\"env\",{\"1\":{\"4\":1}}],[\"environment\",{\"1\":{\"4\":1}}],[\"enable\",{\"1\":{\"4\":1}}],[\"利用栈的思想来判断匹配情况\",{\"1\":{\"49\":1}}],[\"说明找到了目标节点并返回\",{\"1\":{\"244\":1}}],[\"说明\",{\"1\":{\"51\":1,\"67\":2,\"151\":1,\"200\":1}}],[\"说明不是重复项\",{\"1\":{\"48\":1}}],[\"说明此时是重复项已经出现\",{\"1\":{\"48\":1}}],[\"此时需遍历\",{\"1\":{\"311\":1}}],[\"此时不需要翻转\",{\"1\":{\"217\":1}}],[\"此时应该是最后一次\",{\"1\":{\"217\":1}}],[\"此时\",{\"1\":{\"141\":1,\"223\":1,\"267\":1}}],[\"此时剩余两个元素都\",{\"1\":{\"69\":1}}],[\"此时将队列尾部元素删除\",{\"1\":{\"48\":1}}],[\"此文字有脚注\",{\"1\":{\"20\":1}}],[\"当用户下单后\",{\"1\":{\"303\":1}}],[\"当子节点小于父节点\",{\"1\":{\"303\":1}}],[\"当空间不足时\",{\"1\":{\"275\":1}}],[\"当退出循环时\",{\"1\":{\"267\":1}}],[\"当left\",{\"1\":{\"253\":1}}],[\"当索引小于链表长度的一半时\",{\"1\":{\"244\":1}}],[\"当区间长度为\",{\"1\":{\"233\":1}}],[\"当我们使用数组实现哈希表时\",{\"1\":{\"258\":1}}],[\"当我们选择\",{\"1\":{\"230\":1}}],[\"当我们遇到一个右括号时\",{\"1\":{\"102\":1}}],[\"当我们遇到一个左括号时\",{\"1\":{\"102\":1}}],[\"当链表还剩下两个节点时\",{\"1\":{\"160\":1}}],[\"当窗口符合条件时\",{\"1\":{\"140\":1}}],[\"当第一次递归时\",{\"1\":{\"132\":1}}],[\"当\",{\"1\":{\"94\":1,\"139\":1,\"183\":2,\"223\":1,\"244\":1,\"267\":1,\"269\":1,\"309\":2}}],[\"当前节点的父节点位置\",{\"1\":{\"303\":1}}],[\"当前节点位置\",{\"1\":{\"303\":1}}],[\"当前节点\",{\"1\":{\"130\":1}}],[\"当前的右括号\",{\"1\":{\"102\":1}}],[\"当前字符与末尾元素不相同时\",{\"1\":{\"53\":1}}],[\"当前字符与队列尾部不同时\",{\"1\":{\"48\":1}}],[\"当前字符与队列尾部相同时\",{\"1\":{\"48\":1}}],[\"当前是相邻重复项\",{\"1\":{\"51\":1}}],[\"当字符串中同时有多组相邻重复项时\",{\"1\":{\"48\":1}}],[\"存储头节点\",{\"1\":{\"94\":1}}],[\"存储虚拟头节点\",{\"1\":{\"94\":2}}],[\"存储遍历的情况\",{\"1\":{\"48\":1}}],[\"存在\",{\"1\":{\"40\":1,\"200\":1,\"267\":1}}],[\"数据同步\",{\"1\":{\"303\":1}}],[\"数据域\",{\"1\":{\"287\":1}}],[\"数据结构使用过程叙述\",{\"1\":{\"276\":1}}],[\"数字和空格\",{\"1\":{\"73\":1}}],[\"数字或者队列\",{\"1\":{\"48\":1}}],[\"数组的特点\",{\"0\":{\"265\":1}}],[\"数组是存放在\",{\"1\":{\"264\":1}}],[\"数组总结篇\",{\"0\":{\"263\":1}}],[\"数组元素则是对应的value\",{\"1\":{\"258\":1}}],[\"数组变为\",{\"1\":{\"249\":2}}],[\"数组中小于\",{\"1\":{\"268\":2}}],[\"数组中每个元素之和都不相同\",{\"1\":{\"209\":1}}],[\"数组中同一个元素在答案里不能重复出现\",{\"1\":{\"38\":1}}],[\"数组长度都是\",{\"1\":{\"206\":1}}],[\"数组长度为常数\",{\"1\":{\"169\":1}}],[\"数组为空时\",{\"1\":{\"53\":1}}],[\"数组\",{\"0\":{\"51\":1},\"1\":{\"47\":1,\"173\":1,\"174\":1,\"222\":1,\"229\":1,\"257\":1},\"2\":{\"70\":1,\"89\":1,\"178\":1,\"195\":1,\"210\":1,\"235\":1,\"254\":1}}],[\"栈是一种\",{\"1\":{\"274\":1}}],[\"栈是后进先出\",{\"1\":{\"146\":1}}],[\"栈理论基础篇\",{\"0\":{\"273\":1}}],[\"栈\",{\"1\":{\"47\":1,\"101\":1,\"145\":1},\"2\":{\"105\":1,\"148\":1,\"155\":1,\"277\":1}}],[\"这两个链表不相交\",{\"1\":{\"307\":1}}],[\"这类链表题目一般都是使用双指针法解决的\",{\"1\":{\"284\":1}}],[\"这样\",{\"1\":{\"225\":1}}],[\"这样方便后续做删除操作\",{\"1\":{\"162\":1}}],[\"这样就能保证我们每一层循环都可以过滤掉相同的元素\",{\"1\":{\"67\":1}}],[\"这些操作\",{\"1\":{\"144\":1}}],[\"这是他们可以开始的最远的距离\",{\"1\":{\"112\":1}}],[\"这是此时唯一可以执行删除操作的重复项\",{\"1\":{\"46\":1}}],[\"这种情况\",{\"1\":{\"102\":1}}],[\"这意味着你可以在\",{\"1\":{\"33\":1}}],[\"例如寻找距离尾部第\",{\"1\":{\"284\":1}}],[\"例如\",{\"1\":{\"46\":1,\"151\":1}}],[\"在遍历对方的链表\",{\"1\":{\"310\":1}}],[\"在遍历过程过程\",{\"1\":{\"244\":1}}],[\"在遍历过程中如果出现数字与需要移除的值\",{\"1\":{\"175\":1}}],[\"在用户注册\",{\"1\":{\"303\":1}}],[\"在线购物平台中\",{\"1\":{\"303\":1}}],[\"在链表第\",{\"1\":{\"282\":1}}],[\"在链表的最后面插入一个节点\",{\"1\":{\"282\":1}}],[\"在链表的最前面插入一个节点\",{\"1\":{\"282\":1}}],[\"在循环过程中\",{\"1\":{\"268\":1}}],[\"在数组中\",{\"1\":{\"268\":1}}],[\"在区间\",{\"1\":{\"268\":1}}],[\"在上面的\",{\"1\":{\"267\":1}}],[\"在冲突的地方继续往前查询\",{\"1\":{\"261\":1}}],[\"在负数\",{\"1\":{\"253\":1}}],[\"在正数\",{\"1\":{\"253\":1}}],[\"在插入完成后\",{\"1\":{\"238\":1}}],[\"在左闭右开的情况是找不到这个位置的\",{\"1\":{\"230\":1}}],[\"在左闭右开的情况\",{\"1\":{\"230\":1}}],[\"在加入元素时先将\",{\"1\":{\"147\":1}}],[\"在每一次移动过程中\",{\"1\":{\"128\":1}}],[\"在虚拟头节点下\",{\"1\":{\"121\":1}}],[\"在环中它们由于步速不一致\",{\"1\":{\"112\":1}}],[\"在继续往下后\",{\"1\":{\"112\":1}}],[\"在固定两重循环元素的情况\",{\"1\":{\"69\":1}}],[\"在固定两个元素的情况下\",{\"1\":{\"67\":1}}],[\"在次相遇就是环入口\",{\"1\":{\"61\":1}}],[\"在完成所有重复项删除操作后返回最终的字符串\",{\"1\":{\"46\":1}}],[\"在\",{\"1\":{\"46\":2,\"153\":1,\"233\":1,\"274\":1,\"302\":2,\"307\":4}}],[\"在页面禁用功能与布局\",{\"1\":{\"7\":1}}],[\"并删除旧的数组尾元素\",{\"1\":{\"303\":1}}],[\"并删除它们\",{\"1\":{\"46\":1}}],[\"并且其他请求访问的线程必须等待直到计数器非零\",{\"1\":{\"303\":1}}],[\"并且\",{\"1\":{\"173\":2}}],[\"并且返回链表的头结点\",{\"1\":{\"92\":1}}],[\"并支持普通栈的全部四种操作\",{\"1\":{\"144\":1}}],[\"并返回交换后链表的头节点\",{\"1\":{\"158\":1}}],[\"并返回其长度\",{\"1\":{\"137\":1}}],[\"并返回反转后的链表\",{\"1\":{\"126\":1}}],[\"并返回\",{\"1\":{\"116\":1}}],[\"并返回它们的数组下标\",{\"1\":{\"38\":1}}],[\"并将当前元素与栈顶元素判断是否相同\",{\"1\":{\"103\":1}}],[\"并将双指针指向新的单词\",{\"1\":{\"77\":1}}],[\"会实现一个\",{\"1\":{\"303\":1}}],[\"会将所有的key能映射到数组上对应的索引\",{\"1\":{\"258\":1}}],[\"会相遇\",{\"1\":{\"112\":1}}],[\"会先到\",{\"1\":{\"110\":1}}],[\"会先于\",{\"1\":{\"59\":1}}],[\"会选择两个相邻且相同的字母\",{\"1\":{\"46\":1}}],[\"会使用\",{\"1\":{\"16\":1}}],[\"给定两个数组\",{\"1\":{\"189\":1}}],[\"给定两个字符串\",{\"1\":{\"165\":1}}],[\"给定一个\",{\"1\":{\"228\":1}}],[\"给定一个字符串\",{\"1\":{\"213\":1}}],[\"给定一个含有\",{\"1\":{\"137\":1}}],[\"给定一个只包括\",{\"1\":{\"100\":1}}],[\"给定一个链表的头节点\",{\"1\":{\"57\":1}}],[\"给定一个整数数组\",{\"1\":{\"38\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"307\":1}}],[\"给你两个字符串\",{\"1\":{\"198\":1}}],[\"给你四个整数数组\",{\"1\":{\"206\":1}}],[\"给你单链表的头节点\",{\"1\":{\"126\":1}}],[\"给你一个按\",{\"1\":{\"249\":1}}],[\"给你一个正整数\",{\"1\":{\"221\":1}}],[\"给你一个数组\",{\"1\":{\"173\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"116\":1}}],[\"给你一个链表\",{\"1\":{\"92\":1,\"158\":1}}],[\"给你一个由\",{\"1\":{\"84\":1}}],[\"给你一个字符串\",{\"1\":{\"73\":1}}],[\"给你一个整数数组\",{\"1\":{\"65\":1}}],[\"给出由小写字母组成的字符串\",{\"1\":{\"46\":1}}],[\"令\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"69\":1,\"76\":1,\"78\":1,\"88\":1,\"96\":1,\"104\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"245\":1,\"253\":1,\"311\":1}}],[\"复杂度分析\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"245\":1,\"253\":1,\"311\":1}}],[\"<target\",{\"1\":{\"230\":1,\"233\":1}}],[\"<3\",{\"1\":{\"69\":1}}],[\"<0>0=0\",{\"1\":{\"67\":1}}],[\"<\",{\"1\":{\"42\":1,\"67\":1,\"69\":9,\"80\":3,\"84\":1,\"88\":8,\"96\":1,\"141\":1,\"169\":2,\"173\":1,\"183\":1,\"185\":1,\"194\":1,\"200\":1,\"202\":1,\"206\":1,\"217\":2,\"232\":2,\"233\":1,\"234\":1,\"245\":1,\"253\":2,\"267\":3,\"268\":3,\"269\":2,\"303\":3}}],[\"<=bottom\",{\"1\":{\"225\":1}}],[\"<=\",{\"1\":{\"38\":6,\"46\":2,\"51\":1,\"53\":1,\"57\":2,\"65\":4,\"73\":2,\"80\":3,\"84\":7,\"92\":6,\"100\":2,\"108\":2,\"116\":4,\"126\":2,\"137\":6,\"144\":2,\"151\":2,\"158\":2,\"165\":2,\"173\":6,\"181\":2,\"189\":4,\"198\":2,\"202\":1,\"206\":5,\"213\":4,\"221\":2,\"225\":2,\"234\":1,\"238\":2,\"242\":1,\"245\":1,\"249\":4,\"267\":1,\"307\":8}}],[\"语言支持\",{\"1\":{\"42\":1,\"50\":1,\"61\":1,\"69\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"130\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"242\":1,\"253\":1,\"311\":1}}],[\"语法\",{\"0\":{\"22\":1},\"1\":{\"18\":1,\"33\":1}}],[\"语法进行了扩展\",{\"1\":{\"17\":1}}],[\"语法扩展\",{\"1\":{\"16\":1}}],[\"代表当前节点\",{\"1\":{\"160\":1}}],[\"代表这个重复元素不可能是解\",{\"1\":{\"40\":1}}],[\"代码随想录\",{\"1\":{\"128\":1}}],[\"代码\",{\"0\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"245\":1,\"253\":1,\"311\":1}}],[\"每一个节点有两个指针域\",{\"1\":{\"290\":1}}],[\"每一个节点由两部分组成\",{\"1\":{\"287\":1}}],[\"每一次将该数替换为它每个位置上的数字的平方和\",{\"1\":{\"108\":1}}],[\"每移动一次就减小\",{\"1\":{\"244\":1}}],[\"每计数至\",{\"1\":{\"213\":1}}],[\"每次循环的\",{\"1\":{\"268\":1}}],[\"每次比较两个指针对应的数\",{\"1\":{\"251\":1}}],[\"每次翻转完\",{\"1\":{\"215\":1}}],[\"每次取出的数字变量为\",{\"1\":{\"175\":1}}],[\"每次调用\",{\"1\":{\"144\":1}}],[\"每次走一步\",{\"1\":{\"59\":1}}],[\"每次走\",{\"1\":{\"59\":1}}],[\"每次走两步\",{\"1\":{\"59\":2}}],[\"每种输入只会对应一个答案\",{\"1\":{\"41\":1}}],[\"每个节点存放着下一个节点的内存地址\",{\"1\":{\"292\":1}}],[\"每个数字的平方\",{\"1\":{\"249\":1}}],[\"每个字符的情况\",{\"1\":{\"200\":1}}],[\"每个右括号都有一个对应的相同类型的左括号\",{\"1\":{\"100\":1}}],[\"每个\",{\"1\":{\"33\":1}}],[\"关键点\",{\"0\":{\"41\":1,\"49\":1,\"52\":1,\"60\":1,\"68\":1,\"87\":1,\"95\":1,\"103\":1,\"111\":1,\"118\":1,\"121\":1,\"129\":1,\"132\":1,\"140\":1,\"161\":1,\"168\":1,\"176\":1,\"184\":1,\"193\":1,\"201\":1,\"216\":1,\"224\":1,\"231\":1,\"241\":1,\"244\":1,\"252\":1,\"310\":1}}],[\"关于这些扩展\",{\"1\":{\"17\":1}}],[\"关于本站\",{\"0\":{\"4\":1}}],[\"关于我\",{\"0\":{\"2\":1,\"3\":1}}],[\"同样的题目还有\",{\"1\":{\"201\":1}}],[\"同样的道理\",{\"1\":{\"40\":1}}],[\"同时指向\",{\"1\":{\"309\":1}}],[\"同时指向第一个相交节点\",{\"1\":{\"309\":1}}],[\"同时设置一个下标\",{\"1\":{\"175\":1}}],[\"同时往中间移动的时候处理相同元素的情况\",{\"1\":{\"67\":1}}],[\"同时还满足\",{\"1\":{\"65\":1}}],[\"同时每个页面包含\",{\"1\":{\"10\":1}}],[\"插入元素的过程\",{\"1\":{\"303\":1}}],[\"插入和删除元素\",{\"1\":{\"265\":1}}],[\"插入\",{\"1\":{\"241\":1,\"298\":1}}],[\"插入哈希表\",{\"1\":{\"40\":1}}],[\"插件来实现\",{\"1\":{\"16\":1}}],[\"x+y+n\",{\"1\":{\"59\":2}}],[\"x+y\",{\"1\":{\"59\":2,\"61\":1}}],[\"x\",{\"1\":{\"40\":5,\"41\":2,\"59\":2,\"61\":2,\"88\":8,\"144\":3,\"147\":2,\"151\":3,\"154\":3,\"221\":1,\"292\":2,\"296\":7,\"297\":12,\"311\":2}}],[\"思路改进\",{\"0\":{\"233\":1}}],[\"思路2\",{\"0\":{\"120\":1,\"131\":1}}],[\"思路1\",{\"0\":{\"117\":1,\"128\":1,\"139\":1,\"160\":1}}],[\"思路3\",{\"0\":{\"79\":1}}],[\"思路\",{\"0\":{\"40\":1,\"48\":1,\"51\":1,\"59\":1,\"67\":1,\"75\":1,\"77\":1,\"86\":1,\"94\":1,\"102\":1,\"110\":1,\"146\":1,\"153\":1,\"167\":1,\"175\":1,\"183\":1,\"192\":1,\"200\":1,\"208\":1,\"215\":1,\"223\":1,\"230\":1,\"240\":1,\"243\":1,\"251\":1,\"309\":1}}],[\"进行下一轮的判断并且交换\",{\"1\":{\"160\":1}}],[\"进行遍历\",{\"1\":{\"94\":1}}],[\"进行引用\",{\"1\":{\"32\":1}}],[\"进阶\",{\"1\":{\"38\":1,\"57\":1,\"73\":1,\"92\":1,\"126\":1,\"137\":1,\"144\":1,\"151\":1,\"165\":1,\"249\":1,\"307\":1}}],[\"提示\",{\"1\":{\"38\":1,\"46\":1,\"57\":1,\"65\":1,\"73\":1,\"84\":1,\"92\":1,\"100\":1,\"108\":1,\"116\":1,\"126\":1,\"137\":1,\"144\":1,\"151\":1,\"158\":1,\"165\":1,\"173\":1,\"181\":1,\"189\":1,\"198\":1,\"206\":1,\"213\":1,\"221\":1,\"228\":1,\"238\":1,\"249\":1,\"307\":1}}],[\"提供更加丰富的写作功能\",{\"1\":{\"18\":1}}],[\"62\",{\"1\":{\"108\":1}}],[\"68\",{\"1\":{\"108\":1}}],[\"6\",{\"1\":{\"38\":2,\"116\":3,\"221\":1,\"307\":2}}],[\"404\",{\"1\":{\"313\":1}}],[\"49\",{\"1\":{\"249\":1}}],[\"454\",{\"0\":{\"204\":1,\"205\":1}}],[\"4位数只会降到3位数\",{\"1\":{\"112\":1}}],[\"4sum\",{\"1\":{\"83\":1,\"205\":1}}],[\"4\",{\"1\":{\"38\":2,\"57\":2,\"65\":3,\"73\":1,\"92\":1,\"116\":3,\"126\":2,\"137\":5,\"154\":1,\"158\":2,\"165\":1,\"173\":3,\"189\":5,\"213\":2,\"221\":1,\"228\":2,\"249\":5,\"307\":13}}],[\"383\",{\"0\":{\"196\":1,\"197\":1}}],[\"349\",{\"0\":{\"187\":1,\"188\":1}}],[\"344\",{\"0\":{\"179\":1,\"180\":1}}],[\"324\",{\"1\":{\"112\":1}}],[\"30\",{\"1\":{\"92\":1,\"303\":1}}],[\"3000\",{\"1\":{\"65\":1}}],[\"3sum\",{\"1\":{\"64\":1}}],[\"3\",{\"0\":{\"269\":1},\"1\":{\"38\":4,\"40\":1,\"57\":2,\"65\":3,\"73\":1,\"88\":3,\"92\":3,\"100\":1,\"116\":3,\"126\":3,\"137\":4,\"154\":1,\"158\":3,\"173\":6,\"198\":1,\"221\":2,\"223\":1,\"228\":2,\"234\":1,\"238\":6,\"249\":3,\"307\":9}}],[\"返回队列开头的元素\",{\"1\":{\"151\":1}}],[\"返回栈顶元素\",{\"1\":{\"144\":1}}],[\"返回反转之后的头节点\",{\"1\":{\"131\":1}}],[\"返回答案\",{\"1\":{\"84\":1}}],[\"返回的结果字符串中\",{\"1\":{\"73\":1}}],[\"返回索引为\",{\"1\":{\"57\":2}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"57\":1}}],[\"返回\",{\"1\":{\"38\":1,\"57\":1,\"73\":1,\"137\":1,\"144\":5,\"151\":2,\"173\":1,\"189\":1,\"198\":1,\"238\":2,\"249\":1,\"307\":1}}],[\"返回顶部按钮\",{\"1\":{\"7\":1,\"10\":1}}],[\"因为java语言不需要申请长度为n的数组来存储字符\",{\"1\":{\"217\":1}}],[\"因为要取\",{\"1\":{\"216\":1}}],[\"因为\",{\"1\":{\"38\":1}}],[\"因此返回\",{\"1\":{\"307\":1}}],[\"因此下次\",{\"1\":{\"267\":1}}],[\"因此提供查询节点的方法\",{\"1\":{\"240\":1}}],[\"因此我们不能跳过这个\",{\"1\":{\"233\":1}}],[\"因此我们更新左边界的时候\",{\"1\":{\"230\":1}}],[\"因此我们需要\",{\"1\":{\"86\":1}}],[\"因此右边界我们是判断不到的\",{\"1\":{\"230\":1}}],[\"因此它们并不计入评测\",{\"1\":{\"173\":2}}],[\"因此空间复杂度为常数\",{\"1\":{\"169\":1}}],[\"因此要找到\",{\"1\":{\"95\":1}}],[\"因此总时间复杂度为\",{\"1\":{\"88\":1}}],[\"因此需要先排序\",{\"1\":{\"69\":1}}],[\"因此可以借助于\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"13\":1}}],[\"07\",{\"0\":{\"305\":1,\"306\":1},\"1\":{\"283\":1}}],[\"02\",{\"0\":{\"306\":1},\"1\":{\"108\":2,\"283\":1}}],[\"0\",{\"1\":{\"38\":4,\"42\":2,\"50\":1,\"53\":3,\"57\":5,\"65\":21,\"67\":6,\"69\":14,\"78\":3,\"80\":4,\"84\":8,\"88\":2,\"92\":1,\"96\":1,\"112\":2,\"116\":2,\"126\":1,\"137\":2,\"141\":6,\"147\":2,\"158\":2,\"162\":1,\"167\":1,\"169\":3,\"173\":11,\"177\":1,\"185\":1,\"189\":1,\"194\":4,\"200\":1,\"202\":1,\"206\":20,\"209\":2,\"217\":1,\"225\":2,\"228\":2,\"230\":1,\"232\":1,\"233\":1,\"234\":1,\"238\":2,\"242\":4,\"244\":1,\"245\":3,\"249\":4,\"251\":1,\"253\":1,\"265\":1,\"267\":2,\"268\":6,\"269\":2,\"303\":4,\"307\":12,\"309\":2}}],[\"06\",{\"1\":{\"4\":3}}],[\"输出结果中的每个元素一定是\",{\"1\":{\"189\":1}}],[\"输出一个节点\",{\"1\":{\"131\":1}}],[\"输出的顺序和三元组的顺序并不重要\",{\"1\":{\"65\":1}}],[\"输出\",{\"1\":{\"38\":3,\"46\":1,\"57\":3,\"65\":3,\"73\":3,\"84\":2,\"92\":3,\"100\":3,\"108\":2,\"116\":3,\"126\":3,\"137\":3,\"144\":1,\"151\":1,\"158\":3,\"165\":2,\"173\":2,\"181\":2,\"189\":2,\"198\":3,\"206\":2,\"213\":2,\"221\":2,\"228\":2,\"238\":1,\"249\":2,\"307\":3}}],[\"输入数组\",{\"1\":{\"173\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"181\":1}}],[\"输入字符串\",{\"1\":{\"73\":1}}],[\"输入\",{\"1\":{\"38\":3,\"46\":1,\"57\":3,\"65\":3,\"73\":3,\"84\":2,\"92\":3,\"100\":3,\"108\":2,\"116\":3,\"126\":3,\"137\":3,\"144\":1,\"151\":1,\"158\":3,\"165\":2,\"173\":2,\"181\":2,\"189\":2,\"198\":3,\"206\":2,\"213\":2,\"221\":2,\"228\":2,\"238\":1,\"249\":2,\"307\":3}}],[\"977\",{\"0\":{\"247\":1,\"248\":1}}],[\"9999\",{\"1\":{\"228\":2}}],[\"9^2+9^2+9^2\",{\"1\":{\"112\":1}}],[\"92\",{\"1\":{\"108\":1}}],[\"9\",{\"1\":{\"38\":6,\"144\":1,\"151\":1,\"189\":5,\"221\":1,\"228\":4,\"249\":5,\"307\":2}}],[\"707\",{\"0\":{\"236\":1,\"237\":1},\"1\":{\"282\":1}}],[\"704\",{\"0\":{\"226\":1,\"227\":1}}],[\"7\",{\"1\":{\"38\":1,\"116\":5,\"137\":1,\"221\":1,\"249\":1,\"268\":1}}],[\"示例\",{\"1\":{\"38\":3,\"46\":1,\"57\":3,\"65\":3,\"73\":3,\"84\":2,\"92\":3,\"100\":3,\"108\":2,\"116\":3,\"126\":3,\"137\":3,\"144\":1,\"151\":1,\"158\":3,\"165\":2,\"173\":2,\"181\":2,\"189\":2,\"198\":3,\"206\":2,\"213\":2,\"221\":2,\"228\":2,\"238\":1,\"249\":2,\"307\":3}}],[\"两两交换其中相邻的节点\",{\"1\":{\"158\":1}}],[\"两两交换链表中的节点\",{\"0\":{\"156\":1,\"157\":1}}],[\"两个元组如下\",{\"1\":{\"206\":1}}],[\"两个存储数组都是固定长度\",{\"1\":{\"194\":1}}],[\"两个数组的交集\",{\"0\":{\"187\":1,\"188\":1}}],[\"两个指针分别指向待反转的范围\",{\"1\":{\"215\":1}}],[\"两个指针\",{\"1\":{\"185\":1}}],[\"两个\",{\"1\":{\"38\":1}}],[\"两数之和思路\",{\"1\":{\"207\":1}}],[\"两数之和\",{\"0\":{\"36\":1,\"37\":1}}],[\"力扣\",{\"0\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"+1\",{\"1\":{\"167\":1,\"232\":1}}],[\"+=\",{\"1\":{\"112\":1,\"141\":1,\"209\":1}}],[\"+z\",{\"1\":{\"59\":1}}],[\"++\",{\"1\":{\"169\":1,\"194\":2,\"202\":1}}],[\"++end\",{\"1\":{\"80\":2}}],[\"++left\",{\"1\":{\"80\":2}}],[\"++tt\",{\"1\":{\"53\":1}}],[\"++i\",{\"1\":{\"42\":1,\"69\":2}}],[\"+\",{\"1\":{\"33\":1,\"38\":1,\"53\":1,\"65\":14,\"67\":2,\"69\":3,\"78\":3,\"80\":1,\"84\":3,\"88\":24,\"108\":5,\"112\":3,\"141\":2,\"206\":15,\"208\":1,\"209\":3,\"215\":2,\"217\":2,\"232\":1,\"233\":1,\"234\":2,\"267\":4,\"268\":2,\"269\":5,\"303\":4,\"307\":2}}],[\"标签为\",{\"1\":{\"31\":1}}],[\"标题会被视为页面标题\",{\"1\":{\"30\":1}}],[\"标题和页面信息\",{\"1\":{\"10\":1}}],[\"分钟或\",{\"1\":{\"303\":1}}],[\"分析如下\",{\"1\":{\"267\":1}}],[\"分隔开\",{\"1\":{\"73\":1}}],[\"分别出发\",{\"1\":{\"309\":1}}],[\"分别从\",{\"1\":{\"309\":1}}],[\"分别对应的实现类是哪个\",{\"1\":{\"303\":1}}],[\"分别指向待反转的范围\",{\"1\":{\"217\":1}}],[\"分别指向字符数组首元素\",{\"1\":{\"183\":1}}],[\"分别指向滑动窗口的开始位置和结束位置\",{\"1\":{\"139\":1}}],[\"分别在数组索引\",{\"1\":{\"67\":1}}],[\"分别定义为\",{\"1\":{\"59\":1}}],[\"分类为\",{\"1\":{\"31\":1}}],[\"分支\",{\"1\":{\"4\":1}}],[\"日\",{\"1\":{\"31\":1}}],[\"月\",{\"1\":{\"31\":1}}],[\"年\",{\"1\":{\"31\":1}}],[\"的任务\",{\"1\":{\"303\":1}}],[\"的底层实现是一个二叉堆\",{\"1\":{\"303\":1}}],[\"的实现模拟单端队列行为\",{\"1\":{\"303\":1}}],[\"的头节点\",{\"1\":{\"294\":1}}],[\"的线性的数据结构\",{\"1\":{\"274\":1}}],[\"的暴力解法降为\",{\"1\":{\"271\":1}}],[\"的操作发生\",{\"1\":{\"269\":1}}],[\"的下界\",{\"1\":{\"269\":1}}],[\"的下标就是答案\",{\"1\":{\"40\":1}}],[\"的下标与\",{\"1\":{\"40\":1}}],[\"的上界right\",{\"1\":{\"268\":1}}],[\"的集合\",{\"1\":{\"264\":1}}],[\"的算法解决本问题\",{\"1\":{\"249\":1}}],[\"的算法吗\",{\"1\":{\"38\":1}}],[\"的次数不超过\",{\"1\":{\"238\":1}}],[\"的时候\",{\"1\":{\"230\":1}}],[\"的时间\",{\"1\":{\"194\":1}}],[\"的每个元素都将在\",{\"1\":{\"228\":1}}],[\"的第一个还是第二个\",{\"1\":{\"225\":1}}],[\"的情况\",{\"1\":{\"217\":1,\"259\":1}}],[\"的范围\",{\"1\":{\"215\":1}}],[\"的数组存放\",{\"1\":{\"200\":1}}],[\"的数组来存储情况\",{\"1\":{\"53\":1}}],[\"的额外空间解决这一问题\",{\"1\":{\"181\":1}}],[\"的形式给出\",{\"1\":{\"181\":1}}],[\"的值都在target的右侧\",{\"1\":{\"268\":1}}],[\"的值\",{\"1\":{\"244\":1,\"268\":1}}],[\"的值排序\",{\"1\":{\"173\":1}}],[\"的值为\",{\"1\":{\"57\":1}}],[\"的大小并不重要\",{\"1\":{\"173\":1}}],[\"的其余元素和\",{\"1\":{\"173\":1}}],[\"的前驱节点为\",{\"1\":{\"294\":1}}],[\"的前\",{\"1\":{\"173\":2}}],[\"的元素有\",{\"1\":{\"268\":2}}],[\"的元素数量为\",{\"1\":{\"173\":1}}],[\"的元素\",{\"1\":{\"173\":2}}],[\"的字母异位词\",{\"1\":{\"165\":1}}],[\"的字符串\",{\"1\":{\"100\":1}}],[\"的队列\",{\"1\":{\"151\":1}}],[\"的栈\",{\"1\":{\"144\":1}}],[\"的节点之前\",{\"1\":{\"238\":1}}],[\"的节点插入到链表中下标为\",{\"1\":{\"238\":1}}],[\"的节点插入到链表中第一个元素之前\",{\"1\":{\"238\":1}}],[\"的节点追加到链表中作为链表的最后一个元素\",{\"1\":{\"238\":1}}],[\"的节点的值\",{\"1\":{\"238\":1}}],[\"的节点\",{\"1\":{\"116\":1,\"238\":1}}],[\"的位置正好是答案\",{\"1\":{\"230\":1}}],[\"的位置明显不是答案\",{\"1\":{\"230\":1}}],[\"的位置我们是可以取到的\",{\"1\":{\"230\":1}}],[\"的位置\",{\"1\":{\"112\":1,\"233\":1}}],[\"的副本并排序\",{\"1\":{\"88\":1}}],[\"的空间来存储字符串\",{\"1\":{\"80\":1}}],[\"的方法需要\",{\"1\":{\"80\":1}}],[\"的方式\",{\"1\":{\"67\":1}}],[\"的顺序\",{\"1\":{\"73\":1}}],[\"的所有满足\",{\"1\":{\"67\":1}}],[\"的步速大于\",{\"1\":{\"59\":1}}],[\"的链表节点\",{\"1\":{\"57\":2}}],[\"的那\",{\"1\":{\"38\":1}}],[\"的\",{\"1\":{\"30\":1,\"31\":1,\"67\":1,\"189\":1}}],[\"a+b\",{\"1\":{\"311\":3}}],[\"a+\",{\"1\":{\"309\":1}}],[\"a++\",{\"1\":{\"88\":1}}],[\"at\",{\"1\":{\"307\":2}}],[\"algo\",{\"1\":{\"258\":1}}],[\"all\",{\"1\":{\"45\":1}}],[\"about\",{\"0\":{\"314\":1}}],[\"abs\",{\"1\":{\"253\":6}}],[\"abcd\",{\"1\":{\"213\":1}}],[\"abcdefg\",{\"1\":{\"213\":1}}],[\"ab\",{\"1\":{\"198\":1}}],[\"abbaca\",{\"1\":{\"46\":2}}],[\"actuallength\",{\"1\":{\"173\":1}}],[\"action\",{\"1\":{\"4\":2}}],[\"actions\",{\"1\":{\"4\":2}}],[\"anagram\",{\"1\":{\"164\":1,\"165\":1}}],[\"and\",{\"1\":{\"154\":1,\"242\":1,\"303\":1}}],[\"ans++\",{\"1\":{\"177\":1}}],[\"ans\",{\"1\":{\"88\":3,\"141\":6,\"175\":4,\"177\":3,\"209\":3}}],[\"api\",{\"0\":{\"75\":1}}],[\"append\",{\"1\":{\"50\":1,\"78\":1,\"80\":2}}],[\"a\",{\"1\":{\"72\":1,\"73\":2,\"84\":4,\"88\":10,\"169\":2,\"181\":4,\"198\":1,\"202\":3,\"208\":1,\"209\":3,\"248\":1,\"307\":5,\"309\":4,\"311\":5}}],[\"addatindex\",{\"1\":{\"238\":4,\"242\":3,\"245\":3}}],[\"addattail\",{\"1\":{\"238\":4,\"242\":5,\"245\":4}}],[\"addathead\",{\"1\":{\"238\":4,\"242\":4,\"245\":4}}],[\"add\",{\"1\":{\"69\":1,\"88\":1,\"194\":1,\"303\":1}}],[\"adjacent\",{\"1\":{\"45\":1}}],[\"arraydeque\",{\"0\":{\"275\":1},\"1\":{\"274\":1,\"275\":1,\"276\":3,\"303\":1}}],[\"arraydeque<integer>\",{\"1\":{\"154\":2}}],[\"arraydeque<>\",{\"1\":{\"50\":1,\"104\":1,\"147\":2}}],[\"array\",{\"1\":{\"248\":1}}],[\"arraylist<integer>\",{\"1\":{\"69\":1}}],[\"arraylist<>\",{\"1\":{\"69\":1,\"88\":1,\"194\":1}}],[\"arrays\",{\"1\":{\"69\":2,\"76\":1,\"88\":2,\"188\":1}}],[\"aab\",{\"1\":{\"198\":1}}],[\"aa\",{\"1\":{\"46\":1,\"198\":2}}],[\"aaca\",{\"1\":{\"46\":1}}],[\"ascii\",{\"1\":{\"181\":1}}],[\"assert\",{\"1\":{\"173\":2}}],[\"aslist\",{\"1\":{\"69\":1,\"76\":1,\"88\":1}}],[\"as\",{\"1\":{\"30\":1,\"154\":1,\"242\":1}}],[\"h\",{\"1\":{\"181\":6}}],[\"hash\",{\"1\":{\"258\":1}}],[\"hashmap<integer\",{\"1\":{\"209\":1}}],[\"hashmap<>\",{\"1\":{\"42\":1}}],[\"hash2\",{\"1\":{\"194\":3}}],[\"hash1\",{\"1\":{\"194\":3}}],[\"happy\",{\"1\":{\"107\":1}}],[\"heaparray\",{\"1\":{\"303\":8}}],[\"heap\",{\"1\":{\"303\":10}}],[\"headb\",{\"1\":{\"307\":1,\"309\":5,\"311\":4}}],[\"heada\",{\"1\":{\"307\":1,\"309\":5,\"311\":4}}],[\"head\",{\"1\":{\"57\":4,\"61\":6,\"92\":3,\"96\":4,\"116\":4,\"117\":2,\"119\":9,\"122\":1,\"126\":4,\"130\":2,\"131\":2,\"133\":8,\"158\":3,\"162\":5,\"242\":18,\"243\":1,\"245\":9}}],[\"hello\",{\"1\":{\"73\":2,\"258\":1}}],[\"hh\",{\"1\":{\"51\":1,\"53\":2}}],[\"https\",{\"1\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"hope\",{\"1\":{\"31\":1}}],[\"h1\",{\"1\":{\"30\":2}}],[\"h2o\",{\"1\":{\"25\":1}}],[\"注释之前的内容被视为文章摘要\",{\"1\":{\"29\":1}}],[\"注意这五个元素可以任意顺序返回\",{\"1\":{\"173\":1}}],[\"注意\",{\"1\":{\"4\":1,\"57\":1,\"65\":2,\"73\":1,\"144\":1,\"165\":1,\"230\":1,\"267\":3,\"268\":3,\"269\":1,\"307\":3}}],[\"上的\",{\"1\":{\"264\":1}}],[\"上边界缩减\",{\"1\":{\"223\":1}}],[\"上反复执行重复项删除操作\",{\"1\":{\"46\":1}}],[\"上下角标\",{\"0\":{\"25\":1}}],[\"上一篇\",{\"1\":{\"7\":1}}],[\"支持为图片设置颜色模式和大小\",{\"1\":{\"24\":1}}],[\"2k\",{\"1\":{\"213\":3,\"215\":1}}],[\"28\",{\"1\":{\"206\":2}}],[\"27\",{\"0\":{\"171\":1,\"172\":1}}],[\"26\",{\"1\":{\"169\":3,\"200\":1,\"201\":1,\"202\":2}}],[\"242\",{\"0\":{\"163\":1,\"164\":1},\"1\":{\"201\":1}}],[\"24\",{\"0\":{\"156\":1,\"157\":1}}],[\"243\",{\"1\":{\"112\":1}}],[\"232\",{\"0\":{\"149\":1,\"150\":1}}],[\"231\",{\"1\":{\"108\":1}}],[\"2⋅logn\",{\"1\":{\"112\":1}}],[\"225\",{\"0\":{\"142\":1,\"143\":1}}],[\"22\",{\"1\":{\"108\":1}}],[\"2n+1\",{\"1\":{\"147\":1}}],[\"2n\",{\"1\":{\"61\":1}}],[\"2\",{\"0\":{\"51\":1,\"77\":1,\"268\":1},\"1\":{\"23\":1,\"38\":6,\"57\":3,\"59\":1,\"65\":7,\"73\":1,\"84\":16,\"88\":5,\"92\":5,\"96\":2,\"100\":1,\"104\":2,\"108\":2,\"110\":1,\"116\":3,\"126\":5,\"130\":3,\"137\":4,\"144\":6,\"151\":4,\"154\":1,\"158\":3,\"165\":1,\"173\":12,\"181\":1,\"185\":1,\"189\":6,\"198\":1,\"206\":12,\"213\":3,\"215\":1,\"217\":1,\"221\":3,\"228\":3,\"232\":1,\"233\":1,\"234\":2,\"238\":5,\"245\":1,\"249\":2,\"267\":1,\"268\":2,\"269\":1,\"303\":8,\"307\":13}}],[\"209\",{\"0\":{\"135\":1,\"136\":1}}],[\"206\",{\"0\":{\"124\":1,\"125\":1},\"1\":{\"280\":1}}],[\"203\",{\"0\":{\"114\":1,\"115\":1},\"1\":{\"279\":1}}],[\"2000\",{\"1\":{\"238\":1}}],[\"20000\",{\"1\":{\"46\":1}}],[\"200\",{\"1\":{\"84\":1,\"206\":1}}],[\"202\",{\"0\":{\"106\":1,\"107\":1}}],[\"2020\",{\"1\":{\"31\":1}}],[\"2024\",{\"1\":{\"4\":3}}],[\"20\",{\"0\":{\"98\":1,\"99\":1},\"1\":{\"4\":1,\"221\":1}}],[\"ransomnote\",{\"1\":{\"198\":8,\"200\":3,\"202\":3}}],[\"ransom\",{\"1\":{\"197\":1}}],[\"rat\",{\"1\":{\"165\":1}}],[\"r\",{\"1\":{\"88\":11,\"183\":4,\"215\":1,\"216\":2,\"217\":10}}],[\"rightchildindex\",{\"1\":{\"303\":5}}],[\"right+1\",{\"1\":{\"267\":1}}],[\"right时\",{\"1\":{\"253\":1}}],[\"right=mid−1\",{\"1\":{\"230\":1}}],[\"right=mid\",{\"1\":{\"230\":1}}],[\"right\",{\"1\":{\"80\":10,\"141\":1,\"185\":5,\"215\":2,\"223\":1,\"225\":7,\"230\":2,\"232\":4,\"233\":4,\"234\":4,\"253\":12,\"267\":17,\"268\":12,\"269\":5}}],[\"ret\",{\"1\":{\"242\":3,\"253\":6}}],[\"return\",{\"1\":{\"42\":2,\"50\":2,\"53\":2,\"61\":3,\"69\":2,\"76\":1,\"78\":1,\"80\":2,\"88\":1,\"96\":2,\"104\":4,\"112\":3,\"119\":2,\"122\":1,\"130\":1,\"133\":2,\"141\":2,\"147\":3,\"151\":3,\"154\":3,\"162\":2,\"169\":3,\"177\":1,\"194\":1,\"202\":3,\"209\":1,\"217\":1,\"225\":1,\"232\":2,\"233\":2,\"234\":2,\"242\":6,\"245\":5,\"253\":1,\"267\":3,\"268\":6,\"269\":2,\"296\":1,\"297\":3,\"303\":1,\"311\":2}}],[\"reversestr\",{\"1\":{\"217\":1}}],[\"reversestring\",{\"1\":{\"185\":1}}],[\"reverselist\",{\"1\":{\"130\":1,\"133\":2}}],[\"reverseeachword\",{\"1\":{\"79\":1,\"80\":2}}],[\"reversewords\",{\"1\":{\"76\":1,\"78\":1,\"80\":1}}],[\"reverse\",{\"1\":{\"72\":1,\"75\":1,\"76\":1,\"79\":1,\"80\":3,\"125\":1,\"180\":1,\"212\":1,\"217\":2}}],[\"restored\",{\"1\":{\"303\":1}}],[\"reslist\",{\"1\":{\"194\":4}}],[\"res\",{\"1\":{\"69\":4,\"78\":3,\"194\":3,\"225\":6}}],[\"removeelement\",{\"1\":{\"173\":1,\"177\":1}}],[\"removeelements\",{\"1\":{\"119\":1,\"122\":1}}],[\"removenthfromend\",{\"1\":{\"96\":1}}],[\"removeduplicates\",{\"1\":{\"50\":1,\"53\":1}}],[\"remove\",{\"1\":{\"45\":1,\"91\":1,\"115\":1,\"172\":1,\"297\":1,\"303\":1}}],[\"regarded\",{\"1\":{\"30\":1}}],[\"r−i​\",{\"1\":{\"22\":1}}],[\"r−i+1\",{\"1\":{\"22\":1}}],[\"r+i=1∑r​ωi\",{\"1\":{\"22\":1}}],[\"run\",{\"1\":{\"4\":3}}],[\"runs\",{\"1\":{\"4\":1}}],[\"=num\",{\"1\":{\"175\":1}}],[\"=null\",{\"1\":{\"117\":1,\"122\":1}}],[\"=val\",{\"1\":{\"117\":1}}],[\"=o\",{\"1\":{\"88\":1,\"112\":1}}],[\"=>\",{\"1\":{\"59\":1,\"267\":1}}],[\"==target\",{\"1\":{\"230\":1,\"233\":1}}],[\"==\",{\"1\":{\"38\":1,\"50\":2,\"51\":1,\"53\":3,\"61\":5,\"65\":1,\"67\":2,\"69\":7,\"78\":1,\"80\":2,\"84\":1,\"88\":5,\"96\":2,\"104\":4,\"112\":2,\"116\":1,\"119\":3,\"133\":2,\"141\":2,\"162\":2,\"173\":2,\"183\":1,\"206\":5,\"233\":1,\"234\":1,\"242\":4,\"245\":4,\"253\":2,\"267\":6,\"268\":8,\"269\":3,\"294\":1,\"295\":1,\"296\":2,\"297\":2,\"307\":2,\"309\":1,\"311\":4}}],[\"=\",{\"1\":{\"22\":1,\"38\":6,\"42\":4,\"50\":3,\"53\":4,\"57\":6,\"59\":2,\"61\":10,\"65\":12,\"67\":1,\"69\":8,\"73\":3,\"76\":2,\"78\":6,\"80\":13,\"84\":4,\"88\":9,\"92\":6,\"96\":12,\"100\":3,\"104\":2,\"108\":6,\"112\":11,\"116\":6,\"119\":9,\"122\":3,\"126\":3,\"130\":12,\"133\":3,\"137\":6,\"141\":8,\"144\":1,\"147\":2,\"151\":1,\"154\":6,\"158\":3,\"160\":4,\"162\":14,\"165\":4,\"169\":5,\"173\":13,\"177\":3,\"181\":2,\"185\":5,\"189\":4,\"194\":7,\"198\":6,\"202\":1,\"206\":12,\"209\":2,\"213\":4,\"215\":2,\"217\":9,\"221\":2,\"223\":1,\"225\":15,\"228\":4,\"232\":5,\"233\":5,\"234\":5,\"238\":1,\"242\":27,\"245\":32,\"249\":2,\"252\":1,\"253\":8,\"258\":1,\"267\":9,\"268\":11,\"269\":11,\"292\":1,\"294\":5,\"295\":5,\"296\":10,\"297\":6,\"303\":13,\"307\":15,\"309\":1,\"311\":7}}],[\"ωyω​\",{\"1\":{\"22\":2}}],[\"∂ωr∂r​\",{\"1\":{\"22\":1}}],[\"导入文件\",{\"0\":{\"21\":1}}],[\"导航栏\",{\"1\":{\"7\":1,\"10\":1}}],[\"脚注\",{\"0\":{\"20\":1}}],[\"对象当成链表中的节点\",{\"1\":{\"240\":1}}],[\"对象\",{\"1\":{\"238\":1,\"292\":1}}],[\"对应的值累加起来\",{\"1\":{\"208\":1}}],[\"对于变量的边界怎么定义\",{\"1\":{\"225\":1}}],[\"对于有\",{\"1\":{\"154\":1}}],[\"对于一个四位数来说\",{\"1\":{\"112\":1}}],[\"对于一个三位数来说\",{\"1\":{\"112\":1}}],[\"对于一个正整数\",{\"1\":{\"108\":1}}],[\"对于每个\",{\"1\":{\"40\":1}}],[\"对于\",{\"1\":{\"32\":1}}],[\"对\",{\"1\":{\"17\":1,\"110\":1}}],[\"为什么要初始化2的n次幂个长度\",{\"1\":{\"276\":1}}],[\"为什么不是用\",{\"1\":{\"276\":1}}],[\"为\",{\"1\":{\"242\":1,\"244\":1,\"245\":1,\"294\":1,\"307\":7,\"311\":2}}],[\"为奇数时\",{\"1\":{\"223\":1}}],[\"为nums1数组长度\",{\"1\":{\"194\":1}}],[\"为均摊\",{\"1\":{\"154\":1}}],[\"为操作数\",{\"1\":{\"154\":1}}],[\"为栈内元素个数\",{\"1\":{\"147\":1}}],[\"为起点的链表进行反转\",{\"1\":{\"131\":1}}],[\"为链表长度\",{\"1\":{\"130\":1,\"133\":1,\"162\":1,\"242\":1,\"245\":1}}],[\"为输入字符串的长度\",{\"1\":{\"80\":1}}],[\"为走过的环的圈数\",{\"1\":{\"59\":1}}],[\"为了支持优先级的比较\",{\"1\":{\"303\":1}}],[\"为了避免枚举到重复四元组\",{\"1\":{\"86\":1}}],[\"为了更有效的找到有效解\",{\"1\":{\"68\":1}}],[\"为了\",{\"1\":{\"67\":1,\"68\":1}}],[\"为了表示给定链表中的环\",{\"1\":{\"57\":1}}],[\"为了丰富文档写作\",{\"1\":{\"17\":1}}],[\"为字符串长度\",{\"1\":{\"50\":1,\"53\":1,\"76\":1,\"78\":1,\"104\":1,\"202\":1,\"217\":1}}],[\"为数组长度\",{\"1\":{\"42\":1,\"69\":1,\"88\":1,\"96\":1,\"119\":1,\"122\":1,\"141\":1,\"169\":1,\"177\":1,\"185\":1,\"209\":1,\"225\":1,\"232\":1,\"253\":1}}],[\"为每个\",{\"1\":{\"15\":1}}],[\"扩展\",{\"0\":{\"16\":1,\"17\":1},\"1\":{\"17\":1}}],[\"了解详情\",{\"1\":{\"15\":1}}],[\"请不要使用内置的\",{\"1\":{\"238\":1}}],[\"请尝试设计一个\",{\"1\":{\"137\":1}}],[\"请尝试使用\",{\"1\":{\"73\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"307\":1}}],[\"请你找出并返回满足下述全部条件且不重复的四元组\",{\"1\":{\"84\":1}}],[\"请你\",{\"1\":{\"249\":1}}],[\"请你计算有多少个元组\",{\"1\":{\"206\":1}}],[\"请你仅使用两个栈实现先入先出队列\",{\"1\":{\"151\":1}}],[\"请你仅使用两个队列实现一个后入先出\",{\"1\":{\"144\":1}}],[\"请你反转链表\",{\"1\":{\"126\":1}}],[\"请你反转字符串中\",{\"1\":{\"73\":1}}],[\"请你删除链表中所有满足\",{\"1\":{\"116\":1}}],[\"请你在该数组中找出\",{\"1\":{\"38\":1}}],[\"请\",{\"1\":{\"65\":1}}],[\"请使用绝对链接\",{\"1\":{\"32\":1}}],[\"请阅读\",{\"1\":{\"15\":1,\"17\":1}}],[\"请先阅读\",{\"1\":{\"14\":1}}],[\"中节点数目为\",{\"1\":{\"307\":2}}],[\"中继续搜索\",{\"1\":{\"268\":1}}],[\"中因此返回\",{\"1\":{\"228\":1}}],[\"中并且下标为\",{\"1\":{\"228\":1}}],[\"中心数字无法在迭代过程中被填充\",{\"1\":{\"223\":1}}],[\"中不等于\",{\"1\":{\"173\":1}}],[\"中与\",{\"1\":{\"173\":1}}],[\"中每个字符出现的次数都相同\",{\"1\":{\"165\":1}}],[\"中进行\",{\"1\":{\"153\":1}}],[\"中可能会存在前导空格\",{\"1\":{\"73\":1}}],[\"中\",{\"1\":{\"46\":1,\"73\":1,\"274\":1,\"299\":1,\"302\":2,\"307\":4}}],[\"中使用一次\",{\"1\":{\"198\":1}}],[\"中使用至少一个空格将字符串中的\",{\"1\":{\"73\":1}}],[\"中使用\",{\"1\":{\"33\":1}}],[\"中设置页面信息\",{\"1\":{\"31\":1}}],[\"中设置页面标题\",{\"1\":{\"30\":1}}],[\"中的所有元素是不重复的\",{\"1\":{\"228\":1}}],[\"中的每个字符只能在\",{\"1\":{\"198\":1}}],[\"中的前五个元素为\",{\"1\":{\"173\":1}}],[\"中的前两个元素均为\",{\"1\":{\"173\":1}}],[\"中的元素依次出栈压入\",{\"1\":{\"147\":2}}],[\"中的元素总长度\",{\"1\":{\"76\":1}}],[\"中的字符串总长度\",{\"1\":{\"78\":1}}],[\"中的第一个\",{\"1\":{\"30\":1}}],[\"中的\",{\"1\":{\"17\":1,\"228\":1}}],[\"中很重要的一个概念\",{\"1\":{\"15\":1}}],[\"中自定义它们\",{\"1\":{\"10\":1}}],[\"是一种特殊类型的优先队列\",{\"1\":{\"303\":1}}],[\"是一种特殊类型的抽象数据类型或集合\",{\"1\":{\"302\":1}}],[\"是一种允许在其两端进行插入和删除的线性数据结构\",{\"1\":{\"303\":1}}],[\"是双端队列接口\",{\"1\":{\"302\":1}}],[\"是单端队列接口\",{\"1\":{\"302\":1}}],[\"是基于什么实现的\",{\"1\":{\"276\":1}}],[\"是指向下一个节点的指针\",{\"1\":{\"238\":1}}],[\"是当前节点的值\",{\"1\":{\"238\":1}}],[\"是可以合并起来的\",{\"1\":{\"233\":1}}],[\"是为了解决当\",{\"1\":{\"223\":1}}],[\"是和\",{\"1\":{\"208\":1}}],[\"是否是\",{\"1\":{\"165\":1}}],[\"是否存在于哈希表中\",{\"1\":{\"40\":1}}],[\"是栈内的元素个数\",{\"1\":{\"147\":1}}],[\"是该条件下的长度最小的子数组\",{\"1\":{\"137\":1}}],[\"是快乐数\",{\"1\":{\"110\":1}}],[\"是不是快乐数\",{\"1\":{\"108\":1}}],[\"是由非空格字符组成的字符串\",{\"1\":{\"73\":1}}],[\"是\",{\"1\":{\"15\":1,\"41\":1,\"57\":1,\"108\":1,\"268\":1,\"269\":1}}],[\"配置\",{\"0\":{\"15\":1}}],[\"演示\",{\"1\":{\"14\":1}}],[\"和一个\",{\"1\":{\"243\":1}}],[\"和一个值\",{\"1\":{\"173\":1}}],[\"和一个整数\",{\"1\":{\"116\":1,\"213\":1}}],[\"和一个整数目标值\",{\"1\":{\"38\":1}}],[\"和一个目标值\",{\"1\":{\"84\":1,\"228\":1}}],[\"和为目标值\",{\"1\":{\"38\":1}}],[\"和\",{\"1\":{\"14\":1,\"31\":1,\"41\":1,\"59\":2,\"61\":1,\"65\":1,\"67\":1,\"80\":1,\"84\":1,\"94\":1,\"110\":1,\"139\":1,\"144\":4,\"151\":2,\"154\":2,\"160\":2,\"165\":4,\"183\":1,\"189\":1,\"198\":2,\"206\":1,\"208\":1,\"209\":1,\"215\":2,\"217\":2,\"233\":1,\"238\":2,\"242\":1,\"243\":1,\"245\":1,\"251\":1,\"274\":1,\"281\":1,\"303\":1,\"307\":4,\"311\":1}}],[\"你必须\",{\"1\":{\"181\":1}}],[\"你必须在不修改节点内部的值的情况下完成本题\",{\"1\":{\"158\":1}}],[\"你在返回的\",{\"1\":{\"173\":2}}],[\"你的函数应该返回\",{\"1\":{\"173\":1}}],[\"你的函数函数应该返回\",{\"1\":{\"173\":1}}],[\"你的解决方案将会\",{\"1\":{\"173\":1}}],[\"你需要\",{\"1\":{\"173\":1}}],[\"你需要创建并编写\",{\"1\":{\"13\":1}}],[\"你所使用的语言也许不支持栈\",{\"1\":{\"151\":1}}],[\"你所使用的语言也许不支持队列\",{\"1\":{\"144\":1}}],[\"你\",{\"1\":{\"151\":1}}],[\"你只能使用队列的标准操作\",{\"1\":{\"144\":1}}],[\"你能否设计一个时间复杂度\",{\"1\":{\"307\":1}}],[\"你能否调整你的解法来应对这种情况\",{\"1\":{\"165\":1}}],[\"你能否实现每个操作均摊时间复杂度为\",{\"1\":{\"151\":1}}],[\"你能否仅用一个队列来实现栈\",{\"1\":{\"144\":1}}],[\"你能否用两种方法解决这道题\",{\"1\":{\"126\":1}}],[\"你能尝试使用一趟扫描实现吗\",{\"1\":{\"92\":1}}],[\"你返回所有和为\",{\"1\":{\"65\":1}}],[\"你是否可以使用\",{\"1\":{\"57\":1}}],[\"你也可以创建并引入你自己的组件\",{\"1\":{\"33\":1}}],[\"你可以选择使用单链表或者双链表\",{\"1\":{\"238\":1}}],[\"你可以假设\",{\"1\":{\"228\":1}}],[\"你可以假设每种输入只会对应一个答案\",{\"1\":{\"38\":1}}],[\"你可以使用\",{\"1\":{\"144\":1,\"151\":1}}],[\"你可以使用它轻松生成文档或博客站点\",{\"1\":{\"13\":1}}],[\"你可以按\",{\"1\":{\"84\":1}}],[\"你可以按任意顺序返回答案\",{\"1\":{\"38\":1}}],[\"你可以想出一个时间复杂度小于\",{\"1\":{\"38\":1}}],[\"你可以将图片和\",{\"1\":{\"32\":1}}],[\"你可以自由在这里书写你的\",{\"1\":{\"32\":1}}],[\"你可以在\",{\"1\":{\"30\":1,\"31\":1}}],[\"你可以在主题选项和页面的\",{\"1\":{\"10\":1}}],[\"你可以通过设置页面的\",{\"1\":{\"7\":1}}],[\"展示\",{\"0\":{\"13\":1}}],[\"打印按钮\",{\"1\":{\"10\":1}}],[\"夜间模式按钮\",{\"1\":{\"10\":1}}],[\"主操作不变\",{\"1\":{\"112\":1}}],[\"主题扩展了更多\",{\"1\":{\"18\":1}}],[\"主题扩展\",{\"0\":{\"18\":1}}],[\"主题也带有以下元素\",{\"1\":{\"10\":1}}],[\"主要通过实现\",{\"1\":{\"303\":1}}],[\"主要从\",{\"1\":{\"13\":1}}],[\"主要功能与配置演示\",{\"0\":{\"5\":1}}],[\"文章标题列表\",{\"1\":{\"10\":1}}],[\"文件夹的图片\",{\"1\":{\"32\":1}}],[\"文件放置在一起使用相对路径进行引用\",{\"1\":{\"32\":1}}],[\"文件生成页面\",{\"1\":{\"13\":1}}],[\"文件\",{\"1\":{\"4\":1}}],[\"布局包括\",{\"1\":{\"10\":1}}],[\"布局\",{\"0\":{\"10\":1},\"2\":{\"12\":1}}],[\"布局与功能禁用\",{\"0\":{\"7\":1}}],[\"禁用\",{\"2\":{\"9\":1}}],[\"禁用了如下功能\",{\"1\":{\"7\":1}}],[\"页面都会被转换为一个\",{\"1\":{\"33\":1}}],[\"页面内容\",{\"0\":{\"32\":1}}],[\"页面标题\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"页面配置\",{\"0\":{\"29\":1},\"1\":{\"31\":1},\"2\":{\"35\":1}}],[\"页面引入配置\",{\"1\":{\"15\":1}}],[\"页面信息\",{\"0\":{\"31\":1},\"1\":{\"7\":1}}],[\"页脚\",{\"1\":{\"7\":1,\"10\":1}}],[\"贡献者\",{\"1\":{\"7\":1,\"10\":1}}],[\"路径导航\",{\"1\":{\"7\":1,\"10\":1}}],[\"侧边栏\",{\"1\":{\"7\":1,\"10\":1}}],[\">target\",{\"1\":{\"230\":1}}],[\">2\",{\"1\":{\"130\":1}}],[\">=\",{\"1\":{\"78\":3,\"141\":1,\"225\":2,\"242\":2,\"303\":1}}],[\">\",{\"1\":{\"4\":1,\"67\":3,\"69\":6,\"88\":5,\"112\":1,\"147\":2,\"194\":2,\"202\":1,\"206\":2,\"217\":1,\"232\":1,\"233\":1,\"238\":3,\"242\":1,\"245\":1,\"253\":1,\"267\":3,\"268\":2,\"269\":1,\"303\":3,\"309\":1}}],[\"b+a\",{\"1\":{\"311\":1}}],[\"b+\",{\"1\":{\"309\":1}}],[\"b++\",{\"1\":{\"88\":1}}],[\"bugstack\",{\"1\":{\"294\":1,\"295\":1,\"296\":1,\"297\":1}}],[\"build\",{\"1\":{\"4\":1}}],[\"binarysearch\",{\"1\":{\"267\":1}}],[\"binary\",{\"1\":{\"227\":1}}],[\"bound\",{\"1\":{\"268\":1}}],[\"bootom\",{\"1\":{\"225\":1}}],[\"boolean\",{\"1\":{\"104\":1,\"112\":1,\"144\":1,\"147\":1,\"151\":1,\"154\":2,\"169\":1,\"202\":1,\"245\":1,\"297\":1}}],[\"bottom\",{\"1\":{\"223\":1,\"225\":5}}],[\"bacd\",{\"1\":{\"213\":1}}],[\"bacdfeg\",{\"1\":{\"213\":1}}],[\"back\",{\"1\":{\"144\":1}}],[\"b\",{\"1\":{\"84\":4,\"88\":8,\"198\":1,\"208\":1,\"209\":3,\"307\":5,\"309\":4,\"311\":5}}],[\"blue\",{\"1\":{\"73\":2}}],[\"break\",{\"1\":{\"61\":1,\"69\":1,\"88\":2,\"303\":1}}],[\"branch\",{\"1\":{\"4\":1}}],[\"branches\",{\"1\":{\"4\":1}}],[\"bb\",{\"1\":{\"46\":1}}],[\"be\",{\"1\":{\"30\":1,\"154\":1,\"242\":1}}],[\"overflow\",{\"1\":{\"267\":1}}],[\"obj\",{\"1\":{\"154\":5,\"242\":6}}],[\"object\",{\"1\":{\"154\":1,\"242\":1,\"297\":1}}],[\"out\",{\"1\":{\"153\":1,\"154\":8}}],[\"of\",{\"1\":{\"91\":1,\"151\":1,\"188\":1,\"248\":1,\"306\":1}}],[\"offer\",{\"1\":{\"50\":1,\"104\":3,\"147\":3}}],[\"o\",{\"1\":{\"38\":1,\"42\":2,\"50\":2,\"53\":2,\"57\":1,\"61\":2,\"67\":2,\"69\":4,\"73\":1,\"76\":3,\"78\":3,\"80\":2,\"88\":6,\"96\":2,\"104\":2,\"112\":4,\"119\":2,\"122\":2,\"130\":2,\"133\":2,\"137\":1,\"141\":2,\"147\":5,\"151\":2,\"154\":5,\"162\":2,\"169\":2,\"175\":1,\"177\":2,\"181\":3,\"185\":3,\"194\":3,\"202\":2,\"209\":3,\"217\":2,\"225\":2,\"232\":2,\"242\":6,\"245\":7,\"249\":1,\"253\":2,\"257\":9,\"265\":2,\"271\":2,\"297\":3,\"298\":1,\"307\":2,\"311\":2}}],[\"old\",{\"1\":{\"4\":1}}],[\"options\",{\"1\":{\"4\":1}}],[\"on\",{\"1\":{\"4\":2}}],[\"lcci\",{\"1\":{\"306\":1}}],[\"l<r∣∣t<b\",{\"1\":{\"223\":1}}],[\"largerchildindex\",{\"1\":{\"303\":5}}],[\"last\",{\"1\":{\"133\":2,\"294\":1,\"295\":2,\"296\":1}}],[\"latest\",{\"1\":{\"4\":1}}],[\"l++\",{\"1\":{\"88\":3,\"217\":1}}],[\"l\",{\"1\":{\"88\":8,\"181\":4,\"183\":4,\"206\":3,\"215\":3,\"217\":14,\"233\":2,\"295\":4}}],[\"linklast\",{\"1\":{\"295\":1}}],[\"linkfirst\",{\"1\":{\"294\":1}}],[\"linkedlist\",{\"1\":{\"238\":1,\"299\":1,\"303\":2}}],[\"linked\",{\"1\":{\"56\":1,\"61\":1,\"96\":1,\"115\":1,\"119\":1,\"122\":1,\"125\":1,\"130\":1,\"162\":1,\"237\":1,\"306\":1,\"311\":1}}],[\"lifo\",{\"1\":{\"144\":1,\"274\":1,\"275\":1}}],[\"listb\",{\"1\":{\"307\":7,\"309\":3,\"311\":1}}],[\"lista\",{\"1\":{\"307\":7,\"309\":3,\"311\":1}}],[\"lists\",{\"1\":{\"306\":1}}],[\"list<integer>\",{\"1\":{\"194\":1}}],[\"list<string>\",{\"1\":{\"76\":1}}],[\"list<list<integer>>\",{\"1\":{\"69\":2,\"88\":2}}],[\"listnode\",{\"1\":{\"61\":6,\"96\":12,\"119\":9,\"122\":11,\"130\":11,\"133\":3,\"162\":13,\"292\":3,\"311\":8}}],[\"list\",{\"1\":{\"56\":1,\"61\":1,\"76\":1,\"91\":1,\"96\":1,\"115\":1,\"119\":1,\"122\":1,\"125\":1,\"130\":1,\"144\":1,\"151\":1,\"162\":1,\"237\":1,\"311\":1}}],[\"leftchildindex\",{\"1\":{\"303\":5}}],[\"left=mid+1\",{\"1\":{\"230\":1}}],[\"leftmost\",{\"1\":{\"151\":1}}],[\"left++\",{\"1\":{\"80\":1,\"185\":1,\"225\":1,\"253\":1}}],[\"left\",{\"1\":{\"80\":9,\"141\":1,\"185\":4,\"215\":2,\"223\":1,\"225\":6,\"230\":2,\"232\":4,\"233\":4,\"234\":4,\"253\":9,\"267\":19,\"268\":26,\"269\":16}}],[\"length\",{\"1\":{\"38\":1,\"42\":1,\"46\":1,\"50\":1,\"53\":2,\"65\":1,\"67\":1,\"69\":3,\"73\":1,\"78\":1,\"80\":4,\"84\":1,\"88\":1,\"100\":1,\"104\":1,\"137\":1,\"141\":1,\"165\":2,\"169\":3,\"173\":2,\"181\":1,\"185\":1,\"189\":2,\"198\":2,\"202\":2,\"206\":4,\"213\":1,\"217\":1,\"232\":1,\"233\":1,\"234\":1,\"249\":1,\"253\":2,\"267\":2,\"268\":6,\"269\":1}}],[\"leetcode\",{\"0\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"255\":1,\"306\":1},\"1\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"log\",{\"1\":{\"137\":1}}],[\"logn\",{\"1\":{\"112\":2,\"232\":1}}],[\"logy\",{\"1\":{\"22\":2}}],[\"long\",{\"1\":{\"88\":3}}],[\"lockfile\",{\"1\":{\"4\":1}}],[\"f\",{\"1\":{\"294\":4}}],[\"fifo\",{\"1\":{\"303\":1}}],[\"final\",{\"1\":{\"294\":2,\"295\":2,\"296\":3}}],[\"first=cur\",{\"1\":{\"160\":1}}],[\"firstindex\",{\"1\":{\"42\":2}}],[\"first\",{\"1\":{\"30\":1,\"42\":2,\"94\":4,\"96\":8,\"160\":4,\"162\":4,\"294\":2,\"295\":1,\"296\":1,\"297\":2,\"311\":6}}],[\"false\",{\"1\":{\"100\":1,\"104\":2,\"108\":2,\"144\":3,\"151\":3,\"165\":1,\"169\":2,\"198\":3,\"202\":2,\"297\":1}}],[\"fastrunner\",{\"1\":{\"112\":8}}],[\"fast在链表前进\",{\"1\":{\"110\":1}}],[\"fast\",{\"1\":{\"59\":8,\"61\":12,\"110\":2,\"112\":1}}],[\"found\",{\"1\":{\"313\":1}}],[\"foursumcount\",{\"1\":{\"209\":1}}],[\"foursum\",{\"1\":{\"88\":1}}],[\"for循环中变量定义成i或j的细节\",{\"1\":{\"225\":1}}],[\"for\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"88\":2,\"96\":2,\"104\":1,\"119\":1,\"122\":1,\"130\":1,\"162\":1,\"169\":2,\"173\":1,\"177\":1,\"194\":4,\"202\":2,\"209\":4,\"217\":1,\"225\":4,\"242\":1,\"245\":1,\"270\":2,\"297\":2,\"311\":1}}],[\"folder\",{\"1\":{\"4\":1}}],[\"front\",{\"1\":{\"144\":1,\"151\":1}}],[\"frontmatter\",{\"1\":{\"7\":1,\"10\":1,\"15\":4,\"30\":1,\"31\":1}}],[\"from\",{\"1\":{\"91\":1,\"144\":1,\"151\":1}}],[\"frozen\",{\"1\":{\"4\":1}}],[\"fetch\",{\"1\":{\"4\":1}}],[\"illegalstateexception\",{\"1\":{\"303\":1}}],[\"i代表行\",{\"1\":{\"225\":1}}],[\"implement\",{\"1\":{\"143\":1,\"150\":1}}],[\"i++\",{\"1\":{\"96\":1,\"169\":2,\"173\":1,\"194\":1,\"225\":1,\"242\":1}}],[\"ii\",{\"0\":{\"55\":1,\"56\":1,\"204\":1,\"205\":1,\"211\":1,\"212\":1,\"219\":1,\"220\":1},\"1\":{\"56\":1,\"205\":1,\"212\":1,\"220\":1,\"284\":1}}],[\"if\",{\"1\":{\"42\":1,\"50\":2,\"53\":2,\"61\":3,\"69\":6,\"80\":2,\"88\":8,\"96\":1,\"104\":6,\"112\":1,\"119\":2,\"122\":1,\"133\":1,\"141\":1,\"154\":2,\"162\":1,\"169\":2,\"177\":1,\"194\":1,\"202\":2,\"209\":1,\"232\":2,\"233\":2,\"234\":2,\"242\":6,\"245\":6,\"253\":3,\"267\":3,\"268\":6,\"269\":4,\"294\":1,\"295\":1,\"296\":2,\"297\":3,\"303\":3,\"311\":1}}],[\"i\",{\"1\":{\"33\":1,\"38\":1,\"42\":7,\"65\":5,\"67\":8,\"69\":10,\"77\":1,\"78\":10,\"84\":1,\"96\":2,\"137\":1,\"169\":7,\"173\":5,\"181\":1,\"184\":2,\"189\":2,\"194\":11,\"206\":7,\"225\":7,\"242\":2,\"249\":1}}],[\"insert\",{\"1\":{\"303\":1}}],[\"instantiated\",{\"1\":{\"154\":1,\"242\":1}}],[\"install\",{\"1\":{\"4\":1}}],[\"indexprenode\",{\"1\":{\"242\":3}}],[\"indexnode\",{\"1\":{\"242\":3}}],[\"index++\",{\"1\":{\"194\":1}}],[\"index\",{\"1\":{\"194\":1,\"238\":9,\"242\":17,\"244\":2,\"245\":16,\"253\":5,\"258\":1,\"282\":3}}],[\"in2out\",{\"1\":{\"154\":3}}],[\"intersected\",{\"1\":{\"307\":2}}],[\"intersectval\",{\"1\":{\"307\":6}}],[\"intersection\",{\"1\":{\"188\":1,\"194\":1,\"306\":1}}],[\"integer\",{\"1\":{\"141\":2}}],[\"integer>\",{\"1\":{\"42\":1,\"209\":2}}],[\"int\",{\"1\":{\"42\":8,\"53\":1,\"61\":2,\"69\":4,\"78\":1,\"80\":5,\"88\":8,\"96\":5,\"112\":7,\"119\":4,\"122\":4,\"130\":3,\"141\":7,\"144\":3,\"147\":3,\"151\":3,\"154\":5,\"162\":3,\"169\":4,\"173\":5,\"177\":5,\"185\":2,\"194\":14,\"202\":2,\"209\":10,\"217\":6,\"225\":10,\"232\":6,\"233\":6,\"234\":6,\"238\":7,\"242\":13,\"245\":11,\"253\":7,\"267\":6,\"268\":6,\"269\":6,\"292\":2,\"303\":9,\"311\":2}}],[\"in\",{\"1\":{\"30\":1,\"45\":1,\"72\":1,\"153\":1,\"154\":6,\"157\":1}}],[\"ir⋯\",{\"1\":{\"22\":1}}],[\"item\",{\"1\":{\"296\":2,\"297\":2}}],[\"it\",{\"1\":{\"16\":2}}],[\"isleft\",{\"1\":{\"245\":4}}],[\"isanagram\",{\"1\":{\"169\":1}}],[\"ishappy\",{\"1\":{\"112\":1}}],[\"isvalid\",{\"1\":{\"104\":1}}],[\"isempty\",{\"1\":{\"50\":2,\"104\":3,\"147\":1,\"154\":5,\"303\":1}}],[\"is\",{\"1\":{\"1\":1,\"73\":2,\"144\":1,\"151\":5,\"303\":1}}],[\"|s|\",{\"1\":{\"202\":1}}],[\"||\",{\"1\":{\"50\":2,\"53\":1,\"61\":2,\"69\":1,\"104\":1,\"133\":1,\"162\":1,\"311\":1}}],[\"|\",{\"1\":{\"4\":2}}],[\"安装依赖\",{\"1\":{\"4\":1}}],[\"v\",{\"1\":{\"209\":6}}],[\"void\",{\"1\":{\"80\":2,\"144\":1,\"147\":1,\"151\":1,\"154\":2,\"185\":1,\"217\":1,\"238\":4,\"242\":4,\"245\":4,\"294\":1,\"295\":1,\"303\":1}}],[\"valueof\",{\"1\":{\"217\":1}}],[\"value是和出现的次数\",{\"1\":{\"208\":1}}],[\"value\",{\"1\":{\"141\":2,\"257\":1,\"258\":1}}],[\"val==val\",{\"1\":{\"122\":1}}],[\"valid\",{\"1\":{\"99\":1,\"164\":1}}],[\"val\",{\"1\":{\"57\":1,\"61\":2,\"92\":1,\"96\":7,\"116\":8,\"117\":1,\"119\":12,\"122\":9,\"126\":1,\"130\":7,\"158\":1,\"162\":7,\"173\":11,\"175\":1,\"177\":2,\"238\":9,\"242\":15,\"245\":13,\"292\":2,\"307\":1,\"311\":2}}],[\"vue\",{\"1\":{\"33\":2}}],[\"vuepress\",{\"0\":{\"17\":1},\"1\":{\"4\":2,\"13\":2,\"15\":2,\"16\":1,\"17\":2,\"18\":1,\"32\":1}}],[\"version\",{\"1\":{\"4\":1}}],[\"v4\",{\"1\":{\"4\":4}}],[\"j++\",{\"1\":{\"225\":1}}],[\"j代表列\",{\"1\":{\"225\":1}}],[\"join\",{\"1\":{\"76\":1}}],[\"jobs\",{\"1\":{\"4\":1}}],[\"j\",{\"1\":{\"65\":4,\"67\":8,\"69\":12,\"77\":1,\"78\":5,\"206\":3,\"225\":7}}],[\"java\",{\"1\":{\"42\":2,\"50\":2,\"61\":2,\"69\":2,\"76\":1,\"78\":2,\"80\":1,\"88\":2,\"96\":2,\"104\":2,\"112\":2,\"119\":2,\"130\":2,\"141\":2,\"147\":2,\"154\":2,\"162\":2,\"169\":2,\"177\":2,\"185\":2,\"194\":2,\"202\":2,\"209\":2,\"217\":2,\"225\":2,\"232\":1,\"242\":2,\"253\":2,\"274\":1,\"299\":1,\"302\":2,\"303\":6,\"311\":2}}],[\"jamesives\",{\"1\":{\"4\":1}}],[\"js\",{\"1\":{\"4\":1}}],[\"nagaram\",{\"1\":{\"165\":1}}],[\"name\",{\"1\":{\"4\":7}}],[\"n个正整数的数组和一个正整数\",{\"1\":{\"137\":1}}],[\"n个\",{\"1\":{\"104\":1}}],[\"n+1\",{\"1\":{\"94\":1,\"95\":1}}],[\"nth\",{\"1\":{\"91\":1}}],[\"n2\",{\"1\":{\"69\":2,\"209\":2,\"225\":1,\"271\":1}}],[\"nlogn\",{\"1\":{\"67\":1,\"69\":1,\"88\":1}}],[\"n3+nlogn\",{\"1\":{\"88\":1}}],[\"n3\",{\"1\":{\"67\":1,\"88\":3}}],[\"n−1\",{\"1\":{\"59\":1,\"251\":1}}],[\"next=pre\",{\"1\":{\"129\":1}}],[\"next=prev\",{\"1\":{\"122\":1}}],[\"next=head\",{\"1\":{\"122\":1}}],[\"next=cur\",{\"1\":{\"118\":1,\"129\":1}}],[\"next\",{\"1\":{\"57\":1,\"61\":9,\"96\":12,\"118\":2,\"119\":11,\"121\":1,\"122\":10,\"129\":2,\"130\":8,\"133\":5,\"160\":7,\"162\":17,\"238\":2,\"242\":21,\"245\":15,\"292\":1,\"294\":1,\"295\":1,\"296\":8,\"297\":2,\"311\":4}}],[\"newnode\",{\"1\":{\"242\":10,\"294\":4,\"295\":4}}],[\"new\",{\"1\":{\"42\":3,\"50\":2,\"53\":2,\"69\":2,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"144\":1,\"147\":2,\"151\":1,\"154\":3,\"162\":1,\"169\":1,\"194\":4,\"202\":1,\"209\":1,\"225\":1,\"238\":1,\"242\":5,\"245\":5,\"253\":1,\"294\":1,\"295\":1,\"303\":1}}],[\"num<=tar\",{\"1\":{\"223\":1}}],[\"num\",{\"1\":{\"175\":1,\"177\":3}}],[\"number\",{\"1\":{\"107\":1}}],[\"nums4\",{\"1\":{\"206\":8}}],[\"nums3\",{\"1\":{\"206\":8}}],[\"nums2\",{\"1\":{\"189\":5,\"194\":2,\"206\":8}}],[\"nums1\",{\"1\":{\"189\":5,\"194\":2,\"206\":8}}],[\"numsr\",{\"1\":{\"137\":2}}],[\"numsl+1\",{\"1\":{\"137\":1}}],[\"numsl\",{\"1\":{\"137\":1}}],[\"nums\",{\"1\":{\"38\":8,\"42\":5,\"65\":21,\"67\":8,\"69\":23,\"84\":13,\"88\":26,\"137\":5,\"141\":4,\"173\":20,\"175\":2,\"177\":3,\"228\":8,\"230\":3,\"232\":4,\"233\":7,\"234\":4,\"249\":6,\"253\":17,\"267\":9,\"268\":15,\"269\":9}}],[\"null\",{\"1\":{\"50\":1,\"53\":1,\"57\":2,\"59\":1,\"61\":7,\"69\":1,\"96\":3,\"119\":3,\"130\":3,\"133\":3,\"144\":3,\"151\":3,\"162\":4,\"238\":5,\"242\":5,\"244\":1,\"245\":3,\"287\":1,\"294\":2,\"295\":2,\"296\":5,\"297\":4,\"307\":3,\"309\":1,\"310\":1,\"311\":6}}],[\"n\",{\"0\":{\"91\":1,\"281\":1},\"1\":{\"38\":1,\"42\":3,\"50\":3,\"53\":4,\"59\":2,\"61\":2,\"69\":1,\"76\":4,\"78\":4,\"80\":6,\"84\":2,\"88\":12,\"92\":5,\"94\":1,\"96\":7,\"104\":3,\"108\":5,\"110\":4,\"112\":10,\"119\":2,\"122\":2,\"130\":2,\"133\":4,\"137\":3,\"141\":5,\"147\":4,\"151\":2,\"154\":5,\"162\":2,\"169\":2,\"177\":2,\"181\":4,\"184\":1,\"185\":3,\"194\":1,\"202\":2,\"206\":7,\"209\":1,\"216\":1,\"217\":8,\"221\":7,\"223\":2,\"225\":8,\"228\":2,\"232\":1,\"242\":4,\"245\":3,\"249\":1,\"253\":2,\"257\":3,\"265\":1,\"271\":1,\"281\":3,\"298\":1,\"307\":4}}],[\"not\",{\"1\":{\"313\":1}}],[\"note\",{\"1\":{\"197\":1}}],[\"nojekyll\",{\"1\":{\"4\":1}}],[\"node<>\",{\"1\":{\"294\":1,\"295\":1}}],[\"node<e>\",{\"1\":{\"294\":2,\"295\":2,\"296\":3,\"297\":2}}],[\"nodes\",{\"1\":{\"157\":1}}],[\"node\",{\"1\":{\"4\":4,\"57\":1,\"91\":1,\"92\":1,\"116\":2,\"126\":1,\"158\":1,\"240\":1,\"242\":17,\"245\":34,\"292\":1,\"307\":1}}],[\"temp\",{\"1\":{\"185\":2}}],[\"tex\",{\"0\":{\"22\":1}}],[\"tail\",{\"1\":{\"243\":1,\"245\":9}}],[\"table\",{\"1\":{\"169\":4}}],[\"target\",{\"1\":{\"38\":6,\"40\":3,\"41\":1,\"42\":3,\"84\":5,\"88\":8,\"137\":5,\"141\":2,\"225\":2,\"228\":4,\"232\":3,\"233\":3,\"234\":3,\"267\":6,\"268\":14,\"269\":8}}],[\"t\",{\"1\":{\"165\":8,\"167\":3,\"169\":3}}],[\"tmp\",{\"1\":{\"80\":2}}],[\"trimspaces\",{\"1\":{\"79\":1,\"80\":2}}],[\"trim\",{\"1\":{\"76\":1,\"78\":2}}],[\"true\",{\"1\":{\"4\":1,\"61\":1,\"100\":2,\"104\":1,\"108\":2,\"112\":1,\"144\":1,\"151\":1,\"165\":1,\"169\":1,\"198\":2,\"202\":1,\"297\":2}}],[\"tt\",{\"1\":{\"51\":3,\"53\":6}}],[\"to\",{\"1\":{\"144\":1,\"151\":1}}],[\"top++\",{\"1\":{\"225\":1}}],[\"top==bottom\",{\"1\":{\"223\":1}}],[\"top\",{\"1\":{\"144\":6,\"147\":2,\"151\":2,\"223\":1,\"225\":6}}],[\"totalsum\",{\"1\":{\"112\":3}}],[\"tostring\",{\"1\":{\"50\":1,\"78\":1,\"80\":1}}],[\"tochararray\",{\"1\":{\"50\":1,\"53\":1,\"104\":1,\"202\":2,\"217\":1}}],[\"toc\",{\"1\":{\"10\":1}}],[\"twosum\",{\"1\":{\"42\":1}}],[\"two\",{\"1\":{\"37\":1,\"188\":1,\"306\":1}}],[\"title\",{\"1\":{\"30\":3}}],[\"throw\",{\"1\":{\"303\":1}}],[\"threesum\",{\"1\":{\"69\":1}}],[\"the\",{\"1\":{\"30\":1,\"73\":2,\"151\":1,\"303\":1}}],[\"this\",{\"1\":{\"1\":1,\"96\":3,\"119\":3,\"122\":3,\"130\":3,\"162\":3,\"242\":1}}],[\"skipb\",{\"1\":{\"307\":6}}],[\"skipa\",{\"1\":{\"307\":6}}],[\"sky\",{\"1\":{\"73\":2}}],[\"squares\",{\"1\":{\"248\":1}}],[\"swappairs\",{\"1\":{\"162\":1}}],[\"swap\",{\"1\":{\"157\":1,\"303\":3}}],[\"search\",{\"1\":{\"227\":1,\"232\":1,\"233\":1,\"234\":1,\"269\":1}}],[\"secod\",{\"1\":{\"160\":1}}],[\"second=cur\",{\"1\":{\"160\":1}}],[\"second\",{\"1\":{\"94\":3,\"96\":6,\"160\":3,\"162\":4,\"311\":5}}],[\"set\",{\"1\":{\"303\":1}}],[\"setcharat\",{\"1\":{\"80\":2}}],[\"setup\",{\"1\":{\"4\":2}}],[\"sz\",{\"1\":{\"92\":3,\"245\":2}}],[\"s+\",{\"1\":{\"76\":1}}],[\"spiral\",{\"1\":{\"220\":1}}],[\"split\",{\"1\":{\"75\":1,\"76\":1}}],[\"space\",{\"1\":{\"4\":1}}],[\"sortedsquares\",{\"1\":{\"253\":1}}],[\"sorted\",{\"1\":{\"248\":1}}],[\"sort\",{\"1\":{\"69\":1,\"88\":1,\"173\":1}}],[\"solution\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"122\":1,\"130\":1,\"133\":1,\"141\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"253\":1,\"311\":1}}],[\"size++\",{\"1\":{\"242\":3,\"245\":3,\"294\":1,\"295\":1}}],[\"size\",{\"1\":{\"136\":1,\"144\":1,\"147\":2,\"151\":1,\"194\":1,\"241\":1,\"242\":7,\"245\":4,\"296\":1,\"303\":5}}],[\"size=8192\",{\"1\":{\"4\":1}}],[\"singly\",{\"1\":{\"61\":1,\"96\":1,\"119\":1,\"122\":1,\"130\":1,\"162\":1,\"311\":1}}],[\"slow将到达链表中的一半\",{\"1\":{\"112\":1}}],[\"slowrunner\",{\"1\":{\"112\":4}}],[\"slow在链表中前进\",{\"1\":{\"110\":1}}],[\"slow\",{\"1\":{\"59\":8,\"61\":12,\"110\":1,\"112\":1}}],[\"sb\",{\"1\":{\"50\":3,\"80\":20}}],[\"s\",{\"1\":{\"46\":4,\"50\":5,\"53\":6,\"73\":9,\"76\":4,\"77\":1,\"78\":7,\"80\":7,\"100\":6,\"104\":4,\"165\":8,\"167\":3,\"169\":4,\"181\":5,\"184\":2,\"185\":6,\"202\":1,\"213\":5,\"217\":3}}],[\"stacks\",{\"1\":{\"150\":1}}],[\"stack\",{\"1\":{\"143\":1,\"274\":1,\"276\":1}}],[\"start++\",{\"1\":{\"141\":1}}],[\"start\",{\"1\":{\"80\":4,\"139\":2,\"140\":1,\"141\":5}}],[\"stringbuilder\",{\"1\":{\"50\":2,\"78\":3,\"80\":6}}],[\"string\",{\"1\":{\"45\":1,\"50\":2,\"53\":3,\"72\":1,\"76\":3,\"78\":2,\"80\":3,\"104\":1,\"169\":2,\"180\":1,\"202\":2,\"212\":1,\"217\":3}}],[\"steps\",{\"1\":{\"4\":1}}],[\"such\",{\"1\":{\"154\":1,\"242\":1}}],[\"subarray\",{\"1\":{\"136\":1}}],[\"substring\",{\"1\":{\"78\":1}}],[\"submissions\",{\"1\":{\"72\":1}}],[\"submodules\",{\"1\":{\"4\":1}}],[\"sumcd\",{\"1\":{\"208\":2}}],[\"sum\",{\"1\":{\"37\":1,\"69\":4,\"88\":4,\"136\":1,\"139\":2,\"141\":4}}],[\"src\",{\"1\":{\"4\":2}}],[\"wordlist\",{\"1\":{\"76\":3}}],[\"words\",{\"1\":{\"72\":1}}],[\"world\",{\"1\":{\"73\":2}}],[\"while\",{\"1\":{\"50\":1,\"61\":2,\"69\":5,\"78\":3,\"80\":6,\"88\":3,\"96\":1,\"112\":2,\"119\":2,\"122\":1,\"130\":1,\"141\":2,\"147\":2,\"154\":1,\"162\":1,\"185\":1,\"217\":1,\"225\":1,\"232\":1,\"233\":1,\"234\":1,\"242\":1,\"253\":1,\"267\":3,\"268\":2,\"269\":1,\"303\":2,\"311\":1}}],[\"will\",{\"1\":{\"30\":1,\"154\":1,\"242\":1}}],[\"with\",{\"1\":{\"4\":3,\"303\":1}}],[\"write\",{\"1\":{\"4\":1}}],[\"util\",{\"1\":{\"303\":6}}],[\"until\",{\"1\":{\"303\":1}}],[\"unlink\",{\"1\":{\"296\":1,\"297\":2}}],[\"unicode\",{\"1\":{\"165\":1}}],[\"u\",{\"1\":{\"209\":6}}],[\"using\",{\"1\":{\"143\":1,\"150\":1}}],[\"uses\",{\"1\":{\"4\":4}}],[\"ubuntu\",{\"1\":{\"4\":1}}],[\"c=0\",{\"1\":{\"311\":1}}],[\"c1\",{\"1\":{\"307\":1}}],[\"cs\",{\"1\":{\"217\":8}}],[\"cur=dummy\",{\"1\":{\"160\":1}}],[\"cur=next\",{\"1\":{\"129\":1}}],[\"currentindex\",{\"1\":{\"303\":15}}],[\"curr\",{\"1\":{\"130\":7}}],[\"cur\",{\"1\":{\"118\":1,\"128\":1,\"129\":1,\"160\":3,\"162\":7,\"245\":18}}],[\"cycle\",{\"1\":{\"56\":1}}],[\"c\",{\"1\":{\"50\":3,\"51\":1,\"53\":3,\"80\":4,\"84\":4,\"104\":5,\"202\":5,\"208\":1,\"209\":2,\"217\":2,\"309\":5,\"311\":3}}],[\"charat\",{\"1\":{\"78\":2,\"80\":7,\"169\":2}}],[\"char\",{\"1\":{\"50\":1,\"53\":3,\"80\":2,\"104\":1,\"185\":2,\"202\":2,\"217\":3}}],[\"checkout\",{\"1\":{\"4\":2}}],[\"cap\",{\"1\":{\"258\":1}}],[\"canconstruct\",{\"1\":{\"202\":1}}],[\"car\",{\"1\":{\"165\":1}}],[\"called\",{\"1\":{\"154\":1,\"242\":1}}],[\"ca\",{\"1\":{\"46\":2}}],[\"cache\",{\"1\":{\"4\":1}}],[\"class\",{\"1\":{\"42\":1,\"50\":1,\"53\":1,\"61\":2,\"69\":1,\"76\":1,\"78\":1,\"80\":1,\"88\":1,\"96\":2,\"104\":1,\"112\":1,\"119\":2,\"122\":2,\"130\":2,\"133\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":2,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":2,\"245\":2,\"253\":1,\"292\":1,\"311\":2}}],[\"compare\",{\"1\":{\"303\":1}}],[\"comparator\",{\"1\":{\"303\":1}}],[\"comparable\",{\"1\":{\"303\":1}}],[\"concurrent\",{\"1\":{\"303\":1}}],[\"condition\",{\"1\":{\"267\":1}}],[\"continue\",{\"1\":{\"69\":1,\"88\":4}}],[\"containskey\",{\"1\":{\"42\":1,\"209\":1}}],[\"contents\",{\"1\":{\"4\":1}}],[\"count++\",{\"1\":{\"225\":4}}],[\"count\",{\"1\":{\"225\":2}}],[\"countab\",{\"1\":{\"209\":5}}],[\"collections\",{\"1\":{\"76\":1}}],[\"code\",{\"1\":{\"42\":1,\"50\":1,\"61\":1,\"69\":1,\"76\":1,\"78\":1,\"88\":1,\"96\":1,\"104\":1,\"112\":1,\"119\":1,\"130\":1,\"141\":1,\"147\":1,\"154\":1,\"162\":1,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"242\":1,\"253\":1,\"311\":1}}],[\"corepack\",{\"1\":{\"4\":1}}],[\"cnt\",{\"1\":{\"202\":4}}],[\"cn\",{\"1\":{\"4\":1,\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"294\":1,\"295\":1,\"296\":1,\"297\":1,\"306\":1}}],[\"m\",{\"1\":{\"281\":1,\"307\":3}}],[\"mid+\",{\"1\":{\"269\":1}}],[\"mid+1\",{\"1\":{\"267\":1}}],[\"mid−1\",{\"1\":{\"230\":1,\"267\":1}}],[\"mid\",{\"1\":{\"230\":6,\"232\":6,\"233\":8,\"234\":6,\"267\":12,\"268\":11,\"269\":10}}],[\"min\",{\"1\":{\"141\":1,\"216\":1,\"217\":1}}],[\"minsubarraylen\",{\"1\":{\"141\":1}}],[\"minimum\",{\"1\":{\"136\":1}}],[\"m+n\",{\"1\":{\"194\":3}}],[\"m为nums2数组长度\",{\"1\":{\"194\":1}}],[\"mylinkedlist\",{\"1\":{\"238\":13,\"242\":5,\"245\":2}}],[\"myqueue\",{\"1\":{\"151\":10,\"154\":5}}],[\"mystack\",{\"1\":{\"144\":10,\"147\":2}}],[\"ms\",{\"1\":{\"31\":1}}],[\"more\",{\"1\":{\"29\":1}}],[\"md\",{\"1\":{\"18\":1}}],[\"matrix\",{\"1\":{\"220\":1,\"221\":1}}],[\"math\",{\"1\":{\"141\":1,\"216\":1,\"217\":1,\"253\":6}}],[\"magazine\",{\"1\":{\"198\":8,\"200\":3,\"202\":3}}],[\"map\",{\"1\":{\"42\":4}}],[\"map<integer\",{\"1\":{\"42\":1,\"209\":1}}],[\"markdown\",{\"0\":{\"13\":1,\"14\":1,\"15\":1,\"16\":1},\"1\":{\"13\":2,\"14\":3,\"15\":1,\"16\":3,\"17\":2,\"18\":1,\"30\":3,\"31\":1,\"32\":2,\"33\":2},\"2\":{\"28\":1}}],[\"max\",{\"1\":{\"4\":1,\"141\":2}}],[\"master\",{\"1\":{\"4\":2}}],[\"me\",{\"1\":{\"1\":1}}],[\"property\",{\"1\":{\"303\":1}}],[\"problems\",{\"1\":{\"37\":1,\"45\":1,\"56\":1,\"64\":1,\"72\":1,\"83\":1,\"91\":1,\"99\":1,\"107\":1,\"115\":1,\"125\":1,\"136\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"172\":1,\"180\":1,\"188\":1,\"197\":1,\"205\":1,\"212\":1,\"220\":1,\"227\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"priorityqueue\",{\"1\":{\"303\":3}}],[\"private\",{\"1\":{\"154\":1}}],[\"pre=cur\",{\"1\":{\"129\":1}}],[\"pre\",{\"1\":{\"128\":1}}],[\"prevent\",{\"1\":{\"267\":1}}],[\"prev=prev\",{\"1\":{\"122\":1}}],[\"prev=dummynode\",{\"1\":{\"122\":1}}],[\"prev\",{\"1\":{\"119\":7,\"122\":3,\"130\":5,\"238\":1,\"245\":17,\"294\":1,\"296\":8}}],[\"pairs\",{\"1\":{\"157\":1}}],[\"parent\",{\"1\":{\"303\":1}}],[\"parentindex\",{\"1\":{\"303\":5}}],[\"parentheses\",{\"1\":{\"99\":1}}],[\"param\",{\"1\":{\"154\":3,\"242\":1}}],[\"pages\",{\"1\":{\"4\":4}}],[\"page\",{\"1\":{\"4\":1,\"30\":1}}],[\"python\",{\"1\":{\"80\":1}}],[\"poppedelement\",{\"1\":{\"303\":2}}],[\"pop\",{\"1\":{\"144\":7,\"147\":2,\"151\":7,\"153\":2,\"154\":5,\"274\":2,\"303\":1}}],[\"pos\",{\"1\":{\"57\":7}}],[\"poll\",{\"1\":{\"50\":1,\"147\":3}}],[\"polllast\",{\"1\":{\"50\":1,\"104\":1}}],[\"peek\",{\"1\":{\"144\":1,\"147\":1,\"151\":7,\"153\":1,\"154\":4}}],[\"peeklast\",{\"1\":{\"50\":1}}],[\"permissions\",{\"1\":{\"4\":1}}],[\"put\",{\"1\":{\"42\":1,\"209\":1}}],[\"public\",{\"1\":{\"32\":1,\"42\":1,\"50\":1,\"53\":1,\"61\":2,\"69\":1,\"76\":1,\"78\":1,\"80\":4,\"88\":1,\"96\":2,\"104\":1,\"112\":2,\"119\":2,\"122\":2,\"130\":2,\"133\":1,\"141\":1,\"147\":5,\"154\":5,\"162\":2,\"169\":1,\"177\":1,\"185\":1,\"194\":1,\"202\":1,\"209\":1,\"217\":1,\"225\":1,\"232\":1,\"233\":1,\"234\":1,\"242\":7,\"245\":6,\"253\":1,\"267\":1,\"269\":1,\"297\":1,\"303\":2,\"311\":3}}],[\"push\",{\"1\":{\"4\":1,\"144\":8,\"147\":2,\"151\":8,\"153\":1,\"154\":6,\"274\":2}}],[\"plugin\",{\"1\":{\"18\":1}}],[\"pnpm\",{\"1\":{\"4\":5}}],[\"部署文档\",{\"1\":{\"4\":3}}],[\"部署到\",{\"1\":{\"4\":1}}],[\"部署到ssh\",{\"1\":{\"4\":1}}],[\"generatematrix\",{\"1\":{\"225\":1}}],[\"getintersectionnode\",{\"1\":{\"311\":1}}],[\"getnode\",{\"1\":{\"240\":1,\"242\":4,\"245\":4}}],[\"getnext\",{\"1\":{\"110\":2,\"112\":5}}],[\"getordefault\",{\"1\":{\"209\":1}}],[\"get\",{\"1\":{\"42\":1,\"209\":1,\"238\":6,\"242\":3,\"245\":2,\"303\":8}}],[\"good\",{\"1\":{\"73\":2}}],[\"git\",{\"1\":{\"4\":1}}],[\"github\",{\"1\":{\"4\":2}}],[\"gh\",{\"1\":{\"4\":3}}],[\"1<\",{\"1\":{\"130\":1}}],[\"121\",{\"1\":{\"249\":1}}],[\"12\",{\"1\":{\"108\":2,\"228\":2}}],[\"19\",{\"0\":{\"90\":1,\"91\":1},\"1\":{\"108\":1,\"281\":1}}],[\"19th\",{\"1\":{\"25\":1}}],[\"18\",{\"0\":{\"82\":1,\"83\":1}}],[\"142\",{\"0\":{\"55\":1,\"56\":1},\"1\":{\"284\":1}}],[\"105\",{\"1\":{\"137\":2}}],[\"104\",{\"1\":{\"100\":1}}],[\"1047\",{\"0\":{\"44\":1,\"45\":1}}],[\"1002\",{\"1\":{\"194\":3}}],[\"10000\",{\"1\":{\"228\":1}}],[\"1000\",{\"1\":{\"189\":2,\"238\":1}}],[\"100\",{\"1\":{\"92\":1,\"108\":1,\"144\":1,\"151\":1,\"158\":2,\"173\":2,\"249\":3}}],[\"109\",{\"1\":{\"84\":4,\"137\":1}}],[\"10\",{\"1\":{\"38\":5,\"57\":3,\"65\":2,\"73\":1,\"112\":2,\"116\":1,\"165\":1,\"181\":1,\"198\":1,\"213\":2,\"249\":4,\"307\":2}}],[\"11\",{\"1\":{\"38\":1,\"137\":1,\"249\":1}}],[\"151\",{\"0\":{\"71\":1,\"72\":1}}],[\"15\",{\"0\":{\"63\":1,\"64\":1},\"1\":{\"4\":1,\"38\":1,\"86\":1}}],[\"1\",{\"0\":{\"36\":1,\"37\":1,\"48\":1,\"75\":1,\"94\":1,\"175\":1,\"267\":1},\"1\":{\"4\":1,\"20\":1,\"23\":1,\"31\":2,\"33\":2,\"38\":6,\"46\":1,\"53\":2,\"57\":9,\"59\":2,\"61\":2,\"65\":22,\"67\":1,\"69\":4,\"73\":3,\"78\":3,\"80\":5,\"84\":8,\"88\":12,\"92\":10,\"96\":3,\"100\":2,\"104\":1,\"108\":7,\"110\":2,\"112\":3,\"116\":5,\"119\":1,\"122\":2,\"126\":5,\"130\":4,\"137\":16,\"141\":3,\"144\":3,\"147\":3,\"151\":11,\"154\":3,\"158\":5,\"162\":1,\"165\":2,\"169\":1,\"173\":4,\"175\":2,\"177\":1,\"181\":3,\"184\":1,\"185\":3,\"189\":4,\"198\":2,\"206\":17,\"209\":2,\"213\":3,\"215\":1,\"216\":1,\"217\":4,\"221\":6,\"225\":4,\"228\":7,\"232\":2,\"233\":2,\"234\":5,\"238\":13,\"242\":8,\"245\":8,\"249\":6,\"253\":2,\"257\":6,\"265\":1,\"267\":9,\"268\":7,\"269\":9,\"298\":1,\"303\":8,\"307\":15,\"311\":1}}],[\"16\",{\"1\":{\"4\":1,\"249\":3}}],[\"17\",{\"1\":{\"4\":1}}],[\"dummy\",{\"1\":{\"162\":4}}],[\"dummynode=new\",{\"1\":{\"122\":1}}],[\"dummynode\",{\"1\":{\"121\":1,\"122\":2}}],[\"dummyhead\",{\"1\":{\"94\":1,\"96\":3}}],[\"duplicates\",{\"1\":{\"45\":1}}],[\"d互不相同\",{\"1\":{\"84\":1}}],[\"d\",{\"1\":{\"51\":1,\"53\":4,\"84\":3,\"112\":3,\"208\":1,\"209\":2}}],[\"delayed\",{\"1\":{\"303\":1}}],[\"delay\",{\"1\":{\"303\":2}}],[\"deleteatindex\",{\"1\":{\"238\":4,\"242\":2,\"245\":1}}],[\"design\",{\"1\":{\"237\":1}}],[\"description\",{\"1\":{\"45\":1,\"56\":1,\"64\":1,\"83\":1,\"91\":1,\"99\":1,\"115\":1,\"143\":1,\"150\":1,\"157\":1,\"164\":1,\"197\":1,\"205\":1,\"212\":1,\"237\":1,\"248\":1,\"306\":1}}],[\"deque<integer>\",{\"1\":{\"154\":1}}],[\"deque<character>\",{\"1\":{\"50\":1,\"104\":1}}],[\"deque\",{\"1\":{\"144\":1,\"151\":1,\"302\":1,\"303\":2}}],[\"detectcycle\",{\"1\":{\"61\":1}}],[\"definition\",{\"1\":{\"61\":1,\"96\":1,\"119\":1,\"122\":1,\"130\":1,\"162\":1,\"311\":1}}],[\"depth\",{\"1\":{\"4\":1}}],[\"deploy\",{\"1\":{\"4\":4}}],[\"dist\",{\"1\":{\"4\":2}}],[\"double\",{\"1\":{\"303\":1}}],[\"doublew2w\",{\"1\":{\"4\":1}}],[\"docs\",{\"1\":{\"4\":1}}],[\"域名解析\",{\"1\":{\"4\":1}}],[\"完善\",{\"1\":{\"4\":2}}],[\"介绍\",{\"0\":{\"1\":1,\"14\":1},\"1\":{\"14\":1,\"15\":1}}],[\"档案主页\",{\"0\":{\"0\":1},\"1\":{\"1\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
